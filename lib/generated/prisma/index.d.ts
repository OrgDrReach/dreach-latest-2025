
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationRequest
 * 
 */
export type VerificationRequest = $Result.DefaultSelection<Prisma.$VerificationRequestPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model AdminPanel
 * 
 */
export type AdminPanel = $Result.DefaultSelection<Prisma.$AdminPanelPayload>
/**
 * Model SuperAdmin
 * 
 */
export type SuperAdmin = $Result.DefaultSelection<Prisma.$SuperAdminPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model ServiceProvider
 * 
 */
export type ServiceProvider = $Result.DefaultSelection<Prisma.$ServiceProviderPayload>
/**
 * Model Doctor
 * 
 */
export type Doctor = $Result.DefaultSelection<Prisma.$DoctorPayload>
/**
 * Model DoctorsAssistant
 * 
 */
export type DoctorsAssistant = $Result.DefaultSelection<Prisma.$DoctorsAssistantPayload>
/**
 * Model Lab
 * 
 */
export type Lab = $Result.DefaultSelection<Prisma.$LabPayload>
/**
 * Model Hospital
 * 
 */
export type Hospital = $Result.DefaultSelection<Prisma.$HospitalPayload>
/**
 * Model Nursing
 * 
 */
export type Nursing = $Result.DefaultSelection<Prisma.$NursingPayload>
/**
 * Model Allergy
 * 
 */
export type Allergy = $Result.DefaultSelection<Prisma.$AllergyPayload>
/**
 * Model Medication
 * 
 */
export type Medication = $Result.DefaultSelection<Prisma.$MedicationPayload>
/**
 * Model LabResult
 * 
 */
export type LabResult = $Result.DefaultSelection<Prisma.$LabResultPayload>
/**
 * Model MedicalRecord
 * 
 */
export type MedicalRecord = $Result.DefaultSelection<Prisma.$MedicalRecordPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model TherapyPlan
 * 
 */
export type TherapyPlan = $Result.DefaultSelection<Prisma.$TherapyPlanPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model RequestPermission
 * 
 */
export type RequestPermission = $Result.DefaultSelection<Prisma.$RequestPermissionPayload>
/**
 * Model Request
 * 
 */
export type Request = $Result.DefaultSelection<Prisma.$RequestPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model OthersAppointment
 * 
 */
export type OthersAppointment = $Result.DefaultSelection<Prisma.$OthersAppointmentPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model Slot
 * 
 */
export type Slot = $Result.DefaultSelection<Prisma.$SlotPayload>
/**
 * Model ClinicInfo
 * 
 */
export type ClinicInfo = $Result.DefaultSelection<Prisma.$ClinicInfoPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Education
 * 
 */
export type Education = $Result.DefaultSelection<Prisma.$EducationPayload>
/**
 * Model WorkExperience
 * 
 */
export type WorkExperience = $Result.DefaultSelection<Prisma.$WorkExperiencePayload>
/**
 * Model Award
 * 
 */
export type Award = $Result.DefaultSelection<Prisma.$AwardPayload>
/**
 * Model CurrentLocation
 * 
 */
export type CurrentLocation = $Result.DefaultSelection<Prisma.$CurrentLocationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  Patient: 'Patient',
  SuperAdmin: 'SuperAdmin',
  Admin: 'Admin',
  Doctor: 'Doctor',
  Hospital: 'Hospital',
  Lab: 'Lab',
  Nursing: 'Nursing',
  DoctorsAssistant: 'DoctorsAssistant'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  BLOCKED: 'BLOCKED',
  DELETED: 'DELETED',
  ARCHIVED: 'ARCHIVED',
  SUSPENDED: 'SUSPENDED',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED',
  INITIATED: 'INITIATED',
  PAID: 'PAID',
  REFUNDED: 'REFUNDED',
  FAILED: 'FAILED',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const PaymentStatus: {
  INITIATED: 'INITIATED',
  PAID: 'PAID',
  REFUNDED: 'REFUNDED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const AppointmentStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const ScheduleStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type ScheduleStatus = (typeof ScheduleStatus)[keyof typeof ScheduleStatus]


export const ActionType: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  VIEW: 'VIEW'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]


export const BloodGroup: {
  A_POSITIVE: 'A_POSITIVE',
  A_NEGATIVE: 'A_NEGATIVE',
  B_POSITIVE: 'B_POSITIVE',
  B_NEGATIVE: 'B_NEGATIVE',
  O_POSITIVE: 'O_POSITIVE',
  O_NEGATIVE: 'O_NEGATIVE',
  AB_POSITIVE: 'AB_POSITIVE',
  AB_NEGATIVE: 'AB_NEGATIVE'
};

export type BloodGroup = (typeof BloodGroup)[keyof typeof BloodGroup]


export const Service: {
  HomeCare: 'HomeCare',
  VideoConsultation: 'VideoConsultation',
  OndeskAppointment: 'OndeskAppointment',
  IntegratedCare: 'IntegratedCare',
  CollaborativeCare: 'CollaborativeCare',
  LabTest: 'LabTest'
};

export type Service = (typeof Service)[keyof typeof Service]


export const PaymentMethod: {
  UPI: 'UPI',
  CARD: 'CARD',
  NET_BANKING: 'NET_BANKING',
  CASH: 'CASH',
  WALLET: 'WALLET'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PermissionType: {
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  PENDING: 'PENDING',
  VIEW: 'VIEW',
  EDIT: 'EDIT',
  DELETE: 'DELETE',
  CREATE: 'CREATE',
  UPDATE: 'UPDATE'
};

export type PermissionType = (typeof PermissionType)[keyof typeof PermissionType]


export const ProviderType: {
  Doctor: 'Doctor',
  Hospital: 'Hospital',
  Lab: 'Lab',
  Nursing: 'Nursing',
  DoctorsAssistant: 'DoctorsAssistant'
};

export type ProviderType = (typeof ProviderType)[keyof typeof ProviderType]


export const WeekDay: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type WeekDay = (typeof WeekDay)[keyof typeof WeekDay]


export const RecurrenceType: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY'
};

export type RecurrenceType = (typeof RecurrenceType)[keyof typeof RecurrenceType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type ScheduleStatus = $Enums.ScheduleStatus

export const ScheduleStatus: typeof $Enums.ScheduleStatus

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

export type BloodGroup = $Enums.BloodGroup

export const BloodGroup: typeof $Enums.BloodGroup

export type Service = $Enums.Service

export const Service: typeof $Enums.Service

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PermissionType = $Enums.PermissionType

export const PermissionType: typeof $Enums.PermissionType

export type ProviderType = $Enums.ProviderType

export const ProviderType: typeof $Enums.ProviderType

export type WeekDay = $Enums.WeekDay

export const WeekDay: typeof $Enums.WeekDay

export type RecurrenceType = $Enums.RecurrenceType

export const RecurrenceType: typeof $Enums.RecurrenceType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationRequest`: Exposes CRUD operations for the **VerificationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationRequests
    * const verificationRequests = await prisma.verificationRequest.findMany()
    * ```
    */
  get verificationRequest(): Prisma.VerificationRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminPanel`: Exposes CRUD operations for the **AdminPanel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminPanels
    * const adminPanels = await prisma.adminPanel.findMany()
    * ```
    */
  get adminPanel(): Prisma.AdminPanelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superAdmin`: Exposes CRUD operations for the **SuperAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdmins
    * const superAdmins = await prisma.superAdmin.findMany()
    * ```
    */
  get superAdmin(): Prisma.SuperAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceProvider`: Exposes CRUD operations for the **ServiceProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceProviders
    * const serviceProviders = await prisma.serviceProvider.findMany()
    * ```
    */
  get serviceProvider(): Prisma.ServiceProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doctorsAssistant`: Exposes CRUD operations for the **DoctorsAssistant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorsAssistants
    * const doctorsAssistants = await prisma.doctorsAssistant.findMany()
    * ```
    */
  get doctorsAssistant(): Prisma.DoctorsAssistantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lab`: Exposes CRUD operations for the **Lab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labs
    * const labs = await prisma.lab.findMany()
    * ```
    */
  get lab(): Prisma.LabDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hospital`: Exposes CRUD operations for the **Hospital** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospitals
    * const hospitals = await prisma.hospital.findMany()
    * ```
    */
  get hospital(): Prisma.HospitalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nursing`: Exposes CRUD operations for the **Nursing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nursings
    * const nursings = await prisma.nursing.findMany()
    * ```
    */
  get nursing(): Prisma.NursingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.allergy`: Exposes CRUD operations for the **Allergy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Allergies
    * const allergies = await prisma.allergy.findMany()
    * ```
    */
  get allergy(): Prisma.AllergyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medication`: Exposes CRUD operations for the **Medication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medication.findMany()
    * ```
    */
  get medication(): Prisma.MedicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labResult`: Exposes CRUD operations for the **LabResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabResults
    * const labResults = await prisma.labResult.findMany()
    * ```
    */
  get labResult(): Prisma.LabResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalRecord`: Exposes CRUD operations for the **MedicalRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalRecords
    * const medicalRecords = await prisma.medicalRecord.findMany()
    * ```
    */
  get medicalRecord(): Prisma.MedicalRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.therapyPlan`: Exposes CRUD operations for the **TherapyPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TherapyPlans
    * const therapyPlans = await prisma.therapyPlan.findMany()
    * ```
    */
  get therapyPlan(): Prisma.TherapyPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestPermission`: Exposes CRUD operations for the **RequestPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestPermissions
    * const requestPermissions = await prisma.requestPermission.findMany()
    * ```
    */
  get requestPermission(): Prisma.RequestPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.request`: Exposes CRUD operations for the **Request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.request.findMany()
    * ```
    */
  get request(): Prisma.RequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.othersAppointment`: Exposes CRUD operations for the **OthersAppointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OthersAppointments
    * const othersAppointments = await prisma.othersAppointment.findMany()
    * ```
    */
  get othersAppointment(): Prisma.OthersAppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slot`: Exposes CRUD operations for the **Slot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Slots
    * const slots = await prisma.slot.findMany()
    * ```
    */
  get slot(): Prisma.SlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicInfo`: Exposes CRUD operations for the **ClinicInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicInfos
    * const clinicInfos = await prisma.clinicInfo.findMany()
    * ```
    */
  get clinicInfo(): Prisma.ClinicInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.education`: Exposes CRUD operations for the **Education** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.education.findMany()
    * ```
    */
  get education(): Prisma.EducationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workExperience`: Exposes CRUD operations for the **WorkExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkExperiences
    * const workExperiences = await prisma.workExperience.findMany()
    * ```
    */
  get workExperience(): Prisma.WorkExperienceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.award`: Exposes CRUD operations for the **Award** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Awards
    * const awards = await prisma.award.findMany()
    * ```
    */
  get award(): Prisma.AwardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currentLocation`: Exposes CRUD operations for the **CurrentLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurrentLocations
    * const currentLocations = await prisma.currentLocation.findMany()
    * ```
    */
  get currentLocation(): Prisma.CurrentLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationRequest: 'VerificationRequest',
    Patient: 'Patient',
    AdminPanel: 'AdminPanel',
    SuperAdmin: 'SuperAdmin',
    Admin: 'Admin',
    ServiceProvider: 'ServiceProvider',
    Doctor: 'Doctor',
    DoctorsAssistant: 'DoctorsAssistant',
    Lab: 'Lab',
    Hospital: 'Hospital',
    Nursing: 'Nursing',
    Allergy: 'Allergy',
    Medication: 'Medication',
    LabResult: 'LabResult',
    MedicalRecord: 'MedicalRecord',
    Prescription: 'Prescription',
    TherapyPlan: 'TherapyPlan',
    Payment: 'Payment',
    Transaction: 'Transaction',
    Rating: 'Rating',
    RequestPermission: 'RequestPermission',
    Request: 'Request',
    Appointment: 'Appointment',
    OthersAppointment: 'OthersAppointment',
    Schedule: 'Schedule',
    Slot: 'Slot',
    ClinicInfo: 'ClinicInfo',
    Address: 'Address',
    Education: 'Education',
    WorkExperience: 'WorkExperience',
    Award: 'Award',
    CurrentLocation: 'CurrentLocation',
    AuditLog: 'AuditLog',
    Notification: 'Notification',
    Tag: 'Tag'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationRequest" | "patient" | "adminPanel" | "superAdmin" | "admin" | "serviceProvider" | "doctor" | "doctorsAssistant" | "lab" | "hospital" | "nursing" | "allergy" | "medication" | "labResult" | "medicalRecord" | "prescription" | "therapyPlan" | "payment" | "transaction" | "rating" | "requestPermission" | "request" | "appointment" | "othersAppointment" | "schedule" | "slot" | "clinicInfo" | "address" | "education" | "workExperience" | "award" | "currentLocation" | "auditLog" | "notification" | "tag"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationRequest: {
        payload: Prisma.$VerificationRequestPayload<ExtArgs>
        fields: Prisma.VerificationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          findFirst: {
            args: Prisma.VerificationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          findMany: {
            args: Prisma.VerificationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>[]
          }
          create: {
            args: Prisma.VerificationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          createMany: {
            args: Prisma.VerificationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>[]
          }
          delete: {
            args: Prisma.VerificationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          update: {
            args: Prisma.VerificationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          deleteMany: {
            args: Prisma.VerificationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>[]
          }
          upsert: {
            args: Prisma.VerificationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          aggregate: {
            args: Prisma.VerificationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationRequest>
          }
          groupBy: {
            args: Prisma.VerificationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationRequestCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      AdminPanel: {
        payload: Prisma.$AdminPanelPayload<ExtArgs>
        fields: Prisma.AdminPanelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminPanelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminPanelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>
          }
          findFirst: {
            args: Prisma.AdminPanelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminPanelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>
          }
          findMany: {
            args: Prisma.AdminPanelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>[]
          }
          create: {
            args: Prisma.AdminPanelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>
          }
          createMany: {
            args: Prisma.AdminPanelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminPanelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>[]
          }
          delete: {
            args: Prisma.AdminPanelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>
          }
          update: {
            args: Prisma.AdminPanelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>
          }
          deleteMany: {
            args: Prisma.AdminPanelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminPanelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminPanelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>[]
          }
          upsert: {
            args: Prisma.AdminPanelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPanelPayload>
          }
          aggregate: {
            args: Prisma.AdminPanelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminPanel>
          }
          groupBy: {
            args: Prisma.AdminPanelGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminPanelGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminPanelCountArgs<ExtArgs>
            result: $Utils.Optional<AdminPanelCountAggregateOutputType> | number
          }
        }
      }
      SuperAdmin: {
        payload: Prisma.$SuperAdminPayload<ExtArgs>
        fields: Prisma.SuperAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findFirst: {
            args: Prisma.SuperAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findMany: {
            args: Prisma.SuperAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          create: {
            args: Prisma.SuperAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          createMany: {
            args: Prisma.SuperAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          delete: {
            args: Prisma.SuperAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          update: {
            args: Prisma.SuperAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuperAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          upsert: {
            args: Prisma.SuperAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          aggregate: {
            args: Prisma.SuperAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdmin>
          }
          groupBy: {
            args: Prisma.SuperAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      ServiceProvider: {
        payload: Prisma.$ServiceProviderPayload<ExtArgs>
        fields: Prisma.ServiceProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          findFirst: {
            args: Prisma.ServiceProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          findMany: {
            args: Prisma.ServiceProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>[]
          }
          create: {
            args: Prisma.ServiceProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          createMany: {
            args: Prisma.ServiceProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>[]
          }
          delete: {
            args: Prisma.ServiceProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          update: {
            args: Prisma.ServiceProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          deleteMany: {
            args: Prisma.ServiceProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>[]
          }
          upsert: {
            args: Prisma.ServiceProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          aggregate: {
            args: Prisma.ServiceProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceProvider>
          }
          groupBy: {
            args: Prisma.ServiceProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceProviderCountAggregateOutputType> | number
          }
        }
      }
      Doctor: {
        payload: Prisma.$DoctorPayload<ExtArgs>
        fields: Prisma.DoctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoctorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      DoctorsAssistant: {
        payload: Prisma.$DoctorsAssistantPayload<ExtArgs>
        fields: Prisma.DoctorsAssistantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorsAssistantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorsAssistantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>
          }
          findFirst: {
            args: Prisma.DoctorsAssistantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorsAssistantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>
          }
          findMany: {
            args: Prisma.DoctorsAssistantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>[]
          }
          create: {
            args: Prisma.DoctorsAssistantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>
          }
          createMany: {
            args: Prisma.DoctorsAssistantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorsAssistantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>[]
          }
          delete: {
            args: Prisma.DoctorsAssistantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>
          }
          update: {
            args: Prisma.DoctorsAssistantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>
          }
          deleteMany: {
            args: Prisma.DoctorsAssistantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorsAssistantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoctorsAssistantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>[]
          }
          upsert: {
            args: Prisma.DoctorsAssistantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsAssistantPayload>
          }
          aggregate: {
            args: Prisma.DoctorsAssistantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorsAssistant>
          }
          groupBy: {
            args: Prisma.DoctorsAssistantGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorsAssistantGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorsAssistantCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorsAssistantCountAggregateOutputType> | number
          }
        }
      }
      Lab: {
        payload: Prisma.$LabPayload<ExtArgs>
        fields: Prisma.LabFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          findFirst: {
            args: Prisma.LabFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          findMany: {
            args: Prisma.LabFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          create: {
            args: Prisma.LabCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          createMany: {
            args: Prisma.LabCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          delete: {
            args: Prisma.LabDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          update: {
            args: Prisma.LabUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          deleteMany: {
            args: Prisma.LabDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          upsert: {
            args: Prisma.LabUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          aggregate: {
            args: Prisma.LabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab>
          }
          groupBy: {
            args: Prisma.LabGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabCountArgs<ExtArgs>
            result: $Utils.Optional<LabCountAggregateOutputType> | number
          }
        }
      }
      Hospital: {
        payload: Prisma.$HospitalPayload<ExtArgs>
        fields: Prisma.HospitalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HospitalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HospitalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findFirst: {
            args: Prisma.HospitalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HospitalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findMany: {
            args: Prisma.HospitalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          create: {
            args: Prisma.HospitalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          createMany: {
            args: Prisma.HospitalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HospitalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          delete: {
            args: Prisma.HospitalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          update: {
            args: Prisma.HospitalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          deleteMany: {
            args: Prisma.HospitalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HospitalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HospitalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          upsert: {
            args: Prisma.HospitalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          aggregate: {
            args: Prisma.HospitalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospital>
          }
          groupBy: {
            args: Prisma.HospitalGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospitalGroupByOutputType>[]
          }
          count: {
            args: Prisma.HospitalCountArgs<ExtArgs>
            result: $Utils.Optional<HospitalCountAggregateOutputType> | number
          }
        }
      }
      Nursing: {
        payload: Prisma.$NursingPayload<ExtArgs>
        fields: Prisma.NursingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NursingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NursingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>
          }
          findFirst: {
            args: Prisma.NursingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NursingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>
          }
          findMany: {
            args: Prisma.NursingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>[]
          }
          create: {
            args: Prisma.NursingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>
          }
          createMany: {
            args: Prisma.NursingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NursingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>[]
          }
          delete: {
            args: Prisma.NursingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>
          }
          update: {
            args: Prisma.NursingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>
          }
          deleteMany: {
            args: Prisma.NursingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NursingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NursingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>[]
          }
          upsert: {
            args: Prisma.NursingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingPayload>
          }
          aggregate: {
            args: Prisma.NursingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNursing>
          }
          groupBy: {
            args: Prisma.NursingGroupByArgs<ExtArgs>
            result: $Utils.Optional<NursingGroupByOutputType>[]
          }
          count: {
            args: Prisma.NursingCountArgs<ExtArgs>
            result: $Utils.Optional<NursingCountAggregateOutputType> | number
          }
        }
      }
      Allergy: {
        payload: Prisma.$AllergyPayload<ExtArgs>
        fields: Prisma.AllergyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllergyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllergyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          findFirst: {
            args: Prisma.AllergyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllergyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          findMany: {
            args: Prisma.AllergyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>[]
          }
          create: {
            args: Prisma.AllergyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          createMany: {
            args: Prisma.AllergyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllergyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>[]
          }
          delete: {
            args: Prisma.AllergyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          update: {
            args: Prisma.AllergyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          deleteMany: {
            args: Prisma.AllergyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllergyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AllergyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>[]
          }
          upsert: {
            args: Prisma.AllergyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          aggregate: {
            args: Prisma.AllergyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllergy>
          }
          groupBy: {
            args: Prisma.AllergyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllergyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllergyCountArgs<ExtArgs>
            result: $Utils.Optional<AllergyCountAggregateOutputType> | number
          }
        }
      }
      Medication: {
        payload: Prisma.$MedicationPayload<ExtArgs>
        fields: Prisma.MedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findMany: {
            args: Prisma.MedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          create: {
            args: Prisma.MedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          createMany: {
            args: Prisma.MedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          delete: {
            args: Prisma.MedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          update: {
            args: Prisma.MedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          upsert: {
            args: Prisma.MedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedication>
          }
          groupBy: {
            args: Prisma.MedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationCountAggregateOutputType> | number
          }
        }
      }
      LabResult: {
        payload: Prisma.$LabResultPayload<ExtArgs>
        fields: Prisma.LabResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          findFirst: {
            args: Prisma.LabResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          findMany: {
            args: Prisma.LabResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          create: {
            args: Prisma.LabResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          createMany: {
            args: Prisma.LabResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          delete: {
            args: Prisma.LabResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          update: {
            args: Prisma.LabResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          deleteMany: {
            args: Prisma.LabResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          upsert: {
            args: Prisma.LabResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          aggregate: {
            args: Prisma.LabResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabResult>
          }
          groupBy: {
            args: Prisma.LabResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabResultCountArgs<ExtArgs>
            result: $Utils.Optional<LabResultCountAggregateOutputType> | number
          }
        }
      }
      MedicalRecord: {
        payload: Prisma.$MedicalRecordPayload<ExtArgs>
        fields: Prisma.MedicalRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          findFirst: {
            args: Prisma.MedicalRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          findMany: {
            args: Prisma.MedicalRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          create: {
            args: Prisma.MedicalRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          createMany: {
            args: Prisma.MedicalRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          delete: {
            args: Prisma.MedicalRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          update: {
            args: Prisma.MedicalRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          deleteMany: {
            args: Prisma.MedicalRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          upsert: {
            args: Prisma.MedicalRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          aggregate: {
            args: Prisma.MedicalRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalRecord>
          }
          groupBy: {
            args: Prisma.MedicalRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalRecordCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      TherapyPlan: {
        payload: Prisma.$TherapyPlanPayload<ExtArgs>
        fields: Prisma.TherapyPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TherapyPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TherapyPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>
          }
          findFirst: {
            args: Prisma.TherapyPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TherapyPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>
          }
          findMany: {
            args: Prisma.TherapyPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>[]
          }
          create: {
            args: Prisma.TherapyPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>
          }
          createMany: {
            args: Prisma.TherapyPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TherapyPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>[]
          }
          delete: {
            args: Prisma.TherapyPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>
          }
          update: {
            args: Prisma.TherapyPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>
          }
          deleteMany: {
            args: Prisma.TherapyPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TherapyPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TherapyPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>[]
          }
          upsert: {
            args: Prisma.TherapyPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TherapyPlanPayload>
          }
          aggregate: {
            args: Prisma.TherapyPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTherapyPlan>
          }
          groupBy: {
            args: Prisma.TherapyPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TherapyPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TherapyPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TherapyPlanCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      RequestPermission: {
        payload: Prisma.$RequestPermissionPayload<ExtArgs>
        fields: Prisma.RequestPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>
          }
          findFirst: {
            args: Prisma.RequestPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>
          }
          findMany: {
            args: Prisma.RequestPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>[]
          }
          create: {
            args: Prisma.RequestPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>
          }
          createMany: {
            args: Prisma.RequestPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>[]
          }
          delete: {
            args: Prisma.RequestPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>
          }
          update: {
            args: Prisma.RequestPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>
          }
          deleteMany: {
            args: Prisma.RequestPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>[]
          }
          upsert: {
            args: Prisma.RequestPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPermissionPayload>
          }
          aggregate: {
            args: Prisma.RequestPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestPermission>
          }
          groupBy: {
            args: Prisma.RequestPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RequestPermissionCountAggregateOutputType> | number
          }
        }
      }
      Request: {
        payload: Prisma.$RequestPayload<ExtArgs>
        fields: Prisma.RequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findFirst: {
            args: Prisma.RequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findMany: {
            args: Prisma.RequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          create: {
            args: Prisma.RequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          createMany: {
            args: Prisma.RequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          delete: {
            args: Prisma.RequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          update: {
            args: Prisma.RequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          deleteMany: {
            args: Prisma.RequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          upsert: {
            args: Prisma.RequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          aggregate: {
            args: Prisma.RequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequest>
          }
          groupBy: {
            args: Prisma.RequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestCountArgs<ExtArgs>
            result: $Utils.Optional<RequestCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      OthersAppointment: {
        payload: Prisma.$OthersAppointmentPayload<ExtArgs>
        fields: Prisma.OthersAppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OthersAppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OthersAppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>
          }
          findFirst: {
            args: Prisma.OthersAppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OthersAppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>
          }
          findMany: {
            args: Prisma.OthersAppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>[]
          }
          create: {
            args: Prisma.OthersAppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>
          }
          createMany: {
            args: Prisma.OthersAppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OthersAppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>[]
          }
          delete: {
            args: Prisma.OthersAppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>
          }
          update: {
            args: Prisma.OthersAppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>
          }
          deleteMany: {
            args: Prisma.OthersAppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OthersAppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OthersAppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>[]
          }
          upsert: {
            args: Prisma.OthersAppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OthersAppointmentPayload>
          }
          aggregate: {
            args: Prisma.OthersAppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOthersAppointment>
          }
          groupBy: {
            args: Prisma.OthersAppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OthersAppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OthersAppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<OthersAppointmentCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      Slot: {
        payload: Prisma.$SlotPayload<ExtArgs>
        fields: Prisma.SlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          findFirst: {
            args: Prisma.SlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          findMany: {
            args: Prisma.SlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>[]
          }
          create: {
            args: Prisma.SlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          createMany: {
            args: Prisma.SlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>[]
          }
          delete: {
            args: Prisma.SlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          update: {
            args: Prisma.SlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          deleteMany: {
            args: Prisma.SlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>[]
          }
          upsert: {
            args: Prisma.SlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          aggregate: {
            args: Prisma.SlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlot>
          }
          groupBy: {
            args: Prisma.SlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.SlotCountArgs<ExtArgs>
            result: $Utils.Optional<SlotCountAggregateOutputType> | number
          }
        }
      }
      ClinicInfo: {
        payload: Prisma.$ClinicInfoPayload<ExtArgs>
        fields: Prisma.ClinicInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>
          }
          findFirst: {
            args: Prisma.ClinicInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>
          }
          findMany: {
            args: Prisma.ClinicInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>[]
          }
          create: {
            args: Prisma.ClinicInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>
          }
          createMany: {
            args: Prisma.ClinicInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>[]
          }
          delete: {
            args: Prisma.ClinicInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>
          }
          update: {
            args: Prisma.ClinicInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>
          }
          deleteMany: {
            args: Prisma.ClinicInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>[]
          }
          upsert: {
            args: Prisma.ClinicInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicInfoPayload>
          }
          aggregate: {
            args: Prisma.ClinicInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicInfo>
          }
          groupBy: {
            args: Prisma.ClinicInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicInfoCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicInfoCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Education: {
        payload: Prisma.$EducationPayload<ExtArgs>
        fields: Prisma.EducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findFirst: {
            args: Prisma.EducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findMany: {
            args: Prisma.EducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          create: {
            args: Prisma.EducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          createMany: {
            args: Prisma.EducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          delete: {
            args: Prisma.EducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          update: {
            args: Prisma.EducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          deleteMany: {
            args: Prisma.EducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EducationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          upsert: {
            args: Prisma.EducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          aggregate: {
            args: Prisma.EducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducation>
          }
          groupBy: {
            args: Prisma.EducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationCountArgs<ExtArgs>
            result: $Utils.Optional<EducationCountAggregateOutputType> | number
          }
        }
      }
      WorkExperience: {
        payload: Prisma.$WorkExperiencePayload<ExtArgs>
        fields: Prisma.WorkExperienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkExperienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkExperienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          findFirst: {
            args: Prisma.WorkExperienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkExperienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          findMany: {
            args: Prisma.WorkExperienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>[]
          }
          create: {
            args: Prisma.WorkExperienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          createMany: {
            args: Prisma.WorkExperienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkExperienceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>[]
          }
          delete: {
            args: Prisma.WorkExperienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          update: {
            args: Prisma.WorkExperienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          deleteMany: {
            args: Prisma.WorkExperienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkExperienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkExperienceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>[]
          }
          upsert: {
            args: Prisma.WorkExperienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          aggregate: {
            args: Prisma.WorkExperienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkExperience>
          }
          groupBy: {
            args: Prisma.WorkExperienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkExperienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkExperienceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkExperienceCountAggregateOutputType> | number
          }
        }
      }
      Award: {
        payload: Prisma.$AwardPayload<ExtArgs>
        fields: Prisma.AwardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AwardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AwardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          findFirst: {
            args: Prisma.AwardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AwardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          findMany: {
            args: Prisma.AwardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>[]
          }
          create: {
            args: Prisma.AwardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          createMany: {
            args: Prisma.AwardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AwardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>[]
          }
          delete: {
            args: Prisma.AwardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          update: {
            args: Prisma.AwardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          deleteMany: {
            args: Prisma.AwardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AwardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AwardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>[]
          }
          upsert: {
            args: Prisma.AwardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          aggregate: {
            args: Prisma.AwardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAward>
          }
          groupBy: {
            args: Prisma.AwardGroupByArgs<ExtArgs>
            result: $Utils.Optional<AwardGroupByOutputType>[]
          }
          count: {
            args: Prisma.AwardCountArgs<ExtArgs>
            result: $Utils.Optional<AwardCountAggregateOutputType> | number
          }
        }
      }
      CurrentLocation: {
        payload: Prisma.$CurrentLocationPayload<ExtArgs>
        fields: Prisma.CurrentLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrentLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrentLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>
          }
          findFirst: {
            args: Prisma.CurrentLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrentLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>
          }
          findMany: {
            args: Prisma.CurrentLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>[]
          }
          create: {
            args: Prisma.CurrentLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>
          }
          createMany: {
            args: Prisma.CurrentLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrentLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>[]
          }
          delete: {
            args: Prisma.CurrentLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>
          }
          update: {
            args: Prisma.CurrentLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>
          }
          deleteMany: {
            args: Prisma.CurrentLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrentLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrentLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>[]
          }
          upsert: {
            args: Prisma.CurrentLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentLocationPayload>
          }
          aggregate: {
            args: Prisma.CurrentLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrentLocation>
          }
          groupBy: {
            args: Prisma.CurrentLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrentLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrentLocationCountArgs<ExtArgs>
            result: $Utils.Optional<CurrentLocationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationRequest?: VerificationRequestOmit
    patient?: PatientOmit
    adminPanel?: AdminPanelOmit
    superAdmin?: SuperAdminOmit
    admin?: AdminOmit
    serviceProvider?: ServiceProviderOmit
    doctor?: DoctorOmit
    doctorsAssistant?: DoctorsAssistantOmit
    lab?: LabOmit
    hospital?: HospitalOmit
    nursing?: NursingOmit
    allergy?: AllergyOmit
    medication?: MedicationOmit
    labResult?: LabResultOmit
    medicalRecord?: MedicalRecordOmit
    prescription?: PrescriptionOmit
    therapyPlan?: TherapyPlanOmit
    payment?: PaymentOmit
    transaction?: TransactionOmit
    rating?: RatingOmit
    requestPermission?: RequestPermissionOmit
    request?: RequestOmit
    appointment?: AppointmentOmit
    othersAppointment?: OthersAppointmentOmit
    schedule?: ScheduleOmit
    slot?: SlotOmit
    clinicInfo?: ClinicInfoOmit
    address?: AddressOmit
    education?: EducationOmit
    workExperience?: WorkExperienceOmit
    award?: AwardOmit
    currentLocation?: CurrentLocationOmit
    auditLog?: AuditLogOmit
    notification?: NotificationOmit
    tag?: TagOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    patient: number
    payments: number
    medicalRecords: number
    appointments: number
    ratings: number
    notifications: number
    auditLogs: number
    serviceProvider: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    patient?: boolean | UserCountOutputTypeCountPatientArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    medicalRecords?: boolean | UserCountOutputTypeCountMedicalRecordsArgs
    appointments?: boolean | UserCountOutputTypeCountAppointmentsArgs
    ratings?: boolean | UserCountOutputTypeCountRatingsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    serviceProvider?: boolean | UserCountOutputTypeCountServiceProviderArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    allergies: number
    treatmentPlans: number
    appointment: number
    prescriptions: number
    labResults: number
    tags: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allergies?: boolean | PatientCountOutputTypeCountAllergiesArgs
    treatmentPlans?: boolean | PatientCountOutputTypeCountTreatmentPlansArgs
    appointment?: boolean | PatientCountOutputTypeCountAppointmentArgs
    prescriptions?: boolean | PatientCountOutputTypeCountPrescriptionsArgs
    labResults?: boolean | PatientCountOutputTypeCountLabResultsArgs
    tags?: boolean | PatientCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAllergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTreatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TherapyPlanWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountLabResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type AdminPanelCountOutputType
   */

  export type AdminPanelCountOutputType = {
    serviceProvider: number
    patient: number
    superAdminId: number
    adminId: number
  }

  export type AdminPanelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | AdminPanelCountOutputTypeCountServiceProviderArgs
    patient?: boolean | AdminPanelCountOutputTypeCountPatientArgs
    superAdminId?: boolean | AdminPanelCountOutputTypeCountSuperAdminIdArgs
    adminId?: boolean | AdminPanelCountOutputTypeCountAdminIdArgs
  }

  // Custom InputTypes
  /**
   * AdminPanelCountOutputType without action
   */
  export type AdminPanelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanelCountOutputType
     */
    select?: AdminPanelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminPanelCountOutputType without action
   */
  export type AdminPanelCountOutputTypeCountServiceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderWhereInput
  }

  /**
   * AdminPanelCountOutputType without action
   */
  export type AdminPanelCountOutputTypeCountPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * AdminPanelCountOutputType without action
   */
  export type AdminPanelCountOutputTypeCountSuperAdminIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminWhereInput
  }

  /**
   * AdminPanelCountOutputType without action
   */
  export type AdminPanelCountOutputTypeCountAdminIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type SuperAdminCountOutputType
   */

  export type SuperAdminCountOutputType = {
    admin: number
  }

  export type SuperAdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | SuperAdminCountOutputTypeCountAdminArgs
  }

  // Custom InputTypes
  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminCountOutputType
     */
    select?: SuperAdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type ServiceProviderCountOutputType
   */

  export type ServiceProviderCountOutputType = {
    schedule: number
    appointment: number
    education: number
    workExperience: number
    awards: number
    labResults: number
    therapyPlans: number
    rating: number
    medicalRecords: number
    doctor: number
    tags: number
  }

  export type ServiceProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ServiceProviderCountOutputTypeCountScheduleArgs
    appointment?: boolean | ServiceProviderCountOutputTypeCountAppointmentArgs
    education?: boolean | ServiceProviderCountOutputTypeCountEducationArgs
    workExperience?: boolean | ServiceProviderCountOutputTypeCountWorkExperienceArgs
    awards?: boolean | ServiceProviderCountOutputTypeCountAwardsArgs
    labResults?: boolean | ServiceProviderCountOutputTypeCountLabResultsArgs
    therapyPlans?: boolean | ServiceProviderCountOutputTypeCountTherapyPlansArgs
    rating?: boolean | ServiceProviderCountOutputTypeCountRatingArgs
    medicalRecords?: boolean | ServiceProviderCountOutputTypeCountMedicalRecordsArgs
    doctor?: boolean | ServiceProviderCountOutputTypeCountDoctorArgs
    tags?: boolean | ServiceProviderCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderCountOutputType
     */
    select?: ServiceProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountWorkExperienceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkExperienceWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountAwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountLabResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountTherapyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TherapyPlanWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type DoctorCountOutputType
   */

  export type DoctorCountOutputType = {
    prescriptions: number
    assistants: number
    requests: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptions?: boolean | DoctorCountOutputTypeCountPrescriptionsArgs
    assistants?: boolean | DoctorCountOutputTypeCountAssistantsArgs
    requests?: boolean | DoctorCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes
  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountAssistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorsAssistantWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
  }


  /**
   * Count Type DoctorsAssistantCountOutputType
   */

  export type DoctorsAssistantCountOutputType = {
    requestPermissions: number
  }

  export type DoctorsAssistantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestPermissions?: boolean | DoctorsAssistantCountOutputTypeCountRequestPermissionsArgs
  }

  // Custom InputTypes
  /**
   * DoctorsAssistantCountOutputType without action
   */
  export type DoctorsAssistantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistantCountOutputType
     */
    select?: DoctorsAssistantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorsAssistantCountOutputType without action
   */
  export type DoctorsAssistantCountOutputTypeCountRequestPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestPermissionWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    medications: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medications?: boolean | PrescriptionCountOutputTypeCountMedicationsArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    transaction: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | PaymentCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type RequestPermissionCountOutputType
   */

  export type RequestPermissionCountOutputType = {
    requests: number
  }

  export type RequestPermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requests?: boolean | RequestPermissionCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes
  /**
   * RequestPermissionCountOutputType without action
   */
  export type RequestPermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermissionCountOutputType
     */
    select?: RequestPermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestPermissionCountOutputType without action
   */
  export type RequestPermissionCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
  }


  /**
   * Count Type RequestCountOutputType
   */

  export type RequestCountOutputType = {
    requestPermissions: number
  }

  export type RequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestPermissions?: boolean | RequestCountOutputTypeCountRequestPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RequestCountOutputType without action
   */
  export type RequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCountOutputType
     */
    select?: RequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestCountOutputType without action
   */
  export type RequestCountOutputTypeCountRequestPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestPermissionWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    payment: number
    tags: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | AppointmentCountOutputTypeCountPaymentArgs
    tags?: boolean | AppointmentCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type ScheduleCountOutputType
   */

  export type ScheduleCountOutputType = {
    slots: number
    clinicInfo: number
  }

  export type ScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slots?: boolean | ScheduleCountOutputTypeCountSlotsArgs
    clinicInfo?: boolean | ScheduleCountOutputTypeCountClinicInfoArgs
  }

  // Custom InputTypes
  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlotWhereInput
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountClinicInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicInfoWhereInput
  }


  /**
   * Count Type ClinicInfoCountOutputType
   */

  export type ClinicInfoCountOutputType = {
    serviceProviders: number
  }

  export type ClinicInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProviders?: boolean | ClinicInfoCountOutputTypeCountServiceProvidersArgs
  }

  // Custom InputTypes
  /**
   * ClinicInfoCountOutputType without action
   */
  export type ClinicInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfoCountOutputType
     */
    select?: ClinicInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicInfoCountOutputType without action
   */
  export type ClinicInfoCountOutputTypeCountServiceProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    serviceProviders: number
    appointments: number
    patients: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProviders?: boolean | TagCountOutputTypeCountServiceProvidersArgs
    appointments?: boolean | TagCountOutputTypeCountAppointmentsArgs
    patients?: boolean | TagCountOutputTypeCountPatientsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountServiceProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    username: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    phone: string | null
    role: $Enums.UserRole | null
    gender: $Enums.Gender | null
    dob: Date | null
    bloodGroup: $Enums.BloodGroup | null
    isActive: boolean | null
    isVerified: boolean | null
    profilePic: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    username: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    phone: string | null
    role: $Enums.UserRole | null
    gender: $Enums.Gender | null
    dob: Date | null
    bloodGroup: $Enums.BloodGroup | null
    isActive: boolean | null
    isVerified: boolean | null
    profilePic: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userId: number
    username: number
    name: number
    email: number
    emailVerified: number
    phone: number
    role: number
    gender: number
    dob: number
    bloodGroup: number
    isActive: number
    isVerified: number
    profilePic: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    name?: true
    email?: true
    emailVerified?: true
    phone?: true
    role?: true
    gender?: true
    dob?: true
    bloodGroup?: true
    isActive?: true
    isVerified?: true
    profilePic?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    name?: true
    email?: true
    emailVerified?: true
    phone?: true
    role?: true
    gender?: true
    dob?: true
    bloodGroup?: true
    isActive?: true
    isVerified?: true
    profilePic?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    name?: true
    email?: true
    emailVerified?: true
    phone?: true
    role?: true
    gender?: true
    dob?: true
    bloodGroup?: true
    isActive?: true
    isVerified?: true
    profilePic?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    userId: string
    username: string | null
    name: string | null
    email: string
    emailVerified: Date | null
    phone: string | null
    role: $Enums.UserRole
    gender: $Enums.Gender | null
    dob: Date | null
    bloodGroup: $Enums.BloodGroup | null
    isActive: boolean
    isVerified: boolean
    profilePic: string | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    phone?: boolean
    role?: boolean
    gender?: boolean
    dob?: boolean
    bloodGroup?: boolean
    isActive?: boolean
    isVerified?: boolean
    profilePic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    address?: boolean | User$addressArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    patient?: boolean | User$patientArgs<ExtArgs>
    doctor?: boolean | User$doctorArgs<ExtArgs>
    superAdmin?: boolean | User$superAdminArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    lab?: boolean | User$labArgs<ExtArgs>
    hospital?: boolean | User$hospitalArgs<ExtArgs>
    nursing?: boolean | User$nursingArgs<ExtArgs>
    doctorsAssistant?: boolean | User$doctorsAssistantArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    medicalRecords?: boolean | User$medicalRecordsArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    serviceProvider?: boolean | User$serviceProviderArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    phone?: boolean
    role?: boolean
    gender?: boolean
    dob?: boolean
    bloodGroup?: boolean
    isActive?: boolean
    isVerified?: boolean
    profilePic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    phone?: boolean
    role?: boolean
    gender?: boolean
    dob?: boolean
    bloodGroup?: boolean
    isActive?: boolean
    isVerified?: boolean
    profilePic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    userId?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    phone?: boolean
    role?: boolean
    gender?: boolean
    dob?: boolean
    bloodGroup?: boolean
    isActive?: boolean
    isVerified?: boolean
    profilePic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "username" | "name" | "email" | "emailVerified" | "phone" | "role" | "gender" | "dob" | "bloodGroup" | "isActive" | "isVerified" | "profilePic" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | User$addressArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    patient?: boolean | User$patientArgs<ExtArgs>
    doctor?: boolean | User$doctorArgs<ExtArgs>
    superAdmin?: boolean | User$superAdminArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    lab?: boolean | User$labArgs<ExtArgs>
    hospital?: boolean | User$hospitalArgs<ExtArgs>
    nursing?: boolean | User$nursingArgs<ExtArgs>
    doctorsAssistant?: boolean | User$doctorsAssistantArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    medicalRecords?: boolean | User$medicalRecordsArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    serviceProvider?: boolean | User$serviceProviderArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      patient: Prisma.$PatientPayload<ExtArgs>[]
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
      superAdmin: Prisma.$SuperAdminPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      lab: Prisma.$LabPayload<ExtArgs> | null
      hospital: Prisma.$HospitalPayload<ExtArgs> | null
      nursing: Prisma.$NursingPayload<ExtArgs> | null
      doctorsAssistant: Prisma.$DoctorsAssistantPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      medicalRecords: Prisma.$MedicalRecordPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      username: string | null
      name: string | null
      email: string
      emailVerified: Date | null
      phone: string | null
      role: $Enums.UserRole
      gender: $Enums.Gender | null
      dob: Date | null
      bloodGroup: $Enums.BloodGroup | null
      isActive: boolean
      isVerified: boolean
      profilePic: string | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends User$addressArgs<ExtArgs> = {}>(args?: Subset<T, User$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patient<T extends User$patientArgs<ExtArgs> = {}>(args?: Subset<T, User$patientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctor<T extends User$doctorArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    superAdmin<T extends User$superAdminArgs<ExtArgs> = {}>(args?: Subset<T, User$superAdminArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lab<T extends User$labArgs<ExtArgs> = {}>(args?: Subset<T, User$labArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hospital<T extends User$hospitalArgs<ExtArgs> = {}>(args?: Subset<T, User$hospitalArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nursing<T extends User$nursingArgs<ExtArgs> = {}>(args?: Subset<T, User$nursingArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctorsAssistant<T extends User$doctorsAssistantArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorsAssistantArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalRecords<T extends User$medicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$medicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends User$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends User$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, User$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceProvider<T extends User$serviceProviderArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceProviderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly userId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly dob: FieldRef<"User", 'DateTime'>
    readonly bloodGroup: FieldRef<"User", 'BloodGroup'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly profilePic: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.address
   */
  export type User$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.patient
   */
  export type User$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * User.doctor
   */
  export type User$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * User.superAdmin
   */
  export type User$superAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    where?: SuperAdminWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.lab
   */
  export type User$labArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    where?: LabWhereInput
  }

  /**
   * User.hospital
   */
  export type User$hospitalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    where?: HospitalWhereInput
  }

  /**
   * User.nursing
   */
  export type User$nursingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    where?: NursingWhereInput
  }

  /**
   * User.doctorsAssistant
   */
  export type User$doctorsAssistantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    where?: DoctorsAssistantWhereInput
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.medicalRecords
   */
  export type User$medicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * User.appointments
   */
  export type User$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.ratings
   */
  export type User$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.serviceProvider
   */
  export type User$serviceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    where?: ServiceProviderWhereInput
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    cursor?: ServiceProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    providerType: string | null
    providerId: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    providerType: string | null
    providerId: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    providerType: number
    providerId: number
    providerAccountId: number
    refreshToken: number
    accessToken: number
    accessTokenExpires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpires: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerType?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerType?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerType?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    providerType?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "providerType" | "providerId" | "providerAccountId" | "refreshToken" | "accessToken" | "accessTokenExpires" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      providerType: string
      providerId: string
      providerAccountId: string
      refreshToken: string | null
      accessToken: string | null
      accessTokenExpires: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly providerType: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpires: FieldRef<"Account", 'DateTime'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    expires: Date | null
    sessionToken: string | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    expires: Date | null
    sessionToken: string | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    expires: number
    sessionToken: number
    accessToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    expires: Date
    sessionToken: string
    accessToken: string
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "expires" | "sessionToken" | "accessToken" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      expires: Date
      sessionToken: string
      accessToken: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly accessToken: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationRequest
   */

  export type AggregateVerificationRequest = {
    _count: VerificationRequestCountAggregateOutputType | null
    _min: VerificationRequestMinAggregateOutputType | null
    _max: VerificationRequestMaxAggregateOutputType | null
  }

  export type VerificationRequestMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationRequestMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationRequestCountAggregateOutputType = {
    id: number
    identifier: number
    token: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationRequestMinAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationRequestMaxAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationRequestCountAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationRequest to aggregate.
     */
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     */
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationRequests
    **/
    _count?: true | VerificationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationRequestMaxAggregateInputType
  }

  export type GetVerificationRequestAggregateType<T extends VerificationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationRequest[P]>
      : GetScalarType<T[P], AggregateVerificationRequest[P]>
  }




  export type VerificationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationRequestWhereInput
    orderBy?: VerificationRequestOrderByWithAggregationInput | VerificationRequestOrderByWithAggregationInput[]
    by: VerificationRequestScalarFieldEnum[] | VerificationRequestScalarFieldEnum
    having?: VerificationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationRequestCountAggregateInputType | true
    _min?: VerificationRequestMinAggregateInputType
    _max?: VerificationRequestMaxAggregateInputType
  }

  export type VerificationRequestGroupByOutputType = {
    id: string
    identifier: string
    token: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationRequestCountAggregateOutputType | null
    _min: VerificationRequestMinAggregateOutputType | null
    _max: VerificationRequestMaxAggregateOutputType | null
  }

  type GetVerificationRequestGroupByPayload<T extends VerificationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationRequestGroupByOutputType[P]>
        }
      >
    >


  export type VerificationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verificationRequest"]>

  export type VerificationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verificationRequest"]>

  export type VerificationRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verificationRequest"]>

  export type VerificationRequestSelectScalar = {
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "token" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["verificationRequest"]>

  export type $VerificationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      token: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verificationRequest"]>
    composites: {}
  }

  type VerificationRequestGetPayload<S extends boolean | null | undefined | VerificationRequestDefaultArgs> = $Result.GetResult<Prisma.$VerificationRequestPayload, S>

  type VerificationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationRequestCountAggregateInputType | true
    }

  export interface VerificationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationRequest'], meta: { name: 'VerificationRequest' } }
    /**
     * Find zero or one VerificationRequest that matches the filter.
     * @param {VerificationRequestFindUniqueArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationRequestFindUniqueArgs>(args: SelectSubset<T, VerificationRequestFindUniqueArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationRequestFindUniqueOrThrowArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindFirstArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationRequestFindFirstArgs>(args?: SelectSubset<T, VerificationRequestFindFirstArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindFirstOrThrowArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationRequests
     * const verificationRequests = await prisma.verificationRequest.findMany()
     * 
     * // Get first 10 VerificationRequests
     * const verificationRequests = await prisma.verificationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationRequestWithIdOnly = await prisma.verificationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationRequestFindManyArgs>(args?: SelectSubset<T, VerificationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationRequest.
     * @param {VerificationRequestCreateArgs} args - Arguments to create a VerificationRequest.
     * @example
     * // Create one VerificationRequest
     * const VerificationRequest = await prisma.verificationRequest.create({
     *   data: {
     *     // ... data to create a VerificationRequest
     *   }
     * })
     * 
     */
    create<T extends VerificationRequestCreateArgs>(args: SelectSubset<T, VerificationRequestCreateArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationRequests.
     * @param {VerificationRequestCreateManyArgs} args - Arguments to create many VerificationRequests.
     * @example
     * // Create many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationRequestCreateManyArgs>(args?: SelectSubset<T, VerificationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationRequests and returns the data saved in the database.
     * @param {VerificationRequestCreateManyAndReturnArgs} args - Arguments to create many VerificationRequests.
     * @example
     * // Create many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationRequests and only return the `id`
     * const verificationRequestWithIdOnly = await prisma.verificationRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationRequest.
     * @param {VerificationRequestDeleteArgs} args - Arguments to delete one VerificationRequest.
     * @example
     * // Delete one VerificationRequest
     * const VerificationRequest = await prisma.verificationRequest.delete({
     *   where: {
     *     // ... filter to delete one VerificationRequest
     *   }
     * })
     * 
     */
    delete<T extends VerificationRequestDeleteArgs>(args: SelectSubset<T, VerificationRequestDeleteArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationRequest.
     * @param {VerificationRequestUpdateArgs} args - Arguments to update one VerificationRequest.
     * @example
     * // Update one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationRequestUpdateArgs>(args: SelectSubset<T, VerificationRequestUpdateArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationRequests.
     * @param {VerificationRequestDeleteManyArgs} args - Arguments to filter VerificationRequests to delete.
     * @example
     * // Delete a few VerificationRequests
     * const { count } = await prisma.verificationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationRequestDeleteManyArgs>(args?: SelectSubset<T, VerificationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationRequestUpdateManyArgs>(args: SelectSubset<T, VerificationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationRequests and returns the data updated in the database.
     * @param {VerificationRequestUpdateManyAndReturnArgs} args - Arguments to update many VerificationRequests.
     * @example
     * // Update many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationRequests and only return the `id`
     * const verificationRequestWithIdOnly = await prisma.verificationRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationRequest.
     * @param {VerificationRequestUpsertArgs} args - Arguments to update or create a VerificationRequest.
     * @example
     * // Update or create a VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.upsert({
     *   create: {
     *     // ... data to create a VerificationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationRequest we want to update
     *   }
     * })
     */
    upsert<T extends VerificationRequestUpsertArgs>(args: SelectSubset<T, VerificationRequestUpsertArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestCountArgs} args - Arguments to filter VerificationRequests to count.
     * @example
     * // Count the number of VerificationRequests
     * const count = await prisma.verificationRequest.count({
     *   where: {
     *     // ... the filter for the VerificationRequests we want to count
     *   }
     * })
    **/
    count<T extends VerificationRequestCountArgs>(
      args?: Subset<T, VerificationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationRequestAggregateArgs>(args: Subset<T, VerificationRequestAggregateArgs>): Prisma.PrismaPromise<GetVerificationRequestAggregateType<T>>

    /**
     * Group by VerificationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationRequestGroupByArgs['orderBy'] }
        : { orderBy?: VerificationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationRequest model
   */
  readonly fields: VerificationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationRequest model
   */
  interface VerificationRequestFieldRefs {
    readonly id: FieldRef<"VerificationRequest", 'String'>
    readonly identifier: FieldRef<"VerificationRequest", 'String'>
    readonly token: FieldRef<"VerificationRequest", 'String'>
    readonly expires: FieldRef<"VerificationRequest", 'DateTime'>
    readonly createdAt: FieldRef<"VerificationRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"VerificationRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationRequest findUnique
   */
  export type VerificationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * Filter, which VerificationRequest to fetch.
     */
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest findUniqueOrThrow
   */
  export type VerificationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * Filter, which VerificationRequest to fetch.
     */
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest findFirst
   */
  export type VerificationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * Filter, which VerificationRequest to fetch.
     */
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     */
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationRequests.
     */
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationRequests.
     */
    distinct?: VerificationRequestScalarFieldEnum | VerificationRequestScalarFieldEnum[]
  }

  /**
   * VerificationRequest findFirstOrThrow
   */
  export type VerificationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * Filter, which VerificationRequest to fetch.
     */
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     */
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationRequests.
     */
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationRequests.
     */
    distinct?: VerificationRequestScalarFieldEnum | VerificationRequestScalarFieldEnum[]
  }

  /**
   * VerificationRequest findMany
   */
  export type VerificationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * Filter, which VerificationRequests to fetch.
     */
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     */
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationRequests.
     */
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     */
    skip?: number
    distinct?: VerificationRequestScalarFieldEnum | VerificationRequestScalarFieldEnum[]
  }

  /**
   * VerificationRequest create
   */
  export type VerificationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationRequest.
     */
    data: XOR<VerificationRequestCreateInput, VerificationRequestUncheckedCreateInput>
  }

  /**
   * VerificationRequest createMany
   */
  export type VerificationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationRequests.
     */
    data: VerificationRequestCreateManyInput | VerificationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationRequest createManyAndReturn
   */
  export type VerificationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationRequests.
     */
    data: VerificationRequestCreateManyInput | VerificationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationRequest update
   */
  export type VerificationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationRequest.
     */
    data: XOR<VerificationRequestUpdateInput, VerificationRequestUncheckedUpdateInput>
    /**
     * Choose, which VerificationRequest to update.
     */
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest updateMany
   */
  export type VerificationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationRequests.
     */
    data: XOR<VerificationRequestUpdateManyMutationInput, VerificationRequestUncheckedUpdateManyInput>
    /**
     * Filter which VerificationRequests to update
     */
    where?: VerificationRequestWhereInput
    /**
     * Limit how many VerificationRequests to update.
     */
    limit?: number
  }

  /**
   * VerificationRequest updateManyAndReturn
   */
  export type VerificationRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * The data used to update VerificationRequests.
     */
    data: XOR<VerificationRequestUpdateManyMutationInput, VerificationRequestUncheckedUpdateManyInput>
    /**
     * Filter which VerificationRequests to update
     */
    where?: VerificationRequestWhereInput
    /**
     * Limit how many VerificationRequests to update.
     */
    limit?: number
  }

  /**
   * VerificationRequest upsert
   */
  export type VerificationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationRequest to update in case it exists.
     */
    where: VerificationRequestWhereUniqueInput
    /**
     * In case the VerificationRequest found by the `where` argument doesn't exist, create a new VerificationRequest with this data.
     */
    create: XOR<VerificationRequestCreateInput, VerificationRequestUncheckedCreateInput>
    /**
     * In case the VerificationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationRequestUpdateInput, VerificationRequestUncheckedUpdateInput>
  }

  /**
   * VerificationRequest delete
   */
  export type VerificationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
    /**
     * Filter which VerificationRequest to delete.
     */
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest deleteMany
   */
  export type VerificationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationRequests to delete
     */
    where?: VerificationRequestWhereInput
    /**
     * Limit how many VerificationRequests to delete.
     */
    limit?: number
  }

  /**
   * VerificationRequest without action
   */
  export type VerificationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationRequest
     */
    omit?: VerificationRequestOmit<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    age: string | null
    userId: string | null
    bloodGroup: $Enums.BloodGroup | null
    adminPanelId: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    age: string | null
    userId: string | null
    bloodGroup: $Enums.BloodGroup | null
    adminPanelId: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    age: number
    userId: number
    conditions: number
    bloodGroup: number
    adminPanelId: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    age?: true
    userId?: true
    bloodGroup?: true
    adminPanelId?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    age?: true
    userId?: true
    bloodGroup?: true
    adminPanelId?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    age?: true
    userId?: true
    conditions?: true
    bloodGroup?: true
    adminPanelId?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    age: string
    userId: string
    conditions: string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    age?: boolean
    userId?: boolean
    conditions?: boolean
    bloodGroup?: boolean
    adminPanelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    treatmentPlans?: boolean | Patient$treatmentPlansArgs<ExtArgs>
    appointment?: boolean | Patient$appointmentArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    labResults?: boolean | Patient$labResultsArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    tags?: boolean | Patient$tagsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    age?: boolean
    userId?: boolean
    conditions?: boolean
    bloodGroup?: boolean
    adminPanelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    age?: boolean
    userId?: boolean
    conditions?: boolean
    bloodGroup?: boolean
    adminPanelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    age?: boolean
    userId?: boolean
    conditions?: boolean
    bloodGroup?: boolean
    adminPanelId?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "age" | "userId" | "conditions" | "bloodGroup" | "adminPanelId", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    treatmentPlans?: boolean | Patient$treatmentPlansArgs<ExtArgs>
    appointment?: boolean | Patient$appointmentArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    labResults?: boolean | Patient$labResultsArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    tags?: boolean | Patient$tagsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
  }
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      allergies: Prisma.$AllergyPayload<ExtArgs>[]
      treatmentPlans: Prisma.$TherapyPlanPayload<ExtArgs>[]
      appointment: Prisma.$AppointmentPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      labResults: Prisma.$LabResultPayload<ExtArgs>[]
      adminPanel: Prisma.$AdminPanelPayload<ExtArgs>
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      age: string
      userId: string
      conditions: string[]
      bloodGroup: $Enums.BloodGroup
      adminPanelId: string
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    allergies<T extends Patient$allergiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$allergiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treatmentPlans<T extends Patient$treatmentPlansArgs<ExtArgs> = {}>(args?: Subset<T, Patient$treatmentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointment<T extends Patient$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Patient$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labResults<T extends Patient$labResultsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$labResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminPanel<T extends AdminPanelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminPanelDefaultArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends Patient$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly age: FieldRef<"Patient", 'String'>
    readonly userId: FieldRef<"Patient", 'String'>
    readonly conditions: FieldRef<"Patient", 'String[]'>
    readonly bloodGroup: FieldRef<"Patient", 'BloodGroup'>
    readonly adminPanelId: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.allergies
   */
  export type Patient$allergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    where?: AllergyWhereInput
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    cursor?: AllergyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * Patient.treatmentPlans
   */
  export type Patient$treatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    where?: TherapyPlanWhereInput
    orderBy?: TherapyPlanOrderByWithRelationInput | TherapyPlanOrderByWithRelationInput[]
    cursor?: TherapyPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TherapyPlanScalarFieldEnum | TherapyPlanScalarFieldEnum[]
  }

  /**
   * Patient.appointment
   */
  export type Patient$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.prescriptions
   */
  export type Patient$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Patient.labResults
   */
  export type Patient$labResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    cursor?: LabResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * Patient.tags
   */
  export type Patient$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model AdminPanel
   */

  export type AggregateAdminPanel = {
    _count: AdminPanelCountAggregateOutputType | null
    _min: AdminPanelMinAggregateOutputType | null
    _max: AdminPanelMaxAggregateOutputType | null
  }

  export type AdminPanelMinAggregateOutputType = {
    id: string | null
    userId: string | null
    canManageUsers: boolean | null
    canManagePayments: boolean | null
    canManageReports: boolean | null
  }

  export type AdminPanelMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    canManageUsers: boolean | null
    canManagePayments: boolean | null
    canManageReports: boolean | null
  }

  export type AdminPanelCountAggregateOutputType = {
    id: number
    userId: number
    permissions: number
    canManageUsers: number
    canManagePayments: number
    canManageReports: number
    _all: number
  }


  export type AdminPanelMinAggregateInputType = {
    id?: true
    userId?: true
    canManageUsers?: true
    canManagePayments?: true
    canManageReports?: true
  }

  export type AdminPanelMaxAggregateInputType = {
    id?: true
    userId?: true
    canManageUsers?: true
    canManagePayments?: true
    canManageReports?: true
  }

  export type AdminPanelCountAggregateInputType = {
    id?: true
    userId?: true
    permissions?: true
    canManageUsers?: true
    canManagePayments?: true
    canManageReports?: true
    _all?: true
  }

  export type AdminPanelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPanel to aggregate.
     */
    where?: AdminPanelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPanels to fetch.
     */
    orderBy?: AdminPanelOrderByWithRelationInput | AdminPanelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminPanelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPanels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPanels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminPanels
    **/
    _count?: true | AdminPanelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminPanelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminPanelMaxAggregateInputType
  }

  export type GetAdminPanelAggregateType<T extends AdminPanelAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminPanel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminPanel[P]>
      : GetScalarType<T[P], AggregateAdminPanel[P]>
  }




  export type AdminPanelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPanelWhereInput
    orderBy?: AdminPanelOrderByWithAggregationInput | AdminPanelOrderByWithAggregationInput[]
    by: AdminPanelScalarFieldEnum[] | AdminPanelScalarFieldEnum
    having?: AdminPanelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminPanelCountAggregateInputType | true
    _min?: AdminPanelMinAggregateInputType
    _max?: AdminPanelMaxAggregateInputType
  }

  export type AdminPanelGroupByOutputType = {
    id: string
    userId: string
    permissions: $Enums.ActionType[]
    canManageUsers: boolean
    canManagePayments: boolean
    canManageReports: boolean
    _count: AdminPanelCountAggregateOutputType | null
    _min: AdminPanelMinAggregateOutputType | null
    _max: AdminPanelMaxAggregateOutputType | null
  }

  type GetAdminPanelGroupByPayload<T extends AdminPanelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminPanelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminPanelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminPanelGroupByOutputType[P]>
            : GetScalarType<T[P], AdminPanelGroupByOutputType[P]>
        }
      >
    >


  export type AdminPanelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: boolean | AdminPanel$serviceProviderArgs<ExtArgs>
    patient?: boolean | AdminPanel$patientArgs<ExtArgs>
    superAdminId?: boolean | AdminPanel$superAdminIdArgs<ExtArgs>
    adminId?: boolean | AdminPanel$adminIdArgs<ExtArgs>
    _count?: boolean | AdminPanelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminPanel"]>

  export type AdminPanelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
  }, ExtArgs["result"]["adminPanel"]>

  export type AdminPanelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
  }, ExtArgs["result"]["adminPanel"]>

  export type AdminPanelSelectScalar = {
    id?: boolean
    userId?: boolean
    permissions?: boolean
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
  }

  export type AdminPanelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "permissions" | "canManageUsers" | "canManagePayments" | "canManageReports", ExtArgs["result"]["adminPanel"]>
  export type AdminPanelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | AdminPanel$serviceProviderArgs<ExtArgs>
    patient?: boolean | AdminPanel$patientArgs<ExtArgs>
    superAdminId?: boolean | AdminPanel$superAdminIdArgs<ExtArgs>
    adminId?: boolean | AdminPanel$adminIdArgs<ExtArgs>
    _count?: boolean | AdminPanelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminPanelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminPanelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPanelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminPanel"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>[]
      patient: Prisma.$PatientPayload<ExtArgs>[]
      superAdminId: Prisma.$SuperAdminPayload<ExtArgs>[]
      adminId: Prisma.$AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permissions: $Enums.ActionType[]
      canManageUsers: boolean
      canManagePayments: boolean
      canManageReports: boolean
    }, ExtArgs["result"]["adminPanel"]>
    composites: {}
  }

  type AdminPanelGetPayload<S extends boolean | null | undefined | AdminPanelDefaultArgs> = $Result.GetResult<Prisma.$AdminPanelPayload, S>

  type AdminPanelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminPanelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminPanelCountAggregateInputType | true
    }

  export interface AdminPanelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminPanel'], meta: { name: 'AdminPanel' } }
    /**
     * Find zero or one AdminPanel that matches the filter.
     * @param {AdminPanelFindUniqueArgs} args - Arguments to find a AdminPanel
     * @example
     * // Get one AdminPanel
     * const adminPanel = await prisma.adminPanel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminPanelFindUniqueArgs>(args: SelectSubset<T, AdminPanelFindUniqueArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminPanel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminPanelFindUniqueOrThrowArgs} args - Arguments to find a AdminPanel
     * @example
     * // Get one AdminPanel
     * const adminPanel = await prisma.adminPanel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminPanelFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminPanelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPanel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPanelFindFirstArgs} args - Arguments to find a AdminPanel
     * @example
     * // Get one AdminPanel
     * const adminPanel = await prisma.adminPanel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminPanelFindFirstArgs>(args?: SelectSubset<T, AdminPanelFindFirstArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPanel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPanelFindFirstOrThrowArgs} args - Arguments to find a AdminPanel
     * @example
     * // Get one AdminPanel
     * const adminPanel = await prisma.adminPanel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminPanelFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminPanelFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminPanels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPanelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminPanels
     * const adminPanels = await prisma.adminPanel.findMany()
     * 
     * // Get first 10 AdminPanels
     * const adminPanels = await prisma.adminPanel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminPanelWithIdOnly = await prisma.adminPanel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminPanelFindManyArgs>(args?: SelectSubset<T, AdminPanelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminPanel.
     * @param {AdminPanelCreateArgs} args - Arguments to create a AdminPanel.
     * @example
     * // Create one AdminPanel
     * const AdminPanel = await prisma.adminPanel.create({
     *   data: {
     *     // ... data to create a AdminPanel
     *   }
     * })
     * 
     */
    create<T extends AdminPanelCreateArgs>(args: SelectSubset<T, AdminPanelCreateArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminPanels.
     * @param {AdminPanelCreateManyArgs} args - Arguments to create many AdminPanels.
     * @example
     * // Create many AdminPanels
     * const adminPanel = await prisma.adminPanel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminPanelCreateManyArgs>(args?: SelectSubset<T, AdminPanelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminPanels and returns the data saved in the database.
     * @param {AdminPanelCreateManyAndReturnArgs} args - Arguments to create many AdminPanels.
     * @example
     * // Create many AdminPanels
     * const adminPanel = await prisma.adminPanel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminPanels and only return the `id`
     * const adminPanelWithIdOnly = await prisma.adminPanel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminPanelCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminPanelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminPanel.
     * @param {AdminPanelDeleteArgs} args - Arguments to delete one AdminPanel.
     * @example
     * // Delete one AdminPanel
     * const AdminPanel = await prisma.adminPanel.delete({
     *   where: {
     *     // ... filter to delete one AdminPanel
     *   }
     * })
     * 
     */
    delete<T extends AdminPanelDeleteArgs>(args: SelectSubset<T, AdminPanelDeleteArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminPanel.
     * @param {AdminPanelUpdateArgs} args - Arguments to update one AdminPanel.
     * @example
     * // Update one AdminPanel
     * const adminPanel = await prisma.adminPanel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminPanelUpdateArgs>(args: SelectSubset<T, AdminPanelUpdateArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminPanels.
     * @param {AdminPanelDeleteManyArgs} args - Arguments to filter AdminPanels to delete.
     * @example
     * // Delete a few AdminPanels
     * const { count } = await prisma.adminPanel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminPanelDeleteManyArgs>(args?: SelectSubset<T, AdminPanelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPanels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPanelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminPanels
     * const adminPanel = await prisma.adminPanel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminPanelUpdateManyArgs>(args: SelectSubset<T, AdminPanelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPanels and returns the data updated in the database.
     * @param {AdminPanelUpdateManyAndReturnArgs} args - Arguments to update many AdminPanels.
     * @example
     * // Update many AdminPanels
     * const adminPanel = await prisma.adminPanel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminPanels and only return the `id`
     * const adminPanelWithIdOnly = await prisma.adminPanel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminPanelUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminPanelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminPanel.
     * @param {AdminPanelUpsertArgs} args - Arguments to update or create a AdminPanel.
     * @example
     * // Update or create a AdminPanel
     * const adminPanel = await prisma.adminPanel.upsert({
     *   create: {
     *     // ... data to create a AdminPanel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminPanel we want to update
     *   }
     * })
     */
    upsert<T extends AdminPanelUpsertArgs>(args: SelectSubset<T, AdminPanelUpsertArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminPanels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPanelCountArgs} args - Arguments to filter AdminPanels to count.
     * @example
     * // Count the number of AdminPanels
     * const count = await prisma.adminPanel.count({
     *   where: {
     *     // ... the filter for the AdminPanels we want to count
     *   }
     * })
    **/
    count<T extends AdminPanelCountArgs>(
      args?: Subset<T, AdminPanelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminPanelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminPanel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPanelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminPanelAggregateArgs>(args: Subset<T, AdminPanelAggregateArgs>): Prisma.PrismaPromise<GetAdminPanelAggregateType<T>>

    /**
     * Group by AdminPanel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPanelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminPanelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminPanelGroupByArgs['orderBy'] }
        : { orderBy?: AdminPanelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminPanelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminPanelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminPanel model
   */
  readonly fields: AdminPanelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminPanel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminPanelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends AdminPanel$serviceProviderArgs<ExtArgs> = {}>(args?: Subset<T, AdminPanel$serviceProviderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patient<T extends AdminPanel$patientArgs<ExtArgs> = {}>(args?: Subset<T, AdminPanel$patientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    superAdminId<T extends AdminPanel$superAdminIdArgs<ExtArgs> = {}>(args?: Subset<T, AdminPanel$superAdminIdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminId<T extends AdminPanel$adminIdArgs<ExtArgs> = {}>(args?: Subset<T, AdminPanel$adminIdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminPanel model
   */
  interface AdminPanelFieldRefs {
    readonly id: FieldRef<"AdminPanel", 'String'>
    readonly userId: FieldRef<"AdminPanel", 'String'>
    readonly permissions: FieldRef<"AdminPanel", 'ActionType[]'>
    readonly canManageUsers: FieldRef<"AdminPanel", 'Boolean'>
    readonly canManagePayments: FieldRef<"AdminPanel", 'Boolean'>
    readonly canManageReports: FieldRef<"AdminPanel", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AdminPanel findUnique
   */
  export type AdminPanelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * Filter, which AdminPanel to fetch.
     */
    where: AdminPanelWhereUniqueInput
  }

  /**
   * AdminPanel findUniqueOrThrow
   */
  export type AdminPanelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * Filter, which AdminPanel to fetch.
     */
    where: AdminPanelWhereUniqueInput
  }

  /**
   * AdminPanel findFirst
   */
  export type AdminPanelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * Filter, which AdminPanel to fetch.
     */
    where?: AdminPanelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPanels to fetch.
     */
    orderBy?: AdminPanelOrderByWithRelationInput | AdminPanelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPanels.
     */
    cursor?: AdminPanelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPanels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPanels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPanels.
     */
    distinct?: AdminPanelScalarFieldEnum | AdminPanelScalarFieldEnum[]
  }

  /**
   * AdminPanel findFirstOrThrow
   */
  export type AdminPanelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * Filter, which AdminPanel to fetch.
     */
    where?: AdminPanelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPanels to fetch.
     */
    orderBy?: AdminPanelOrderByWithRelationInput | AdminPanelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPanels.
     */
    cursor?: AdminPanelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPanels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPanels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPanels.
     */
    distinct?: AdminPanelScalarFieldEnum | AdminPanelScalarFieldEnum[]
  }

  /**
   * AdminPanel findMany
   */
  export type AdminPanelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * Filter, which AdminPanels to fetch.
     */
    where?: AdminPanelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPanels to fetch.
     */
    orderBy?: AdminPanelOrderByWithRelationInput | AdminPanelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminPanels.
     */
    cursor?: AdminPanelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPanels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPanels.
     */
    skip?: number
    distinct?: AdminPanelScalarFieldEnum | AdminPanelScalarFieldEnum[]
  }

  /**
   * AdminPanel create
   */
  export type AdminPanelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminPanel.
     */
    data: XOR<AdminPanelCreateInput, AdminPanelUncheckedCreateInput>
  }

  /**
   * AdminPanel createMany
   */
  export type AdminPanelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminPanels.
     */
    data: AdminPanelCreateManyInput | AdminPanelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPanel createManyAndReturn
   */
  export type AdminPanelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * The data used to create many AdminPanels.
     */
    data: AdminPanelCreateManyInput | AdminPanelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPanel update
   */
  export type AdminPanelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminPanel.
     */
    data: XOR<AdminPanelUpdateInput, AdminPanelUncheckedUpdateInput>
    /**
     * Choose, which AdminPanel to update.
     */
    where: AdminPanelWhereUniqueInput
  }

  /**
   * AdminPanel updateMany
   */
  export type AdminPanelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminPanels.
     */
    data: XOR<AdminPanelUpdateManyMutationInput, AdminPanelUncheckedUpdateManyInput>
    /**
     * Filter which AdminPanels to update
     */
    where?: AdminPanelWhereInput
    /**
     * Limit how many AdminPanels to update.
     */
    limit?: number
  }

  /**
   * AdminPanel updateManyAndReturn
   */
  export type AdminPanelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * The data used to update AdminPanels.
     */
    data: XOR<AdminPanelUpdateManyMutationInput, AdminPanelUncheckedUpdateManyInput>
    /**
     * Filter which AdminPanels to update
     */
    where?: AdminPanelWhereInput
    /**
     * Limit how many AdminPanels to update.
     */
    limit?: number
  }

  /**
   * AdminPanel upsert
   */
  export type AdminPanelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminPanel to update in case it exists.
     */
    where: AdminPanelWhereUniqueInput
    /**
     * In case the AdminPanel found by the `where` argument doesn't exist, create a new AdminPanel with this data.
     */
    create: XOR<AdminPanelCreateInput, AdminPanelUncheckedCreateInput>
    /**
     * In case the AdminPanel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminPanelUpdateInput, AdminPanelUncheckedUpdateInput>
  }

  /**
   * AdminPanel delete
   */
  export type AdminPanelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    /**
     * Filter which AdminPanel to delete.
     */
    where: AdminPanelWhereUniqueInput
  }

  /**
   * AdminPanel deleteMany
   */
  export type AdminPanelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPanels to delete
     */
    where?: AdminPanelWhereInput
    /**
     * Limit how many AdminPanels to delete.
     */
    limit?: number
  }

  /**
   * AdminPanel.serviceProvider
   */
  export type AdminPanel$serviceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    where?: ServiceProviderWhereInput
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    cursor?: ServiceProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * AdminPanel.patient
   */
  export type AdminPanel$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * AdminPanel.superAdminId
   */
  export type AdminPanel$superAdminIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    where?: SuperAdminWhereInput
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    cursor?: SuperAdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * AdminPanel.adminId
   */
  export type AdminPanel$adminIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * AdminPanel without action
   */
  export type AdminPanelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
  }


  /**
   * Model SuperAdmin
   */

  export type AggregateSuperAdmin = {
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  export type SuperAdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.Status | null
    adminPanelId: string | null
  }

  export type SuperAdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.Status | null
    adminPanelId: string | null
  }

  export type SuperAdminCountAggregateOutputType = {
    id: number
    userId: number
    permissions: number
    status: number
    adminPanelId: number
    _all: number
  }


  export type SuperAdminMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    adminPanelId?: true
  }

  export type SuperAdminMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    adminPanelId?: true
  }

  export type SuperAdminCountAggregateInputType = {
    id?: true
    userId?: true
    permissions?: true
    status?: true
    adminPanelId?: true
    _all?: true
  }

  export type SuperAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmin to aggregate.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdmins
    **/
    _count?: true | SuperAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminMaxAggregateInputType
  }

  export type GetSuperAdminAggregateType<T extends SuperAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdmin[P]>
      : GetScalarType<T[P], AggregateSuperAdmin[P]>
  }




  export type SuperAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminWhereInput
    orderBy?: SuperAdminOrderByWithAggregationInput | SuperAdminOrderByWithAggregationInput[]
    by: SuperAdminScalarFieldEnum[] | SuperAdminScalarFieldEnum
    having?: SuperAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminCountAggregateInputType | true
    _min?: SuperAdminMinAggregateInputType
    _max?: SuperAdminMaxAggregateInputType
  }

  export type SuperAdminGroupByOutputType = {
    id: string
    userId: string
    permissions: string[]
    status: $Enums.Status
    adminPanelId: string
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  type GetSuperAdminGroupByPayload<T extends SuperAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    status?: boolean
    adminPanelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | SuperAdmin$adminArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    status?: boolean
    adminPanelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    status?: boolean
    adminPanelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectScalar = {
    id?: boolean
    userId?: boolean
    permissions?: boolean
    status?: boolean
    adminPanelId?: boolean
  }

  export type SuperAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "permissions" | "status" | "adminPanelId", ExtArgs["result"]["superAdmin"]>
  export type SuperAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | SuperAdmin$adminArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuperAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
  }
  export type SuperAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
  }

  export type $SuperAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdmin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      admin: Prisma.$AdminPayload<ExtArgs>[]
      adminPanel: Prisma.$AdminPanelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permissions: string[]
      status: $Enums.Status
      adminPanelId: string
    }, ExtArgs["result"]["superAdmin"]>
    composites: {}
  }

  type SuperAdminGetPayload<S extends boolean | null | undefined | SuperAdminDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminPayload, S>

  type SuperAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminCountAggregateInputType | true
    }

  export interface SuperAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdmin'], meta: { name: 'SuperAdmin' } }
    /**
     * Find zero or one SuperAdmin that matches the filter.
     * @param {SuperAdminFindUniqueArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminFindUniqueArgs>(args: SelectSubset<T, SuperAdminFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminFindUniqueOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminFindFirstArgs>(args?: SelectSubset<T, SuperAdminFindFirstArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany()
     * 
     * // Get first 10 SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminFindManyArgs>(args?: SelectSubset<T, SuperAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdmin.
     * @param {SuperAdminCreateArgs} args - Arguments to create a SuperAdmin.
     * @example
     * // Create one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.create({
     *   data: {
     *     // ... data to create a SuperAdmin
     *   }
     * })
     * 
     */
    create<T extends SuperAdminCreateArgs>(args: SelectSubset<T, SuperAdminCreateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdmins.
     * @param {SuperAdminCreateManyArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminCreateManyArgs>(args?: SelectSubset<T, SuperAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdmins and returns the data saved in the database.
     * @param {SuperAdminCreateManyAndReturnArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdmin.
     * @param {SuperAdminDeleteArgs} args - Arguments to delete one SuperAdmin.
     * @example
     * // Delete one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.delete({
     *   where: {
     *     // ... filter to delete one SuperAdmin
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminDeleteArgs>(args: SelectSubset<T, SuperAdminDeleteArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdmin.
     * @param {SuperAdminUpdateArgs} args - Arguments to update one SuperAdmin.
     * @example
     * // Update one SuperAdmin
     * const superAdmin = await prisma.superAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminUpdateArgs>(args: SelectSubset<T, SuperAdminUpdateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdmins.
     * @param {SuperAdminDeleteManyArgs} args - Arguments to filter SuperAdmins to delete.
     * @example
     * // Delete a few SuperAdmins
     * const { count } = await prisma.superAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminDeleteManyArgs>(args?: SelectSubset<T, SuperAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminUpdateManyArgs>(args: SelectSubset<T, SuperAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins and returns the data updated in the database.
     * @param {SuperAdminUpdateManyAndReturnArgs} args - Arguments to update many SuperAdmins.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuperAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, SuperAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdmin.
     * @param {SuperAdminUpsertArgs} args - Arguments to update or create a SuperAdmin.
     * @example
     * // Update or create a SuperAdmin
     * const superAdmin = await prisma.superAdmin.upsert({
     *   create: {
     *     // ... data to create a SuperAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdmin we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminUpsertArgs>(args: SelectSubset<T, SuperAdminUpsertArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminCountArgs} args - Arguments to filter SuperAdmins to count.
     * @example
     * // Count the number of SuperAdmins
     * const count = await prisma.superAdmin.count({
     *   where: {
     *     // ... the filter for the SuperAdmins we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminCountArgs>(
      args?: Subset<T, SuperAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminAggregateArgs>(args: Subset<T, SuperAdminAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminAggregateType<T>>

    /**
     * Group by SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdmin model
   */
  readonly fields: SuperAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admin<T extends SuperAdmin$adminArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdmin$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminPanel<T extends AdminPanelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminPanelDefaultArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdmin model
   */
  interface SuperAdminFieldRefs {
    readonly id: FieldRef<"SuperAdmin", 'String'>
    readonly userId: FieldRef<"SuperAdmin", 'String'>
    readonly permissions: FieldRef<"SuperAdmin", 'String[]'>
    readonly status: FieldRef<"SuperAdmin", 'Status'>
    readonly adminPanelId: FieldRef<"SuperAdmin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdmin findUnique
   */
  export type SuperAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findUniqueOrThrow
   */
  export type SuperAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findFirst
   */
  export type SuperAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findFirstOrThrow
   */
  export type SuperAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findMany
   */
  export type SuperAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmins to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin create
   */
  export type SuperAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdmin.
     */
    data: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
  }

  /**
   * SuperAdmin createMany
   */
  export type SuperAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin createManyAndReturn
   */
  export type SuperAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdmin update
   */
  export type SuperAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdmin.
     */
    data: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
    /**
     * Choose, which SuperAdmin to update.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin updateMany
   */
  export type SuperAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin updateManyAndReturn
   */
  export type SuperAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdmin upsert
   */
  export type SuperAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdmin to update in case it exists.
     */
    where: SuperAdminWhereUniqueInput
    /**
     * In case the SuperAdmin found by the `where` argument doesn't exist, create a new SuperAdmin with this data.
     */
    create: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
    /**
     * In case the SuperAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
  }

  /**
   * SuperAdmin delete
   */
  export type SuperAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter which SuperAdmin to delete.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin deleteMany
   */
  export type SuperAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmins to delete
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to delete.
     */
    limit?: number
  }

  /**
   * SuperAdmin.admin
   */
  export type SuperAdmin$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin without action
   */
  export type SuperAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    canManageProviders: boolean | null
    canViewAllTransactions: boolean | null
    canViewAllAppointments: boolean | null
    adminPanelId: string | null
    superAdminId: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    canManageProviders: boolean | null
    canViewAllTransactions: boolean | null
    canViewAllAppointments: boolean | null
    adminPanelId: string | null
    superAdminId: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    permissions: number
    canManageProviders: number
    canViewAllTransactions: number
    canViewAllAppointments: number
    adminPanelId: number
    superAdminId: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    canManageProviders?: true
    canViewAllTransactions?: true
    canViewAllAppointments?: true
    adminPanelId?: true
    superAdminId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    canManageProviders?: true
    canViewAllTransactions?: true
    canViewAllAppointments?: true
    adminPanelId?: true
    superAdminId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    permissions?: true
    canManageProviders?: true
    canViewAllTransactions?: true
    canViewAllAppointments?: true
    adminPanelId?: true
    superAdminId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    permissions: string[]
    canManageProviders: boolean
    canViewAllTransactions: boolean
    canViewAllAppointments: boolean
    adminPanelId: string
    superAdminId: string
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId?: boolean
    superAdminId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId?: boolean
    superAdminId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId?: boolean
    superAdminId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    permissions?: boolean
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId?: boolean
    superAdminId?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "permissions" | "canManageProviders" | "canViewAllTransactions" | "canViewAllAppointments" | "adminPanelId" | "superAdminId", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminPanel?: boolean | AdminPanelDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      adminPanel: Prisma.$AdminPanelPayload<ExtArgs>
      superAdmin: Prisma.$SuperAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permissions: string[]
      canManageProviders: boolean
      canViewAllTransactions: boolean
      canViewAllAppointments: boolean
      adminPanelId: string
      superAdminId: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    adminPanel<T extends AdminPanelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminPanelDefaultArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    superAdmin<T extends SuperAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminDefaultArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly permissions: FieldRef<"Admin", 'String[]'>
    readonly canManageProviders: FieldRef<"Admin", 'Boolean'>
    readonly canViewAllTransactions: FieldRef<"Admin", 'Boolean'>
    readonly canViewAllAppointments: FieldRef<"Admin", 'Boolean'>
    readonly adminPanelId: FieldRef<"Admin", 'String'>
    readonly superAdminId: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model ServiceProvider
   */

  export type AggregateServiceProvider = {
    _count: ServiceProviderCountAggregateOutputType | null
    _avg: ServiceProviderAvgAggregateOutputType | null
    _sum: ServiceProviderSumAggregateOutputType | null
    _min: ServiceProviderMinAggregateOutputType | null
    _max: ServiceProviderMaxAggregateOutputType | null
  }

  export type ServiceProviderAvgAggregateOutputType = {
    age: number | null
    fee: number | null
    experience: number | null
  }

  export type ServiceProviderSumAggregateOutputType = {
    age: number | null
    fee: number | null
    experience: number | null
  }

  export type ServiceProviderMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    age: number | null
    dob: Date | null
    providerType: $Enums.ProviderType | null
    fee: number | null
    experience: number | null
    description: string | null
    status: $Enums.Status | null
    document: string | null
    registrationNumber: string | null
    clinicInfoId: string | null
    adminPanelId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ServiceProviderMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    age: number | null
    dob: Date | null
    providerType: $Enums.ProviderType | null
    fee: number | null
    experience: number | null
    description: string | null
    status: $Enums.Status | null
    document: string | null
    registrationNumber: string | null
    clinicInfoId: string | null
    adminPanelId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ServiceProviderCountAggregateOutputType = {
    id: number
    providerId: number
    name: number
    age: number
    dob: number
    providerType: number
    specialization: number
    fee: number
    experience: number
    description: number
    service: number
    status: number
    document: number
    registrationNumber: number
    clinicInfoId: number
    adminPanelId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type ServiceProviderAvgAggregateInputType = {
    age?: true
    fee?: true
    experience?: true
  }

  export type ServiceProviderSumAggregateInputType = {
    age?: true
    fee?: true
    experience?: true
  }

  export type ServiceProviderMinAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    age?: true
    dob?: true
    providerType?: true
    fee?: true
    experience?: true
    description?: true
    status?: true
    document?: true
    registrationNumber?: true
    clinicInfoId?: true
    adminPanelId?: true
    userId?: true
    createdAt?: true
  }

  export type ServiceProviderMaxAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    age?: true
    dob?: true
    providerType?: true
    fee?: true
    experience?: true
    description?: true
    status?: true
    document?: true
    registrationNumber?: true
    clinicInfoId?: true
    adminPanelId?: true
    userId?: true
    createdAt?: true
  }

  export type ServiceProviderCountAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    age?: true
    dob?: true
    providerType?: true
    specialization?: true
    fee?: true
    experience?: true
    description?: true
    service?: true
    status?: true
    document?: true
    registrationNumber?: true
    clinicInfoId?: true
    adminPanelId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProvider to aggregate.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceProviders
    **/
    _count?: true | ServiceProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceProviderMaxAggregateInputType
  }

  export type GetServiceProviderAggregateType<T extends ServiceProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceProvider[P]>
      : GetScalarType<T[P], AggregateServiceProvider[P]>
  }




  export type ServiceProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderWhereInput
    orderBy?: ServiceProviderOrderByWithAggregationInput | ServiceProviderOrderByWithAggregationInput[]
    by: ServiceProviderScalarFieldEnum[] | ServiceProviderScalarFieldEnum
    having?: ServiceProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceProviderCountAggregateInputType | true
    _avg?: ServiceProviderAvgAggregateInputType
    _sum?: ServiceProviderSumAggregateInputType
    _min?: ServiceProviderMinAggregateInputType
    _max?: ServiceProviderMaxAggregateInputType
  }

  export type ServiceProviderGroupByOutputType = {
    id: string
    providerId: string
    name: string
    age: number | null
    dob: Date | null
    providerType: $Enums.ProviderType
    specialization: string[]
    fee: number | null
    experience: number | null
    description: string | null
    service: $Enums.Service[]
    status: $Enums.Status
    document: string | null
    registrationNumber: string | null
    clinicInfoId: string | null
    adminPanelId: string | null
    userId: string
    createdAt: Date
    _count: ServiceProviderCountAggregateOutputType | null
    _avg: ServiceProviderAvgAggregateOutputType | null
    _sum: ServiceProviderSumAggregateOutputType | null
    _min: ServiceProviderMinAggregateOutputType | null
    _max: ServiceProviderMaxAggregateOutputType | null
  }

  type GetServiceProviderGroupByPayload<T extends ServiceProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceProviderGroupByOutputType[P]>
        }
      >
    >


  export type ServiceProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    age?: boolean
    dob?: boolean
    providerType?: boolean
    specialization?: boolean
    fee?: boolean
    experience?: boolean
    description?: boolean
    service?: boolean
    status?: boolean
    document?: boolean
    registrationNumber?: boolean
    clinicInfoId?: boolean
    adminPanelId?: boolean
    userId?: boolean
    createdAt?: boolean
    schedule?: boolean | ServiceProvider$scheduleArgs<ExtArgs>
    appointment?: boolean | ServiceProvider$appointmentArgs<ExtArgs>
    education?: boolean | ServiceProvider$educationArgs<ExtArgs>
    workExperience?: boolean | ServiceProvider$workExperienceArgs<ExtArgs>
    awards?: boolean | ServiceProvider$awardsArgs<ExtArgs>
    labResults?: boolean | ServiceProvider$labResultsArgs<ExtArgs>
    therapyPlans?: boolean | ServiceProvider$therapyPlansArgs<ExtArgs>
    rating?: boolean | ServiceProvider$ratingArgs<ExtArgs>
    medicalRecords?: boolean | ServiceProvider$medicalRecordsArgs<ExtArgs>
    doctor?: boolean | ServiceProvider$doctorArgs<ExtArgs>
    clinicInfo?: boolean | ServiceProvider$clinicInfoArgs<ExtArgs>
    adminPanel?: boolean | ServiceProvider$adminPanelArgs<ExtArgs>
    tags?: boolean | ServiceProvider$tagsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ServiceProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceProvider"]>

  export type ServiceProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    age?: boolean
    dob?: boolean
    providerType?: boolean
    specialization?: boolean
    fee?: boolean
    experience?: boolean
    description?: boolean
    service?: boolean
    status?: boolean
    document?: boolean
    registrationNumber?: boolean
    clinicInfoId?: boolean
    adminPanelId?: boolean
    userId?: boolean
    createdAt?: boolean
    clinicInfo?: boolean | ServiceProvider$clinicInfoArgs<ExtArgs>
    adminPanel?: boolean | ServiceProvider$adminPanelArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceProvider"]>

  export type ServiceProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    age?: boolean
    dob?: boolean
    providerType?: boolean
    specialization?: boolean
    fee?: boolean
    experience?: boolean
    description?: boolean
    service?: boolean
    status?: boolean
    document?: boolean
    registrationNumber?: boolean
    clinicInfoId?: boolean
    adminPanelId?: boolean
    userId?: boolean
    createdAt?: boolean
    clinicInfo?: boolean | ServiceProvider$clinicInfoArgs<ExtArgs>
    adminPanel?: boolean | ServiceProvider$adminPanelArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceProvider"]>

  export type ServiceProviderSelectScalar = {
    id?: boolean
    providerId?: boolean
    name?: boolean
    age?: boolean
    dob?: boolean
    providerType?: boolean
    specialization?: boolean
    fee?: boolean
    experience?: boolean
    description?: boolean
    service?: boolean
    status?: boolean
    document?: boolean
    registrationNumber?: boolean
    clinicInfoId?: boolean
    adminPanelId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type ServiceProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "name" | "age" | "dob" | "providerType" | "specialization" | "fee" | "experience" | "description" | "service" | "status" | "document" | "registrationNumber" | "clinicInfoId" | "adminPanelId" | "userId" | "createdAt", ExtArgs["result"]["serviceProvider"]>
  export type ServiceProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ServiceProvider$scheduleArgs<ExtArgs>
    appointment?: boolean | ServiceProvider$appointmentArgs<ExtArgs>
    education?: boolean | ServiceProvider$educationArgs<ExtArgs>
    workExperience?: boolean | ServiceProvider$workExperienceArgs<ExtArgs>
    awards?: boolean | ServiceProvider$awardsArgs<ExtArgs>
    labResults?: boolean | ServiceProvider$labResultsArgs<ExtArgs>
    therapyPlans?: boolean | ServiceProvider$therapyPlansArgs<ExtArgs>
    rating?: boolean | ServiceProvider$ratingArgs<ExtArgs>
    medicalRecords?: boolean | ServiceProvider$medicalRecordsArgs<ExtArgs>
    doctor?: boolean | ServiceProvider$doctorArgs<ExtArgs>
    clinicInfo?: boolean | ServiceProvider$clinicInfoArgs<ExtArgs>
    adminPanel?: boolean | ServiceProvider$adminPanelArgs<ExtArgs>
    tags?: boolean | ServiceProvider$tagsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ServiceProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinicInfo?: boolean | ServiceProvider$clinicInfoArgs<ExtArgs>
    adminPanel?: boolean | ServiceProvider$adminPanelArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ServiceProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinicInfo?: boolean | ServiceProvider$clinicInfoArgs<ExtArgs>
    adminPanel?: boolean | ServiceProvider$adminPanelArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ServiceProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceProvider"
    objects: {
      schedule: Prisma.$SchedulePayload<ExtArgs>[]
      appointment: Prisma.$AppointmentPayload<ExtArgs>[]
      education: Prisma.$EducationPayload<ExtArgs>[]
      workExperience: Prisma.$WorkExperiencePayload<ExtArgs>[]
      awards: Prisma.$AwardPayload<ExtArgs>[]
      labResults: Prisma.$LabResultPayload<ExtArgs>[]
      therapyPlans: Prisma.$TherapyPlanPayload<ExtArgs>[]
      rating: Prisma.$RatingPayload<ExtArgs>[]
      medicalRecords: Prisma.$MedicalRecordPayload<ExtArgs>[]
      doctor: Prisma.$DoctorPayload<ExtArgs>[]
      clinicInfo: Prisma.$ClinicInfoPayload<ExtArgs> | null
      adminPanel: Prisma.$AdminPanelPayload<ExtArgs> | null
      tags: Prisma.$TagPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      name: string
      age: number | null
      dob: Date | null
      providerType: $Enums.ProviderType
      specialization: string[]
      fee: number | null
      experience: number | null
      description: string | null
      service: $Enums.Service[]
      status: $Enums.Status
      document: string | null
      registrationNumber: string | null
      clinicInfoId: string | null
      adminPanelId: string | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["serviceProvider"]>
    composites: {}
  }

  type ServiceProviderGetPayload<S extends boolean | null | undefined | ServiceProviderDefaultArgs> = $Result.GetResult<Prisma.$ServiceProviderPayload, S>

  type ServiceProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceProviderCountAggregateInputType | true
    }

  export interface ServiceProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceProvider'], meta: { name: 'ServiceProvider' } }
    /**
     * Find zero or one ServiceProvider that matches the filter.
     * @param {ServiceProviderFindUniqueArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceProviderFindUniqueArgs>(args: SelectSubset<T, ServiceProviderFindUniqueArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceProviderFindUniqueOrThrowArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindFirstArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceProviderFindFirstArgs>(args?: SelectSubset<T, ServiceProviderFindFirstArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindFirstOrThrowArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceProviders
     * const serviceProviders = await prisma.serviceProvider.findMany()
     * 
     * // Get first 10 ServiceProviders
     * const serviceProviders = await prisma.serviceProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceProviderWithIdOnly = await prisma.serviceProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceProviderFindManyArgs>(args?: SelectSubset<T, ServiceProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceProvider.
     * @param {ServiceProviderCreateArgs} args - Arguments to create a ServiceProvider.
     * @example
     * // Create one ServiceProvider
     * const ServiceProvider = await prisma.serviceProvider.create({
     *   data: {
     *     // ... data to create a ServiceProvider
     *   }
     * })
     * 
     */
    create<T extends ServiceProviderCreateArgs>(args: SelectSubset<T, ServiceProviderCreateArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceProviders.
     * @param {ServiceProviderCreateManyArgs} args - Arguments to create many ServiceProviders.
     * @example
     * // Create many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceProviderCreateManyArgs>(args?: SelectSubset<T, ServiceProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceProviders and returns the data saved in the database.
     * @param {ServiceProviderCreateManyAndReturnArgs} args - Arguments to create many ServiceProviders.
     * @example
     * // Create many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceProviders and only return the `id`
     * const serviceProviderWithIdOnly = await prisma.serviceProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceProvider.
     * @param {ServiceProviderDeleteArgs} args - Arguments to delete one ServiceProvider.
     * @example
     * // Delete one ServiceProvider
     * const ServiceProvider = await prisma.serviceProvider.delete({
     *   where: {
     *     // ... filter to delete one ServiceProvider
     *   }
     * })
     * 
     */
    delete<T extends ServiceProviderDeleteArgs>(args: SelectSubset<T, ServiceProviderDeleteArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceProvider.
     * @param {ServiceProviderUpdateArgs} args - Arguments to update one ServiceProvider.
     * @example
     * // Update one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceProviderUpdateArgs>(args: SelectSubset<T, ServiceProviderUpdateArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceProviders.
     * @param {ServiceProviderDeleteManyArgs} args - Arguments to filter ServiceProviders to delete.
     * @example
     * // Delete a few ServiceProviders
     * const { count } = await prisma.serviceProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceProviderDeleteManyArgs>(args?: SelectSubset<T, ServiceProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceProviderUpdateManyArgs>(args: SelectSubset<T, ServiceProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceProviders and returns the data updated in the database.
     * @param {ServiceProviderUpdateManyAndReturnArgs} args - Arguments to update many ServiceProviders.
     * @example
     * // Update many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceProviders and only return the `id`
     * const serviceProviderWithIdOnly = await prisma.serviceProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceProvider.
     * @param {ServiceProviderUpsertArgs} args - Arguments to update or create a ServiceProvider.
     * @example
     * // Update or create a ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.upsert({
     *   create: {
     *     // ... data to create a ServiceProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceProvider we want to update
     *   }
     * })
     */
    upsert<T extends ServiceProviderUpsertArgs>(args: SelectSubset<T, ServiceProviderUpsertArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderCountArgs} args - Arguments to filter ServiceProviders to count.
     * @example
     * // Count the number of ServiceProviders
     * const count = await prisma.serviceProvider.count({
     *   where: {
     *     // ... the filter for the ServiceProviders we want to count
     *   }
     * })
    **/
    count<T extends ServiceProviderCountArgs>(
      args?: Subset<T, ServiceProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceProviderAggregateArgs>(args: Subset<T, ServiceProviderAggregateArgs>): Prisma.PrismaPromise<GetServiceProviderAggregateType<T>>

    /**
     * Group by ServiceProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceProviderGroupByArgs['orderBy'] }
        : { orderBy?: ServiceProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceProvider model
   */
  readonly fields: ServiceProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ServiceProvider$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$scheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointment<T extends ServiceProvider$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$appointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    education<T extends ServiceProvider$educationArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$educationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workExperience<T extends ServiceProvider$workExperienceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$workExperienceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    awards<T extends ServiceProvider$awardsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$awardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labResults<T extends ServiceProvider$labResultsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$labResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    therapyPlans<T extends ServiceProvider$therapyPlansArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$therapyPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rating<T extends ServiceProvider$ratingArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalRecords<T extends ServiceProvider$medicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$medicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctor<T extends ServiceProvider$doctorArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$doctorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinicInfo<T extends ServiceProvider$clinicInfoArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$clinicInfoArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adminPanel<T extends ServiceProvider$adminPanelArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$adminPanelArgs<ExtArgs>>): Prisma__AdminPanelClient<$Result.GetResult<Prisma.$AdminPanelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tags<T extends ServiceProvider$tagsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceProvider model
   */
  interface ServiceProviderFieldRefs {
    readonly id: FieldRef<"ServiceProvider", 'String'>
    readonly providerId: FieldRef<"ServiceProvider", 'String'>
    readonly name: FieldRef<"ServiceProvider", 'String'>
    readonly age: FieldRef<"ServiceProvider", 'Int'>
    readonly dob: FieldRef<"ServiceProvider", 'DateTime'>
    readonly providerType: FieldRef<"ServiceProvider", 'ProviderType'>
    readonly specialization: FieldRef<"ServiceProvider", 'String[]'>
    readonly fee: FieldRef<"ServiceProvider", 'Float'>
    readonly experience: FieldRef<"ServiceProvider", 'Int'>
    readonly description: FieldRef<"ServiceProvider", 'String'>
    readonly service: FieldRef<"ServiceProvider", 'Service[]'>
    readonly status: FieldRef<"ServiceProvider", 'Status'>
    readonly document: FieldRef<"ServiceProvider", 'String'>
    readonly registrationNumber: FieldRef<"ServiceProvider", 'String'>
    readonly clinicInfoId: FieldRef<"ServiceProvider", 'String'>
    readonly adminPanelId: FieldRef<"ServiceProvider", 'String'>
    readonly userId: FieldRef<"ServiceProvider", 'String'>
    readonly createdAt: FieldRef<"ServiceProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceProvider findUnique
   */
  export type ServiceProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider findUniqueOrThrow
   */
  export type ServiceProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider findFirst
   */
  export type ServiceProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProviders.
     */
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider findFirstOrThrow
   */
  export type ServiceProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProviders.
     */
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider findMany
   */
  export type ServiceProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProviders to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider create
   */
  export type ServiceProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceProvider.
     */
    data: XOR<ServiceProviderCreateInput, ServiceProviderUncheckedCreateInput>
  }

  /**
   * ServiceProvider createMany
   */
  export type ServiceProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceProviders.
     */
    data: ServiceProviderCreateManyInput | ServiceProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceProvider createManyAndReturn
   */
  export type ServiceProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceProviders.
     */
    data: ServiceProviderCreateManyInput | ServiceProviderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceProvider update
   */
  export type ServiceProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceProvider.
     */
    data: XOR<ServiceProviderUpdateInput, ServiceProviderUncheckedUpdateInput>
    /**
     * Choose, which ServiceProvider to update.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider updateMany
   */
  export type ServiceProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceProviders.
     */
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyInput>
    /**
     * Filter which ServiceProviders to update
     */
    where?: ServiceProviderWhereInput
    /**
     * Limit how many ServiceProviders to update.
     */
    limit?: number
  }

  /**
   * ServiceProvider updateManyAndReturn
   */
  export type ServiceProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * The data used to update ServiceProviders.
     */
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyInput>
    /**
     * Filter which ServiceProviders to update
     */
    where?: ServiceProviderWhereInput
    /**
     * Limit how many ServiceProviders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceProvider upsert
   */
  export type ServiceProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceProvider to update in case it exists.
     */
    where: ServiceProviderWhereUniqueInput
    /**
     * In case the ServiceProvider found by the `where` argument doesn't exist, create a new ServiceProvider with this data.
     */
    create: XOR<ServiceProviderCreateInput, ServiceProviderUncheckedCreateInput>
    /**
     * In case the ServiceProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceProviderUpdateInput, ServiceProviderUncheckedUpdateInput>
  }

  /**
   * ServiceProvider delete
   */
  export type ServiceProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter which ServiceProvider to delete.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider deleteMany
   */
  export type ServiceProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProviders to delete
     */
    where?: ServiceProviderWhereInput
    /**
     * Limit how many ServiceProviders to delete.
     */
    limit?: number
  }

  /**
   * ServiceProvider.schedule
   */
  export type ServiceProvider$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * ServiceProvider.appointment
   */
  export type ServiceProvider$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * ServiceProvider.education
   */
  export type ServiceProvider$educationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    cursor?: EducationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * ServiceProvider.workExperience
   */
  export type ServiceProvider$workExperienceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    where?: WorkExperienceWhereInput
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    cursor?: WorkExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkExperienceScalarFieldEnum | WorkExperienceScalarFieldEnum[]
  }

  /**
   * ServiceProvider.awards
   */
  export type ServiceProvider$awardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    where?: AwardWhereInput
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    cursor?: AwardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AwardScalarFieldEnum | AwardScalarFieldEnum[]
  }

  /**
   * ServiceProvider.labResults
   */
  export type ServiceProvider$labResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    cursor?: LabResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * ServiceProvider.therapyPlans
   */
  export type ServiceProvider$therapyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    where?: TherapyPlanWhereInput
    orderBy?: TherapyPlanOrderByWithRelationInput | TherapyPlanOrderByWithRelationInput[]
    cursor?: TherapyPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TherapyPlanScalarFieldEnum | TherapyPlanScalarFieldEnum[]
  }

  /**
   * ServiceProvider.rating
   */
  export type ServiceProvider$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * ServiceProvider.medicalRecords
   */
  export type ServiceProvider$medicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * ServiceProvider.doctor
   */
  export type ServiceProvider$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    cursor?: DoctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * ServiceProvider.clinicInfo
   */
  export type ServiceProvider$clinicInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    where?: ClinicInfoWhereInput
  }

  /**
   * ServiceProvider.adminPanel
   */
  export type ServiceProvider$adminPanelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPanel
     */
    select?: AdminPanelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPanel
     */
    omit?: AdminPanelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPanelInclude<ExtArgs> | null
    where?: AdminPanelWhereInput
  }

  /**
   * ServiceProvider.tags
   */
  export type ServiceProvider$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * ServiceProvider without action
   */
  export type ServiceProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
  }


  /**
   * Model Doctor
   */

  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceproviderId: string | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceproviderId: string | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    userId: number
    serviceproviderId: number
    _all: number
  }


  export type DoctorMinAggregateInputType = {
    id?: true
    userId?: true
    serviceproviderId?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceproviderId?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    userId?: true
    serviceproviderId?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithAggregationInput | DoctorOrderByWithAggregationInput[]
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }

  export type DoctorGroupByOutputType = {
    id: string
    userId: string
    serviceproviderId: string
    _count: DoctorCountAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceproviderId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    prescriptions?: boolean | Doctor$prescriptionsArgs<ExtArgs>
    assistants?: boolean | Doctor$assistantsArgs<ExtArgs>
    requests?: boolean | Doctor$requestsArgs<ExtArgs>
    serviceprovider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceproviderId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceprovider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceproviderId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceprovider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceproviderId?: boolean
  }

  export type DoctorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "serviceproviderId", ExtArgs["result"]["doctor"]>
  export type DoctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    prescriptions?: boolean | Doctor$prescriptionsArgs<ExtArgs>
    assistants?: boolean | Doctor$assistantsArgs<ExtArgs>
    requests?: boolean | Doctor$requestsArgs<ExtArgs>
    serviceprovider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceprovider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type DoctorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceprovider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $DoctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      assistants: Prisma.$DoctorsAssistantPayload<ExtArgs>[]
      requests: Prisma.$RequestPayload<ExtArgs>[]
      serviceprovider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceproviderId: string
    }, ExtArgs["result"]["doctor"]>
    composites: {}
  }

  type DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = $Result.GetResult<Prisma.$DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoctorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorFindUniqueArgs>(args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Doctor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorFindFirstArgs>(args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorFindManyArgs>(args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
     */
    create<T extends DoctorCreateArgs>(args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Doctors.
     * @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorCreateManyArgs>(args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
     */
    delete<T extends DoctorDeleteArgs>(args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorUpdateArgs>(args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorDeleteManyArgs>(args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorUpdateManyArgs>(args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors and returns the data updated in the database.
     * @param {DoctorUpdateManyAndReturnArgs} args - Arguments to update many Doctors.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoctorUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
     */
    upsert<T extends DoctorUpsertArgs>(args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctor model
   */
  readonly fields: DoctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prescriptions<T extends Doctor$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assistants<T extends Doctor$assistantsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$assistantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requests<T extends Doctor$requestsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceprovider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctor model
   */
  interface DoctorFieldRefs {
    readonly id: FieldRef<"Doctor", 'String'>
    readonly userId: FieldRef<"Doctor", 'String'>
    readonly serviceproviderId: FieldRef<"Doctor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Doctor findUnique
   */
  export type DoctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findFirst
   */
  export type DoctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }

  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctor createManyAndReturn
   */
  export type DoctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
  }

  /**
   * Doctor updateManyAndReturn
   */
  export type DoctorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }

  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to delete.
     */
    limit?: number
  }

  /**
   * Doctor.prescriptions
   */
  export type Doctor$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Doctor.assistants
   */
  export type Doctor$assistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    where?: DoctorsAssistantWhereInput
    orderBy?: DoctorsAssistantOrderByWithRelationInput | DoctorsAssistantOrderByWithRelationInput[]
    cursor?: DoctorsAssistantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorsAssistantScalarFieldEnum | DoctorsAssistantScalarFieldEnum[]
  }

  /**
   * Doctor.requests
   */
  export type Doctor$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Doctor without action
   */
  export type DoctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
  }


  /**
   * Model DoctorsAssistant
   */

  export type AggregateDoctorsAssistant = {
    _count: DoctorsAssistantCountAggregateOutputType | null
    _min: DoctorsAssistantMinAggregateOutputType | null
    _max: DoctorsAssistantMaxAggregateOutputType | null
  }

  export type DoctorsAssistantMinAggregateOutputType = {
    id: string | null
    userId: string | null
    assignedDoctorId: string | null
  }

  export type DoctorsAssistantMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    assignedDoctorId: string | null
  }

  export type DoctorsAssistantCountAggregateOutputType = {
    id: number
    userId: number
    assignedDoctorId: number
    _all: number
  }


  export type DoctorsAssistantMinAggregateInputType = {
    id?: true
    userId?: true
    assignedDoctorId?: true
  }

  export type DoctorsAssistantMaxAggregateInputType = {
    id?: true
    userId?: true
    assignedDoctorId?: true
  }

  export type DoctorsAssistantCountAggregateInputType = {
    id?: true
    userId?: true
    assignedDoctorId?: true
    _all?: true
  }

  export type DoctorsAssistantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorsAssistant to aggregate.
     */
    where?: DoctorsAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorsAssistants to fetch.
     */
    orderBy?: DoctorsAssistantOrderByWithRelationInput | DoctorsAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorsAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorsAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorsAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorsAssistants
    **/
    _count?: true | DoctorsAssistantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorsAssistantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorsAssistantMaxAggregateInputType
  }

  export type GetDoctorsAssistantAggregateType<T extends DoctorsAssistantAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorsAssistant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorsAssistant[P]>
      : GetScalarType<T[P], AggregateDoctorsAssistant[P]>
  }




  export type DoctorsAssistantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorsAssistantWhereInput
    orderBy?: DoctorsAssistantOrderByWithAggregationInput | DoctorsAssistantOrderByWithAggregationInput[]
    by: DoctorsAssistantScalarFieldEnum[] | DoctorsAssistantScalarFieldEnum
    having?: DoctorsAssistantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorsAssistantCountAggregateInputType | true
    _min?: DoctorsAssistantMinAggregateInputType
    _max?: DoctorsAssistantMaxAggregateInputType
  }

  export type DoctorsAssistantGroupByOutputType = {
    id: string
    userId: string
    assignedDoctorId: string
    _count: DoctorsAssistantCountAggregateOutputType | null
    _min: DoctorsAssistantMinAggregateOutputType | null
    _max: DoctorsAssistantMaxAggregateOutputType | null
  }

  type GetDoctorsAssistantGroupByPayload<T extends DoctorsAssistantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorsAssistantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorsAssistantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorsAssistantGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorsAssistantGroupByOutputType[P]>
        }
      >
    >


  export type DoctorsAssistantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignedDoctorId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    requestPermissions?: boolean | DoctorsAssistant$requestPermissionsArgs<ExtArgs>
    _count?: boolean | DoctorsAssistantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorsAssistant"]>

  export type DoctorsAssistantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignedDoctorId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorsAssistant"]>

  export type DoctorsAssistantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignedDoctorId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorsAssistant"]>

  export type DoctorsAssistantSelectScalar = {
    id?: boolean
    userId?: boolean
    assignedDoctorId?: boolean
  }

  export type DoctorsAssistantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "assignedDoctorId", ExtArgs["result"]["doctorsAssistant"]>
  export type DoctorsAssistantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    requestPermissions?: boolean | DoctorsAssistant$requestPermissionsArgs<ExtArgs>
    _count?: boolean | DoctorsAssistantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoctorsAssistantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }
  export type DoctorsAssistantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }

  export type $DoctorsAssistantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorsAssistant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      doctor: Prisma.$DoctorPayload<ExtArgs>
      requestPermissions: Prisma.$RequestPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      assignedDoctorId: string
    }, ExtArgs["result"]["doctorsAssistant"]>
    composites: {}
  }

  type DoctorsAssistantGetPayload<S extends boolean | null | undefined | DoctorsAssistantDefaultArgs> = $Result.GetResult<Prisma.$DoctorsAssistantPayload, S>

  type DoctorsAssistantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoctorsAssistantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorsAssistantCountAggregateInputType | true
    }

  export interface DoctorsAssistantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorsAssistant'], meta: { name: 'DoctorsAssistant' } }
    /**
     * Find zero or one DoctorsAssistant that matches the filter.
     * @param {DoctorsAssistantFindUniqueArgs} args - Arguments to find a DoctorsAssistant
     * @example
     * // Get one DoctorsAssistant
     * const doctorsAssistant = await prisma.doctorsAssistant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorsAssistantFindUniqueArgs>(args: SelectSubset<T, DoctorsAssistantFindUniqueArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DoctorsAssistant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorsAssistantFindUniqueOrThrowArgs} args - Arguments to find a DoctorsAssistant
     * @example
     * // Get one DoctorsAssistant
     * const doctorsAssistant = await prisma.doctorsAssistant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorsAssistantFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorsAssistantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DoctorsAssistant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAssistantFindFirstArgs} args - Arguments to find a DoctorsAssistant
     * @example
     * // Get one DoctorsAssistant
     * const doctorsAssistant = await prisma.doctorsAssistant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorsAssistantFindFirstArgs>(args?: SelectSubset<T, DoctorsAssistantFindFirstArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DoctorsAssistant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAssistantFindFirstOrThrowArgs} args - Arguments to find a DoctorsAssistant
     * @example
     * // Get one DoctorsAssistant
     * const doctorsAssistant = await prisma.doctorsAssistant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorsAssistantFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorsAssistantFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DoctorsAssistants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAssistantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorsAssistants
     * const doctorsAssistants = await prisma.doctorsAssistant.findMany()
     * 
     * // Get first 10 DoctorsAssistants
     * const doctorsAssistants = await prisma.doctorsAssistant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorsAssistantWithIdOnly = await prisma.doctorsAssistant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorsAssistantFindManyArgs>(args?: SelectSubset<T, DoctorsAssistantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DoctorsAssistant.
     * @param {DoctorsAssistantCreateArgs} args - Arguments to create a DoctorsAssistant.
     * @example
     * // Create one DoctorsAssistant
     * const DoctorsAssistant = await prisma.doctorsAssistant.create({
     *   data: {
     *     // ... data to create a DoctorsAssistant
     *   }
     * })
     * 
     */
    create<T extends DoctorsAssistantCreateArgs>(args: SelectSubset<T, DoctorsAssistantCreateArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DoctorsAssistants.
     * @param {DoctorsAssistantCreateManyArgs} args - Arguments to create many DoctorsAssistants.
     * @example
     * // Create many DoctorsAssistants
     * const doctorsAssistant = await prisma.doctorsAssistant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorsAssistantCreateManyArgs>(args?: SelectSubset<T, DoctorsAssistantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorsAssistants and returns the data saved in the database.
     * @param {DoctorsAssistantCreateManyAndReturnArgs} args - Arguments to create many DoctorsAssistants.
     * @example
     * // Create many DoctorsAssistants
     * const doctorsAssistant = await prisma.doctorsAssistant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorsAssistants and only return the `id`
     * const doctorsAssistantWithIdOnly = await prisma.doctorsAssistant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorsAssistantCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorsAssistantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DoctorsAssistant.
     * @param {DoctorsAssistantDeleteArgs} args - Arguments to delete one DoctorsAssistant.
     * @example
     * // Delete one DoctorsAssistant
     * const DoctorsAssistant = await prisma.doctorsAssistant.delete({
     *   where: {
     *     // ... filter to delete one DoctorsAssistant
     *   }
     * })
     * 
     */
    delete<T extends DoctorsAssistantDeleteArgs>(args: SelectSubset<T, DoctorsAssistantDeleteArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DoctorsAssistant.
     * @param {DoctorsAssistantUpdateArgs} args - Arguments to update one DoctorsAssistant.
     * @example
     * // Update one DoctorsAssistant
     * const doctorsAssistant = await prisma.doctorsAssistant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorsAssistantUpdateArgs>(args: SelectSubset<T, DoctorsAssistantUpdateArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DoctorsAssistants.
     * @param {DoctorsAssistantDeleteManyArgs} args - Arguments to filter DoctorsAssistants to delete.
     * @example
     * // Delete a few DoctorsAssistants
     * const { count } = await prisma.doctorsAssistant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorsAssistantDeleteManyArgs>(args?: SelectSubset<T, DoctorsAssistantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorsAssistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAssistantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorsAssistants
     * const doctorsAssistant = await prisma.doctorsAssistant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorsAssistantUpdateManyArgs>(args: SelectSubset<T, DoctorsAssistantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorsAssistants and returns the data updated in the database.
     * @param {DoctorsAssistantUpdateManyAndReturnArgs} args - Arguments to update many DoctorsAssistants.
     * @example
     * // Update many DoctorsAssistants
     * const doctorsAssistant = await prisma.doctorsAssistant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DoctorsAssistants and only return the `id`
     * const doctorsAssistantWithIdOnly = await prisma.doctorsAssistant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoctorsAssistantUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorsAssistantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DoctorsAssistant.
     * @param {DoctorsAssistantUpsertArgs} args - Arguments to update or create a DoctorsAssistant.
     * @example
     * // Update or create a DoctorsAssistant
     * const doctorsAssistant = await prisma.doctorsAssistant.upsert({
     *   create: {
     *     // ... data to create a DoctorsAssistant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorsAssistant we want to update
     *   }
     * })
     */
    upsert<T extends DoctorsAssistantUpsertArgs>(args: SelectSubset<T, DoctorsAssistantUpsertArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DoctorsAssistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAssistantCountArgs} args - Arguments to filter DoctorsAssistants to count.
     * @example
     * // Count the number of DoctorsAssistants
     * const count = await prisma.doctorsAssistant.count({
     *   where: {
     *     // ... the filter for the DoctorsAssistants we want to count
     *   }
     * })
    **/
    count<T extends DoctorsAssistantCountArgs>(
      args?: Subset<T, DoctorsAssistantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorsAssistantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorsAssistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAssistantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorsAssistantAggregateArgs>(args: Subset<T, DoctorsAssistantAggregateArgs>): Prisma.PrismaPromise<GetDoctorsAssistantAggregateType<T>>

    /**
     * Group by DoctorsAssistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAssistantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorsAssistantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorsAssistantGroupByArgs['orderBy'] }
        : { orderBy?: DoctorsAssistantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorsAssistantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorsAssistantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorsAssistant model
   */
  readonly fields: DoctorsAssistantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorsAssistant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorsAssistantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestPermissions<T extends DoctorsAssistant$requestPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, DoctorsAssistant$requestPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorsAssistant model
   */
  interface DoctorsAssistantFieldRefs {
    readonly id: FieldRef<"DoctorsAssistant", 'String'>
    readonly userId: FieldRef<"DoctorsAssistant", 'String'>
    readonly assignedDoctorId: FieldRef<"DoctorsAssistant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DoctorsAssistant findUnique
   */
  export type DoctorsAssistantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DoctorsAssistant to fetch.
     */
    where: DoctorsAssistantWhereUniqueInput
  }

  /**
   * DoctorsAssistant findUniqueOrThrow
   */
  export type DoctorsAssistantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DoctorsAssistant to fetch.
     */
    where: DoctorsAssistantWhereUniqueInput
  }

  /**
   * DoctorsAssistant findFirst
   */
  export type DoctorsAssistantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DoctorsAssistant to fetch.
     */
    where?: DoctorsAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorsAssistants to fetch.
     */
    orderBy?: DoctorsAssistantOrderByWithRelationInput | DoctorsAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorsAssistants.
     */
    cursor?: DoctorsAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorsAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorsAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorsAssistants.
     */
    distinct?: DoctorsAssistantScalarFieldEnum | DoctorsAssistantScalarFieldEnum[]
  }

  /**
   * DoctorsAssistant findFirstOrThrow
   */
  export type DoctorsAssistantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DoctorsAssistant to fetch.
     */
    where?: DoctorsAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorsAssistants to fetch.
     */
    orderBy?: DoctorsAssistantOrderByWithRelationInput | DoctorsAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorsAssistants.
     */
    cursor?: DoctorsAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorsAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorsAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorsAssistants.
     */
    distinct?: DoctorsAssistantScalarFieldEnum | DoctorsAssistantScalarFieldEnum[]
  }

  /**
   * DoctorsAssistant findMany
   */
  export type DoctorsAssistantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DoctorsAssistants to fetch.
     */
    where?: DoctorsAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorsAssistants to fetch.
     */
    orderBy?: DoctorsAssistantOrderByWithRelationInput | DoctorsAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorsAssistants.
     */
    cursor?: DoctorsAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorsAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorsAssistants.
     */
    skip?: number
    distinct?: DoctorsAssistantScalarFieldEnum | DoctorsAssistantScalarFieldEnum[]
  }

  /**
   * DoctorsAssistant create
   */
  export type DoctorsAssistantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorsAssistant.
     */
    data: XOR<DoctorsAssistantCreateInput, DoctorsAssistantUncheckedCreateInput>
  }

  /**
   * DoctorsAssistant createMany
   */
  export type DoctorsAssistantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorsAssistants.
     */
    data: DoctorsAssistantCreateManyInput | DoctorsAssistantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoctorsAssistant createManyAndReturn
   */
  export type DoctorsAssistantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * The data used to create many DoctorsAssistants.
     */
    data: DoctorsAssistantCreateManyInput | DoctorsAssistantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorsAssistant update
   */
  export type DoctorsAssistantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorsAssistant.
     */
    data: XOR<DoctorsAssistantUpdateInput, DoctorsAssistantUncheckedUpdateInput>
    /**
     * Choose, which DoctorsAssistant to update.
     */
    where: DoctorsAssistantWhereUniqueInput
  }

  /**
   * DoctorsAssistant updateMany
   */
  export type DoctorsAssistantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorsAssistants.
     */
    data: XOR<DoctorsAssistantUpdateManyMutationInput, DoctorsAssistantUncheckedUpdateManyInput>
    /**
     * Filter which DoctorsAssistants to update
     */
    where?: DoctorsAssistantWhereInput
    /**
     * Limit how many DoctorsAssistants to update.
     */
    limit?: number
  }

  /**
   * DoctorsAssistant updateManyAndReturn
   */
  export type DoctorsAssistantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * The data used to update DoctorsAssistants.
     */
    data: XOR<DoctorsAssistantUpdateManyMutationInput, DoctorsAssistantUncheckedUpdateManyInput>
    /**
     * Filter which DoctorsAssistants to update
     */
    where?: DoctorsAssistantWhereInput
    /**
     * Limit how many DoctorsAssistants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorsAssistant upsert
   */
  export type DoctorsAssistantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorsAssistant to update in case it exists.
     */
    where: DoctorsAssistantWhereUniqueInput
    /**
     * In case the DoctorsAssistant found by the `where` argument doesn't exist, create a new DoctorsAssistant with this data.
     */
    create: XOR<DoctorsAssistantCreateInput, DoctorsAssistantUncheckedCreateInput>
    /**
     * In case the DoctorsAssistant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorsAssistantUpdateInput, DoctorsAssistantUncheckedUpdateInput>
  }

  /**
   * DoctorsAssistant delete
   */
  export type DoctorsAssistantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    /**
     * Filter which DoctorsAssistant to delete.
     */
    where: DoctorsAssistantWhereUniqueInput
  }

  /**
   * DoctorsAssistant deleteMany
   */
  export type DoctorsAssistantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorsAssistants to delete
     */
    where?: DoctorsAssistantWhereInput
    /**
     * Limit how many DoctorsAssistants to delete.
     */
    limit?: number
  }

  /**
   * DoctorsAssistant.requestPermissions
   */
  export type DoctorsAssistant$requestPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    where?: RequestPermissionWhereInput
    orderBy?: RequestPermissionOrderByWithRelationInput | RequestPermissionOrderByWithRelationInput[]
    cursor?: RequestPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestPermissionScalarFieldEnum | RequestPermissionScalarFieldEnum[]
  }

  /**
   * DoctorsAssistant without action
   */
  export type DoctorsAssistantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
  }


  /**
   * Model Lab
   */

  export type AggregateLab = {
    _count: LabCountAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  export type LabMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type LabMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type LabCountAggregateOutputType = {
    id: number
    userId: number
    servicesOffered: number
    _all: number
  }


  export type LabMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LabMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LabCountAggregateInputType = {
    id?: true
    userId?: true
    servicesOffered?: true
    _all?: true
  }

  export type LabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lab to aggregate.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labs
    **/
    _count?: true | LabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabMaxAggregateInputType
  }

  export type GetLabAggregateType<T extends LabAggregateArgs> = {
        [P in keyof T & keyof AggregateLab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab[P]>
      : GetScalarType<T[P], AggregateLab[P]>
  }




  export type LabGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabWhereInput
    orderBy?: LabOrderByWithAggregationInput | LabOrderByWithAggregationInput[]
    by: LabScalarFieldEnum[] | LabScalarFieldEnum
    having?: LabScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabCountAggregateInputType | true
    _min?: LabMinAggregateInputType
    _max?: LabMaxAggregateInputType
  }

  export type LabGroupByOutputType = {
    id: string
    userId: string
    servicesOffered: string[]
    _count: LabCountAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  type GetLabGroupByPayload<T extends LabGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabGroupByOutputType[P]>
            : GetScalarType<T[P], LabGroupByOutputType[P]>
        }
      >
    >


  export type LabSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectScalar = {
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
  }

  export type LabOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "servicesOffered", ExtArgs["result"]["lab"]>
  export type LabInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LabIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LabIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LabPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lab"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      servicesOffered: string[]
    }, ExtArgs["result"]["lab"]>
    composites: {}
  }

  type LabGetPayload<S extends boolean | null | undefined | LabDefaultArgs> = $Result.GetResult<Prisma.$LabPayload, S>

  type LabCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabCountAggregateInputType | true
    }

  export interface LabDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lab'], meta: { name: 'Lab' } }
    /**
     * Find zero or one Lab that matches the filter.
     * @param {LabFindUniqueArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabFindUniqueArgs>(args: SelectSubset<T, LabFindUniqueArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lab that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabFindUniqueOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabFindUniqueOrThrowArgs>(args: SelectSubset<T, LabFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindFirstArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabFindFirstArgs>(args?: SelectSubset<T, LabFindFirstArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindFirstOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabFindFirstOrThrowArgs>(args?: SelectSubset<T, LabFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labs
     * const labs = await prisma.lab.findMany()
     * 
     * // Get first 10 Labs
     * const labs = await prisma.lab.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labWithIdOnly = await prisma.lab.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabFindManyArgs>(args?: SelectSubset<T, LabFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lab.
     * @param {LabCreateArgs} args - Arguments to create a Lab.
     * @example
     * // Create one Lab
     * const Lab = await prisma.lab.create({
     *   data: {
     *     // ... data to create a Lab
     *   }
     * })
     * 
     */
    create<T extends LabCreateArgs>(args: SelectSubset<T, LabCreateArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Labs.
     * @param {LabCreateManyArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabCreateManyArgs>(args?: SelectSubset<T, LabCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Labs and returns the data saved in the database.
     * @param {LabCreateManyAndReturnArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Labs and only return the `id`
     * const labWithIdOnly = await prisma.lab.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabCreateManyAndReturnArgs>(args?: SelectSubset<T, LabCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lab.
     * @param {LabDeleteArgs} args - Arguments to delete one Lab.
     * @example
     * // Delete one Lab
     * const Lab = await prisma.lab.delete({
     *   where: {
     *     // ... filter to delete one Lab
     *   }
     * })
     * 
     */
    delete<T extends LabDeleteArgs>(args: SelectSubset<T, LabDeleteArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lab.
     * @param {LabUpdateArgs} args - Arguments to update one Lab.
     * @example
     * // Update one Lab
     * const lab = await prisma.lab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabUpdateArgs>(args: SelectSubset<T, LabUpdateArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Labs.
     * @param {LabDeleteManyArgs} args - Arguments to filter Labs to delete.
     * @example
     * // Delete a few Labs
     * const { count } = await prisma.lab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabDeleteManyArgs>(args?: SelectSubset<T, LabDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabUpdateManyArgs>(args: SelectSubset<T, LabUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs and returns the data updated in the database.
     * @param {LabUpdateManyAndReturnArgs} args - Arguments to update many Labs.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Labs and only return the `id`
     * const labWithIdOnly = await prisma.lab.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabUpdateManyAndReturnArgs>(args: SelectSubset<T, LabUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lab.
     * @param {LabUpsertArgs} args - Arguments to update or create a Lab.
     * @example
     * // Update or create a Lab
     * const lab = await prisma.lab.upsert({
     *   create: {
     *     // ... data to create a Lab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab we want to update
     *   }
     * })
     */
    upsert<T extends LabUpsertArgs>(args: SelectSubset<T, LabUpsertArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabCountArgs} args - Arguments to filter Labs to count.
     * @example
     * // Count the number of Labs
     * const count = await prisma.lab.count({
     *   where: {
     *     // ... the filter for the Labs we want to count
     *   }
     * })
    **/
    count<T extends LabCountArgs>(
      args?: Subset<T, LabCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabAggregateArgs>(args: Subset<T, LabAggregateArgs>): Prisma.PrismaPromise<GetLabAggregateType<T>>

    /**
     * Group by Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabGroupByArgs['orderBy'] }
        : { orderBy?: LabGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lab model
   */
  readonly fields: LabFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lab model
   */
  interface LabFieldRefs {
    readonly id: FieldRef<"Lab", 'String'>
    readonly userId: FieldRef<"Lab", 'String'>
    readonly servicesOffered: FieldRef<"Lab", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Lab findUnique
   */
  export type LabFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab findUniqueOrThrow
   */
  export type LabFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab findFirst
   */
  export type LabFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab findFirstOrThrow
   */
  export type LabFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab findMany
   */
  export type LabFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Labs to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab create
   */
  export type LabCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The data needed to create a Lab.
     */
    data: XOR<LabCreateInput, LabUncheckedCreateInput>
  }

  /**
   * Lab createMany
   */
  export type LabCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labs.
     */
    data: LabCreateManyInput | LabCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lab createManyAndReturn
   */
  export type LabCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * The data used to create many Labs.
     */
    data: LabCreateManyInput | LabCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lab update
   */
  export type LabUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The data needed to update a Lab.
     */
    data: XOR<LabUpdateInput, LabUncheckedUpdateInput>
    /**
     * Choose, which Lab to update.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab updateMany
   */
  export type LabUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labs.
     */
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyInput>
    /**
     * Filter which Labs to update
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to update.
     */
    limit?: number
  }

  /**
   * Lab updateManyAndReturn
   */
  export type LabUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * The data used to update Labs.
     */
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyInput>
    /**
     * Filter which Labs to update
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lab upsert
   */
  export type LabUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The filter to search for the Lab to update in case it exists.
     */
    where: LabWhereUniqueInput
    /**
     * In case the Lab found by the `where` argument doesn't exist, create a new Lab with this data.
     */
    create: XOR<LabCreateInput, LabUncheckedCreateInput>
    /**
     * In case the Lab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabUpdateInput, LabUncheckedUpdateInput>
  }

  /**
   * Lab delete
   */
  export type LabDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter which Lab to delete.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab deleteMany
   */
  export type LabDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labs to delete
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to delete.
     */
    limit?: number
  }

  /**
   * Lab without action
   */
  export type LabDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
  }


  /**
   * Model Hospital
   */

  export type AggregateHospital = {
    _count: HospitalCountAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  export type HospitalMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type HospitalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type HospitalCountAggregateOutputType = {
    id: number
    userId: number
    servicesOffered: number
    _all: number
  }


  export type HospitalMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type HospitalMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type HospitalCountAggregateInputType = {
    id?: true
    userId?: true
    servicesOffered?: true
    _all?: true
  }

  export type HospitalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospital to aggregate.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hospitals
    **/
    _count?: true | HospitalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalMaxAggregateInputType
  }

  export type GetHospitalAggregateType<T extends HospitalAggregateArgs> = {
        [P in keyof T & keyof AggregateHospital]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospital[P]>
      : GetScalarType<T[P], AggregateHospital[P]>
  }




  export type HospitalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalWhereInput
    orderBy?: HospitalOrderByWithAggregationInput | HospitalOrderByWithAggregationInput[]
    by: HospitalScalarFieldEnum[] | HospitalScalarFieldEnum
    having?: HospitalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalCountAggregateInputType | true
    _min?: HospitalMinAggregateInputType
    _max?: HospitalMaxAggregateInputType
  }

  export type HospitalGroupByOutputType = {
    id: string
    userId: string
    servicesOffered: string[]
    _count: HospitalCountAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  type GetHospitalGroupByPayload<T extends HospitalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospitalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalGroupByOutputType[P]>
        }
      >
    >


  export type HospitalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectScalar = {
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
  }

  export type HospitalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "servicesOffered", ExtArgs["result"]["hospital"]>
  export type HospitalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HospitalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HospitalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HospitalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hospital"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      servicesOffered: string[]
    }, ExtArgs["result"]["hospital"]>
    composites: {}
  }

  type HospitalGetPayload<S extends boolean | null | undefined | HospitalDefaultArgs> = $Result.GetResult<Prisma.$HospitalPayload, S>

  type HospitalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HospitalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HospitalCountAggregateInputType | true
    }

  export interface HospitalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hospital'], meta: { name: 'Hospital' } }
    /**
     * Find zero or one Hospital that matches the filter.
     * @param {HospitalFindUniqueArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalFindUniqueArgs>(args: SelectSubset<T, HospitalFindUniqueArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hospital that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HospitalFindUniqueOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hospital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalFindFirstArgs>(args?: SelectSubset<T, HospitalFindFirstArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hospital that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hospitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospitals
     * const hospitals = await prisma.hospital.findMany()
     * 
     * // Get first 10 Hospitals
     * const hospitals = await prisma.hospital.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalWithIdOnly = await prisma.hospital.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HospitalFindManyArgs>(args?: SelectSubset<T, HospitalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hospital.
     * @param {HospitalCreateArgs} args - Arguments to create a Hospital.
     * @example
     * // Create one Hospital
     * const Hospital = await prisma.hospital.create({
     *   data: {
     *     // ... data to create a Hospital
     *   }
     * })
     * 
     */
    create<T extends HospitalCreateArgs>(args: SelectSubset<T, HospitalCreateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hospitals.
     * @param {HospitalCreateManyArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HospitalCreateManyArgs>(args?: SelectSubset<T, HospitalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hospitals and returns the data saved in the database.
     * @param {HospitalCreateManyAndReturnArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hospitals and only return the `id`
     * const hospitalWithIdOnly = await prisma.hospital.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HospitalCreateManyAndReturnArgs>(args?: SelectSubset<T, HospitalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hospital.
     * @param {HospitalDeleteArgs} args - Arguments to delete one Hospital.
     * @example
     * // Delete one Hospital
     * const Hospital = await prisma.hospital.delete({
     *   where: {
     *     // ... filter to delete one Hospital
     *   }
     * })
     * 
     */
    delete<T extends HospitalDeleteArgs>(args: SelectSubset<T, HospitalDeleteArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hospital.
     * @param {HospitalUpdateArgs} args - Arguments to update one Hospital.
     * @example
     * // Update one Hospital
     * const hospital = await prisma.hospital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HospitalUpdateArgs>(args: SelectSubset<T, HospitalUpdateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hospitals.
     * @param {HospitalDeleteManyArgs} args - Arguments to filter Hospitals to delete.
     * @example
     * // Delete a few Hospitals
     * const { count } = await prisma.hospital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HospitalDeleteManyArgs>(args?: SelectSubset<T, HospitalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HospitalUpdateManyArgs>(args: SelectSubset<T, HospitalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitals and returns the data updated in the database.
     * @param {HospitalUpdateManyAndReturnArgs} args - Arguments to update many Hospitals.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hospitals and only return the `id`
     * const hospitalWithIdOnly = await prisma.hospital.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HospitalUpdateManyAndReturnArgs>(args: SelectSubset<T, HospitalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hospital.
     * @param {HospitalUpsertArgs} args - Arguments to update or create a Hospital.
     * @example
     * // Update or create a Hospital
     * const hospital = await prisma.hospital.upsert({
     *   create: {
     *     // ... data to create a Hospital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospital we want to update
     *   }
     * })
     */
    upsert<T extends HospitalUpsertArgs>(args: SelectSubset<T, HospitalUpsertArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalCountArgs} args - Arguments to filter Hospitals to count.
     * @example
     * // Count the number of Hospitals
     * const count = await prisma.hospital.count({
     *   where: {
     *     // ... the filter for the Hospitals we want to count
     *   }
     * })
    **/
    count<T extends HospitalCountArgs>(
      args?: Subset<T, HospitalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalAggregateArgs>(args: Subset<T, HospitalAggregateArgs>): Prisma.PrismaPromise<GetHospitalAggregateType<T>>

    /**
     * Group by Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalGroupByArgs['orderBy'] }
        : { orderBy?: HospitalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hospital model
   */
  readonly fields: HospitalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hospital.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HospitalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hospital model
   */
  interface HospitalFieldRefs {
    readonly id: FieldRef<"Hospital", 'String'>
    readonly userId: FieldRef<"Hospital", 'String'>
    readonly servicesOffered: FieldRef<"Hospital", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Hospital findUnique
   */
  export type HospitalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findUniqueOrThrow
   */
  export type HospitalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findFirst
   */
  export type HospitalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findFirstOrThrow
   */
  export type HospitalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findMany
   */
  export type HospitalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospitals to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital create
   */
  export type HospitalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The data needed to create a Hospital.
     */
    data: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
  }

  /**
   * Hospital createMany
   */
  export type HospitalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospital createManyAndReturn
   */
  export type HospitalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hospital update
   */
  export type HospitalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The data needed to update a Hospital.
     */
    data: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
    /**
     * Choose, which Hospital to update.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital updateMany
   */
  export type HospitalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput
    /**
     * Limit how many Hospitals to update.
     */
    limit?: number
  }

  /**
   * Hospital updateManyAndReturn
   */
  export type HospitalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput
    /**
     * Limit how many Hospitals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hospital upsert
   */
  export type HospitalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The filter to search for the Hospital to update in case it exists.
     */
    where: HospitalWhereUniqueInput
    /**
     * In case the Hospital found by the `where` argument doesn't exist, create a new Hospital with this data.
     */
    create: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
    /**
     * In case the Hospital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
  }

  /**
   * Hospital delete
   */
  export type HospitalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter which Hospital to delete.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital deleteMany
   */
  export type HospitalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospitals to delete
     */
    where?: HospitalWhereInput
    /**
     * Limit how many Hospitals to delete.
     */
    limit?: number
  }

  /**
   * Hospital without action
   */
  export type HospitalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
  }


  /**
   * Model Nursing
   */

  export type AggregateNursing = {
    _count: NursingCountAggregateOutputType | null
    _min: NursingMinAggregateOutputType | null
    _max: NursingMaxAggregateOutputType | null
  }

  export type NursingMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type NursingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type NursingCountAggregateOutputType = {
    id: number
    userId: number
    servicesOffered: number
    _all: number
  }


  export type NursingMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NursingMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NursingCountAggregateInputType = {
    id?: true
    userId?: true
    servicesOffered?: true
    _all?: true
  }

  export type NursingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nursing to aggregate.
     */
    where?: NursingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nursings to fetch.
     */
    orderBy?: NursingOrderByWithRelationInput | NursingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NursingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nursings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nursings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nursings
    **/
    _count?: true | NursingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NursingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NursingMaxAggregateInputType
  }

  export type GetNursingAggregateType<T extends NursingAggregateArgs> = {
        [P in keyof T & keyof AggregateNursing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNursing[P]>
      : GetScalarType<T[P], AggregateNursing[P]>
  }




  export type NursingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NursingWhereInput
    orderBy?: NursingOrderByWithAggregationInput | NursingOrderByWithAggregationInput[]
    by: NursingScalarFieldEnum[] | NursingScalarFieldEnum
    having?: NursingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NursingCountAggregateInputType | true
    _min?: NursingMinAggregateInputType
    _max?: NursingMaxAggregateInputType
  }

  export type NursingGroupByOutputType = {
    id: string
    userId: string
    servicesOffered: string[]
    _count: NursingCountAggregateOutputType | null
    _min: NursingMinAggregateOutputType | null
    _max: NursingMaxAggregateOutputType | null
  }

  type GetNursingGroupByPayload<T extends NursingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NursingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NursingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NursingGroupByOutputType[P]>
            : GetScalarType<T[P], NursingGroupByOutputType[P]>
        }
      >
    >


  export type NursingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nursing"]>

  export type NursingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nursing"]>

  export type NursingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nursing"]>

  export type NursingSelectScalar = {
    id?: boolean
    userId?: boolean
    servicesOffered?: boolean
  }

  export type NursingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "servicesOffered", ExtArgs["result"]["nursing"]>
  export type NursingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NursingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NursingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NursingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nursing"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      servicesOffered: string[]
    }, ExtArgs["result"]["nursing"]>
    composites: {}
  }

  type NursingGetPayload<S extends boolean | null | undefined | NursingDefaultArgs> = $Result.GetResult<Prisma.$NursingPayload, S>

  type NursingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NursingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NursingCountAggregateInputType | true
    }

  export interface NursingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nursing'], meta: { name: 'Nursing' } }
    /**
     * Find zero or one Nursing that matches the filter.
     * @param {NursingFindUniqueArgs} args - Arguments to find a Nursing
     * @example
     * // Get one Nursing
     * const nursing = await prisma.nursing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NursingFindUniqueArgs>(args: SelectSubset<T, NursingFindUniqueArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nursing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NursingFindUniqueOrThrowArgs} args - Arguments to find a Nursing
     * @example
     * // Get one Nursing
     * const nursing = await prisma.nursing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NursingFindUniqueOrThrowArgs>(args: SelectSubset<T, NursingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nursing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingFindFirstArgs} args - Arguments to find a Nursing
     * @example
     * // Get one Nursing
     * const nursing = await prisma.nursing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NursingFindFirstArgs>(args?: SelectSubset<T, NursingFindFirstArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nursing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingFindFirstOrThrowArgs} args - Arguments to find a Nursing
     * @example
     * // Get one Nursing
     * const nursing = await prisma.nursing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NursingFindFirstOrThrowArgs>(args?: SelectSubset<T, NursingFindFirstOrThrowArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nursings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nursings
     * const nursings = await prisma.nursing.findMany()
     * 
     * // Get first 10 Nursings
     * const nursings = await prisma.nursing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nursingWithIdOnly = await prisma.nursing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NursingFindManyArgs>(args?: SelectSubset<T, NursingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nursing.
     * @param {NursingCreateArgs} args - Arguments to create a Nursing.
     * @example
     * // Create one Nursing
     * const Nursing = await prisma.nursing.create({
     *   data: {
     *     // ... data to create a Nursing
     *   }
     * })
     * 
     */
    create<T extends NursingCreateArgs>(args: SelectSubset<T, NursingCreateArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nursings.
     * @param {NursingCreateManyArgs} args - Arguments to create many Nursings.
     * @example
     * // Create many Nursings
     * const nursing = await prisma.nursing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NursingCreateManyArgs>(args?: SelectSubset<T, NursingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nursings and returns the data saved in the database.
     * @param {NursingCreateManyAndReturnArgs} args - Arguments to create many Nursings.
     * @example
     * // Create many Nursings
     * const nursing = await prisma.nursing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nursings and only return the `id`
     * const nursingWithIdOnly = await prisma.nursing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NursingCreateManyAndReturnArgs>(args?: SelectSubset<T, NursingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Nursing.
     * @param {NursingDeleteArgs} args - Arguments to delete one Nursing.
     * @example
     * // Delete one Nursing
     * const Nursing = await prisma.nursing.delete({
     *   where: {
     *     // ... filter to delete one Nursing
     *   }
     * })
     * 
     */
    delete<T extends NursingDeleteArgs>(args: SelectSubset<T, NursingDeleteArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nursing.
     * @param {NursingUpdateArgs} args - Arguments to update one Nursing.
     * @example
     * // Update one Nursing
     * const nursing = await prisma.nursing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NursingUpdateArgs>(args: SelectSubset<T, NursingUpdateArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nursings.
     * @param {NursingDeleteManyArgs} args - Arguments to filter Nursings to delete.
     * @example
     * // Delete a few Nursings
     * const { count } = await prisma.nursing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NursingDeleteManyArgs>(args?: SelectSubset<T, NursingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nursings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nursings
     * const nursing = await prisma.nursing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NursingUpdateManyArgs>(args: SelectSubset<T, NursingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nursings and returns the data updated in the database.
     * @param {NursingUpdateManyAndReturnArgs} args - Arguments to update many Nursings.
     * @example
     * // Update many Nursings
     * const nursing = await prisma.nursing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nursings and only return the `id`
     * const nursingWithIdOnly = await prisma.nursing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NursingUpdateManyAndReturnArgs>(args: SelectSubset<T, NursingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Nursing.
     * @param {NursingUpsertArgs} args - Arguments to update or create a Nursing.
     * @example
     * // Update or create a Nursing
     * const nursing = await prisma.nursing.upsert({
     *   create: {
     *     // ... data to create a Nursing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nursing we want to update
     *   }
     * })
     */
    upsert<T extends NursingUpsertArgs>(args: SelectSubset<T, NursingUpsertArgs<ExtArgs>>): Prisma__NursingClient<$Result.GetResult<Prisma.$NursingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nursings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingCountArgs} args - Arguments to filter Nursings to count.
     * @example
     * // Count the number of Nursings
     * const count = await prisma.nursing.count({
     *   where: {
     *     // ... the filter for the Nursings we want to count
     *   }
     * })
    **/
    count<T extends NursingCountArgs>(
      args?: Subset<T, NursingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NursingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nursing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NursingAggregateArgs>(args: Subset<T, NursingAggregateArgs>): Prisma.PrismaPromise<GetNursingAggregateType<T>>

    /**
     * Group by Nursing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NursingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NursingGroupByArgs['orderBy'] }
        : { orderBy?: NursingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NursingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNursingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nursing model
   */
  readonly fields: NursingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nursing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NursingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nursing model
   */
  interface NursingFieldRefs {
    readonly id: FieldRef<"Nursing", 'String'>
    readonly userId: FieldRef<"Nursing", 'String'>
    readonly servicesOffered: FieldRef<"Nursing", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Nursing findUnique
   */
  export type NursingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * Filter, which Nursing to fetch.
     */
    where: NursingWhereUniqueInput
  }

  /**
   * Nursing findUniqueOrThrow
   */
  export type NursingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * Filter, which Nursing to fetch.
     */
    where: NursingWhereUniqueInput
  }

  /**
   * Nursing findFirst
   */
  export type NursingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * Filter, which Nursing to fetch.
     */
    where?: NursingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nursings to fetch.
     */
    orderBy?: NursingOrderByWithRelationInput | NursingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nursings.
     */
    cursor?: NursingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nursings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nursings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nursings.
     */
    distinct?: NursingScalarFieldEnum | NursingScalarFieldEnum[]
  }

  /**
   * Nursing findFirstOrThrow
   */
  export type NursingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * Filter, which Nursing to fetch.
     */
    where?: NursingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nursings to fetch.
     */
    orderBy?: NursingOrderByWithRelationInput | NursingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nursings.
     */
    cursor?: NursingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nursings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nursings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nursings.
     */
    distinct?: NursingScalarFieldEnum | NursingScalarFieldEnum[]
  }

  /**
   * Nursing findMany
   */
  export type NursingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * Filter, which Nursings to fetch.
     */
    where?: NursingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nursings to fetch.
     */
    orderBy?: NursingOrderByWithRelationInput | NursingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nursings.
     */
    cursor?: NursingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nursings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nursings.
     */
    skip?: number
    distinct?: NursingScalarFieldEnum | NursingScalarFieldEnum[]
  }

  /**
   * Nursing create
   */
  export type NursingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * The data needed to create a Nursing.
     */
    data: XOR<NursingCreateInput, NursingUncheckedCreateInput>
  }

  /**
   * Nursing createMany
   */
  export type NursingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nursings.
     */
    data: NursingCreateManyInput | NursingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nursing createManyAndReturn
   */
  export type NursingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * The data used to create many Nursings.
     */
    data: NursingCreateManyInput | NursingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nursing update
   */
  export type NursingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * The data needed to update a Nursing.
     */
    data: XOR<NursingUpdateInput, NursingUncheckedUpdateInput>
    /**
     * Choose, which Nursing to update.
     */
    where: NursingWhereUniqueInput
  }

  /**
   * Nursing updateMany
   */
  export type NursingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nursings.
     */
    data: XOR<NursingUpdateManyMutationInput, NursingUncheckedUpdateManyInput>
    /**
     * Filter which Nursings to update
     */
    where?: NursingWhereInput
    /**
     * Limit how many Nursings to update.
     */
    limit?: number
  }

  /**
   * Nursing updateManyAndReturn
   */
  export type NursingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * The data used to update Nursings.
     */
    data: XOR<NursingUpdateManyMutationInput, NursingUncheckedUpdateManyInput>
    /**
     * Filter which Nursings to update
     */
    where?: NursingWhereInput
    /**
     * Limit how many Nursings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nursing upsert
   */
  export type NursingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * The filter to search for the Nursing to update in case it exists.
     */
    where: NursingWhereUniqueInput
    /**
     * In case the Nursing found by the `where` argument doesn't exist, create a new Nursing with this data.
     */
    create: XOR<NursingCreateInput, NursingUncheckedCreateInput>
    /**
     * In case the Nursing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NursingUpdateInput, NursingUncheckedUpdateInput>
  }

  /**
   * Nursing delete
   */
  export type NursingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
    /**
     * Filter which Nursing to delete.
     */
    where: NursingWhereUniqueInput
  }

  /**
   * Nursing deleteMany
   */
  export type NursingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nursings to delete
     */
    where?: NursingWhereInput
    /**
     * Limit how many Nursings to delete.
     */
    limit?: number
  }

  /**
   * Nursing without action
   */
  export type NursingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nursing
     */
    select?: NursingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nursing
     */
    omit?: NursingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingInclude<ExtArgs> | null
  }


  /**
   * Model Allergy
   */

  export type AggregateAllergy = {
    _count: AllergyCountAggregateOutputType | null
    _min: AllergyMinAggregateOutputType | null
    _max: AllergyMaxAggregateOutputType | null
  }

  export type AllergyMinAggregateOutputType = {
    id: string | null
    allergen: string | null
    type: string | null
    severity: string | null
    reaction: string | null
    patientId: string | null
  }

  export type AllergyMaxAggregateOutputType = {
    id: string | null
    allergen: string | null
    type: string | null
    severity: string | null
    reaction: string | null
    patientId: string | null
  }

  export type AllergyCountAggregateOutputType = {
    id: number
    allergen: number
    type: number
    severity: number
    reaction: number
    patientId: number
    _all: number
  }


  export type AllergyMinAggregateInputType = {
    id?: true
    allergen?: true
    type?: true
    severity?: true
    reaction?: true
    patientId?: true
  }

  export type AllergyMaxAggregateInputType = {
    id?: true
    allergen?: true
    type?: true
    severity?: true
    reaction?: true
    patientId?: true
  }

  export type AllergyCountAggregateInputType = {
    id?: true
    allergen?: true
    type?: true
    severity?: true
    reaction?: true
    patientId?: true
    _all?: true
  }

  export type AllergyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergy to aggregate.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Allergies
    **/
    _count?: true | AllergyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllergyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllergyMaxAggregateInputType
  }

  export type GetAllergyAggregateType<T extends AllergyAggregateArgs> = {
        [P in keyof T & keyof AggregateAllergy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllergy[P]>
      : GetScalarType<T[P], AggregateAllergy[P]>
  }




  export type AllergyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyWhereInput
    orderBy?: AllergyOrderByWithAggregationInput | AllergyOrderByWithAggregationInput[]
    by: AllergyScalarFieldEnum[] | AllergyScalarFieldEnum
    having?: AllergyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllergyCountAggregateInputType | true
    _min?: AllergyMinAggregateInputType
    _max?: AllergyMaxAggregateInputType
  }

  export type AllergyGroupByOutputType = {
    id: string
    allergen: string
    type: string
    severity: string
    reaction: string
    patientId: string
    _count: AllergyCountAggregateOutputType | null
    _min: AllergyMinAggregateOutputType | null
    _max: AllergyMaxAggregateOutputType | null
  }

  type GetAllergyGroupByPayload<T extends AllergyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllergyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllergyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllergyGroupByOutputType[P]>
            : GetScalarType<T[P], AllergyGroupByOutputType[P]>
        }
      >
    >


  export type AllergySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    allergen?: boolean
    type?: boolean
    severity?: boolean
    reaction?: boolean
    patientId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergy"]>

  export type AllergySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    allergen?: boolean
    type?: boolean
    severity?: boolean
    reaction?: boolean
    patientId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergy"]>

  export type AllergySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    allergen?: boolean
    type?: boolean
    severity?: boolean
    reaction?: boolean
    patientId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergy"]>

  export type AllergySelectScalar = {
    id?: boolean
    allergen?: boolean
    type?: boolean
    severity?: boolean
    reaction?: boolean
    patientId?: boolean
  }

  export type AllergyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "allergen" | "type" | "severity" | "reaction" | "patientId", ExtArgs["result"]["allergy"]>
  export type AllergyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AllergyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AllergyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $AllergyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Allergy"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      allergen: string
      type: string
      severity: string
      reaction: string
      patientId: string
    }, ExtArgs["result"]["allergy"]>
    composites: {}
  }

  type AllergyGetPayload<S extends boolean | null | undefined | AllergyDefaultArgs> = $Result.GetResult<Prisma.$AllergyPayload, S>

  type AllergyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AllergyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AllergyCountAggregateInputType | true
    }

  export interface AllergyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Allergy'], meta: { name: 'Allergy' } }
    /**
     * Find zero or one Allergy that matches the filter.
     * @param {AllergyFindUniqueArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllergyFindUniqueArgs>(args: SelectSubset<T, AllergyFindUniqueArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Allergy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AllergyFindUniqueOrThrowArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllergyFindUniqueOrThrowArgs>(args: SelectSubset<T, AllergyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Allergy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindFirstArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllergyFindFirstArgs>(args?: SelectSubset<T, AllergyFindFirstArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Allergy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindFirstOrThrowArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllergyFindFirstOrThrowArgs>(args?: SelectSubset<T, AllergyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Allergies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Allergies
     * const allergies = await prisma.allergy.findMany()
     * 
     * // Get first 10 Allergies
     * const allergies = await prisma.allergy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allergyWithIdOnly = await prisma.allergy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllergyFindManyArgs>(args?: SelectSubset<T, AllergyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Allergy.
     * @param {AllergyCreateArgs} args - Arguments to create a Allergy.
     * @example
     * // Create one Allergy
     * const Allergy = await prisma.allergy.create({
     *   data: {
     *     // ... data to create a Allergy
     *   }
     * })
     * 
     */
    create<T extends AllergyCreateArgs>(args: SelectSubset<T, AllergyCreateArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Allergies.
     * @param {AllergyCreateManyArgs} args - Arguments to create many Allergies.
     * @example
     * // Create many Allergies
     * const allergy = await prisma.allergy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllergyCreateManyArgs>(args?: SelectSubset<T, AllergyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Allergies and returns the data saved in the database.
     * @param {AllergyCreateManyAndReturnArgs} args - Arguments to create many Allergies.
     * @example
     * // Create many Allergies
     * const allergy = await prisma.allergy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Allergies and only return the `id`
     * const allergyWithIdOnly = await prisma.allergy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllergyCreateManyAndReturnArgs>(args?: SelectSubset<T, AllergyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Allergy.
     * @param {AllergyDeleteArgs} args - Arguments to delete one Allergy.
     * @example
     * // Delete one Allergy
     * const Allergy = await prisma.allergy.delete({
     *   where: {
     *     // ... filter to delete one Allergy
     *   }
     * })
     * 
     */
    delete<T extends AllergyDeleteArgs>(args: SelectSubset<T, AllergyDeleteArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Allergy.
     * @param {AllergyUpdateArgs} args - Arguments to update one Allergy.
     * @example
     * // Update one Allergy
     * const allergy = await prisma.allergy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllergyUpdateArgs>(args: SelectSubset<T, AllergyUpdateArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Allergies.
     * @param {AllergyDeleteManyArgs} args - Arguments to filter Allergies to delete.
     * @example
     * // Delete a few Allergies
     * const { count } = await prisma.allergy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllergyDeleteManyArgs>(args?: SelectSubset<T, AllergyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Allergies
     * const allergy = await prisma.allergy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllergyUpdateManyArgs>(args: SelectSubset<T, AllergyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergies and returns the data updated in the database.
     * @param {AllergyUpdateManyAndReturnArgs} args - Arguments to update many Allergies.
     * @example
     * // Update many Allergies
     * const allergy = await prisma.allergy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Allergies and only return the `id`
     * const allergyWithIdOnly = await prisma.allergy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AllergyUpdateManyAndReturnArgs>(args: SelectSubset<T, AllergyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Allergy.
     * @param {AllergyUpsertArgs} args - Arguments to update or create a Allergy.
     * @example
     * // Update or create a Allergy
     * const allergy = await prisma.allergy.upsert({
     *   create: {
     *     // ... data to create a Allergy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Allergy we want to update
     *   }
     * })
     */
    upsert<T extends AllergyUpsertArgs>(args: SelectSubset<T, AllergyUpsertArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Allergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyCountArgs} args - Arguments to filter Allergies to count.
     * @example
     * // Count the number of Allergies
     * const count = await prisma.allergy.count({
     *   where: {
     *     // ... the filter for the Allergies we want to count
     *   }
     * })
    **/
    count<T extends AllergyCountArgs>(
      args?: Subset<T, AllergyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllergyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Allergy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllergyAggregateArgs>(args: Subset<T, AllergyAggregateArgs>): Prisma.PrismaPromise<GetAllergyAggregateType<T>>

    /**
     * Group by Allergy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllergyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllergyGroupByArgs['orderBy'] }
        : { orderBy?: AllergyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllergyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllergyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Allergy model
   */
  readonly fields: AllergyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Allergy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllergyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Allergy model
   */
  interface AllergyFieldRefs {
    readonly id: FieldRef<"Allergy", 'String'>
    readonly allergen: FieldRef<"Allergy", 'String'>
    readonly type: FieldRef<"Allergy", 'String'>
    readonly severity: FieldRef<"Allergy", 'String'>
    readonly reaction: FieldRef<"Allergy", 'String'>
    readonly patientId: FieldRef<"Allergy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Allergy findUnique
   */
  export type AllergyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where: AllergyWhereUniqueInput
  }

  /**
   * Allergy findUniqueOrThrow
   */
  export type AllergyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where: AllergyWhereUniqueInput
  }

  /**
   * Allergy findFirst
   */
  export type AllergyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergies.
     */
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * Allergy findFirstOrThrow
   */
  export type AllergyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergies.
     */
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * Allergy findMany
   */
  export type AllergyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergies to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * Allergy create
   */
  export type AllergyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The data needed to create a Allergy.
     */
    data: XOR<AllergyCreateInput, AllergyUncheckedCreateInput>
  }

  /**
   * Allergy createMany
   */
  export type AllergyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Allergies.
     */
    data: AllergyCreateManyInput | AllergyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Allergy createManyAndReturn
   */
  export type AllergyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * The data used to create many Allergies.
     */
    data: AllergyCreateManyInput | AllergyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Allergy update
   */
  export type AllergyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The data needed to update a Allergy.
     */
    data: XOR<AllergyUpdateInput, AllergyUncheckedUpdateInput>
    /**
     * Choose, which Allergy to update.
     */
    where: AllergyWhereUniqueInput
  }

  /**
   * Allergy updateMany
   */
  export type AllergyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Allergies.
     */
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyInput>
    /**
     * Filter which Allergies to update
     */
    where?: AllergyWhereInput
    /**
     * Limit how many Allergies to update.
     */
    limit?: number
  }

  /**
   * Allergy updateManyAndReturn
   */
  export type AllergyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * The data used to update Allergies.
     */
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyInput>
    /**
     * Filter which Allergies to update
     */
    where?: AllergyWhereInput
    /**
     * Limit how many Allergies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Allergy upsert
   */
  export type AllergyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The filter to search for the Allergy to update in case it exists.
     */
    where: AllergyWhereUniqueInput
    /**
     * In case the Allergy found by the `where` argument doesn't exist, create a new Allergy with this data.
     */
    create: XOR<AllergyCreateInput, AllergyUncheckedCreateInput>
    /**
     * In case the Allergy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllergyUpdateInput, AllergyUncheckedUpdateInput>
  }

  /**
   * Allergy delete
   */
  export type AllergyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter which Allergy to delete.
     */
    where: AllergyWhereUniqueInput
  }

  /**
   * Allergy deleteMany
   */
  export type AllergyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergies to delete
     */
    where?: AllergyWhereInput
    /**
     * Limit how many Allergies to delete.
     */
    limit?: number
  }

  /**
   * Allergy without action
   */
  export type AllergyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
  }


  /**
   * Model Medication
   */

  export type AggregateMedication = {
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  export type MedicationMinAggregateOutputType = {
    id: string | null
    name: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    status: string | null
    prescriptionId: string | null
  }

  export type MedicationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    status: string | null
    prescriptionId: string | null
  }

  export type MedicationCountAggregateOutputType = {
    id: number
    name: number
    dosage: number
    frequency: number
    duration: number
    status: number
    prescriptionId: number
    _all: number
  }


  export type MedicationMinAggregateInputType = {
    id?: true
    name?: true
    dosage?: true
    frequency?: true
    duration?: true
    status?: true
    prescriptionId?: true
  }

  export type MedicationMaxAggregateInputType = {
    id?: true
    name?: true
    dosage?: true
    frequency?: true
    duration?: true
    status?: true
    prescriptionId?: true
  }

  export type MedicationCountAggregateInputType = {
    id?: true
    name?: true
    dosage?: true
    frequency?: true
    duration?: true
    status?: true
    prescriptionId?: true
    _all?: true
  }

  export type MedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medication to aggregate.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationMaxAggregateInputType
  }

  export type GetMedicationAggregateType<T extends MedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedication[P]>
      : GetScalarType<T[P], AggregateMedication[P]>
  }




  export type MedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithAggregationInput | MedicationOrderByWithAggregationInput[]
    by: MedicationScalarFieldEnum[] | MedicationScalarFieldEnum
    having?: MedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationCountAggregateInputType | true
    _min?: MedicationMinAggregateInputType
    _max?: MedicationMaxAggregateInputType
  }

  export type MedicationGroupByOutputType = {
    id: string
    name: string
    dosage: string
    frequency: string
    duration: string
    status: string
    prescriptionId: string | null
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  type GetMedicationGroupByPayload<T extends MedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    status?: boolean
    prescriptionId?: boolean
    prescription?: boolean | Medication$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    status?: boolean
    prescriptionId?: boolean
    prescription?: boolean | Medication$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    status?: boolean
    prescriptionId?: boolean
    prescription?: boolean | Medication$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectScalar = {
    id?: boolean
    name?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    status?: boolean
    prescriptionId?: boolean
  }

  export type MedicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "dosage" | "frequency" | "duration" | "status" | "prescriptionId", ExtArgs["result"]["medication"]>
  export type MedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | Medication$prescriptionArgs<ExtArgs>
  }
  export type MedicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | Medication$prescriptionArgs<ExtArgs>
  }
  export type MedicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | Medication$prescriptionArgs<ExtArgs>
  }

  export type $MedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medication"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      dosage: string
      frequency: string
      duration: string
      status: string
      prescriptionId: string | null
    }, ExtArgs["result"]["medication"]>
    composites: {}
  }

  type MedicationGetPayload<S extends boolean | null | undefined | MedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicationPayload, S>

  type MedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationCountAggregateInputType | true
    }

  export interface MedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medication'], meta: { name: 'Medication' } }
    /**
     * Find zero or one Medication that matches the filter.
     * @param {MedicationFindUniqueArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationFindUniqueArgs>(args: SelectSubset<T, MedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicationFindUniqueOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationFindFirstArgs>(args?: SelectSubset<T, MedicationFindFirstArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medication.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationWithIdOnly = await prisma.medication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationFindManyArgs>(args?: SelectSubset<T, MedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medication.
     * @param {MedicationCreateArgs} args - Arguments to create a Medication.
     * @example
     * // Create one Medication
     * const Medication = await prisma.medication.create({
     *   data: {
     *     // ... data to create a Medication
     *   }
     * })
     * 
     */
    create<T extends MedicationCreateArgs>(args: SelectSubset<T, MedicationCreateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medications.
     * @param {MedicationCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationCreateManyArgs>(args?: SelectSubset<T, MedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medications and returns the data saved in the database.
     * @param {MedicationCreateManyAndReturnArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medication.
     * @param {MedicationDeleteArgs} args - Arguments to delete one Medication.
     * @example
     * // Delete one Medication
     * const Medication = await prisma.medication.delete({
     *   where: {
     *     // ... filter to delete one Medication
     *   }
     * })
     * 
     */
    delete<T extends MedicationDeleteArgs>(args: SelectSubset<T, MedicationDeleteArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medication.
     * @param {MedicationUpdateArgs} args - Arguments to update one Medication.
     * @example
     * // Update one Medication
     * const medication = await prisma.medication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationUpdateArgs>(args: SelectSubset<T, MedicationUpdateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medications.
     * @param {MedicationDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationDeleteManyArgs>(args?: SelectSubset<T, MedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationUpdateManyArgs>(args: SelectSubset<T, MedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications and returns the data updated in the database.
     * @param {MedicationUpdateManyAndReturnArgs} args - Arguments to update many Medications.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicationUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medication.
     * @param {MedicationUpsertArgs} args - Arguments to update or create a Medication.
     * @example
     * // Update or create a Medication
     * const medication = await prisma.medication.upsert({
     *   create: {
     *     // ... data to create a Medication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medication we want to update
     *   }
     * })
     */
    upsert<T extends MedicationUpsertArgs>(args: SelectSubset<T, MedicationUpsertArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medication.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationCountArgs>(
      args?: Subset<T, MedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAggregateArgs>(args: Subset<T, MedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAggregateType<T>>

    /**
     * Group by Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medication model
   */
  readonly fields: MedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends Medication$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Medication$prescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medication model
   */
  interface MedicationFieldRefs {
    readonly id: FieldRef<"Medication", 'String'>
    readonly name: FieldRef<"Medication", 'String'>
    readonly dosage: FieldRef<"Medication", 'String'>
    readonly frequency: FieldRef<"Medication", 'String'>
    readonly duration: FieldRef<"Medication", 'String'>
    readonly status: FieldRef<"Medication", 'String'>
    readonly prescriptionId: FieldRef<"Medication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Medication findUnique
   */
  export type MedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findUniqueOrThrow
   */
  export type MedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findFirst
   */
  export type MedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findFirstOrThrow
   */
  export type MedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findMany
   */
  export type MedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication create
   */
  export type MedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Medication.
     */
    data: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
  }

  /**
   * Medication createMany
   */
  export type MedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medication createManyAndReturn
   */
  export type MedicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication update
   */
  export type MedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Medication.
     */
    data: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
    /**
     * Choose, which Medication to update.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication updateMany
   */
  export type MedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
  }

  /**
   * Medication updateManyAndReturn
   */
  export type MedicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication upsert
   */
  export type MedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Medication to update in case it exists.
     */
    where: MedicationWhereUniqueInput
    /**
     * In case the Medication found by the `where` argument doesn't exist, create a new Medication with this data.
     */
    create: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
    /**
     * In case the Medication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
  }

  /**
   * Medication delete
   */
  export type MedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter which Medication to delete.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication deleteMany
   */
  export type MedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to delete.
     */
    limit?: number
  }

  /**
   * Medication.prescription
   */
  export type Medication$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
  }

  /**
   * Medication without action
   */
  export type MedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
  }


  /**
   * Model LabResult
   */

  export type AggregateLabResult = {
    _count: LabResultCountAggregateOutputType | null
    _min: LabResultMinAggregateOutputType | null
    _max: LabResultMaxAggregateOutputType | null
  }

  export type LabResultMinAggregateOutputType = {
    id: string | null
    testName: string | null
    testDate: Date | null
    result: string | null
    referenceRange: string | null
    status: string | null
    patientId: string | null
    serviceProvideId: string | null
  }

  export type LabResultMaxAggregateOutputType = {
    id: string | null
    testName: string | null
    testDate: Date | null
    result: string | null
    referenceRange: string | null
    status: string | null
    patientId: string | null
    serviceProvideId: string | null
  }

  export type LabResultCountAggregateOutputType = {
    id: number
    testName: number
    testDate: number
    result: number
    referenceRange: number
    status: number
    patientId: number
    serviceProvideId: number
    _all: number
  }


  export type LabResultMinAggregateInputType = {
    id?: true
    testName?: true
    testDate?: true
    result?: true
    referenceRange?: true
    status?: true
    patientId?: true
    serviceProvideId?: true
  }

  export type LabResultMaxAggregateInputType = {
    id?: true
    testName?: true
    testDate?: true
    result?: true
    referenceRange?: true
    status?: true
    patientId?: true
    serviceProvideId?: true
  }

  export type LabResultCountAggregateInputType = {
    id?: true
    testName?: true
    testDate?: true
    result?: true
    referenceRange?: true
    status?: true
    patientId?: true
    serviceProvideId?: true
    _all?: true
  }

  export type LabResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabResult to aggregate.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabResults
    **/
    _count?: true | LabResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabResultMaxAggregateInputType
  }

  export type GetLabResultAggregateType<T extends LabResultAggregateArgs> = {
        [P in keyof T & keyof AggregateLabResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabResult[P]>
      : GetScalarType<T[P], AggregateLabResult[P]>
  }




  export type LabResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithAggregationInput | LabResultOrderByWithAggregationInput[]
    by: LabResultScalarFieldEnum[] | LabResultScalarFieldEnum
    having?: LabResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabResultCountAggregateInputType | true
    _min?: LabResultMinAggregateInputType
    _max?: LabResultMaxAggregateInputType
  }

  export type LabResultGroupByOutputType = {
    id: string
    testName: string
    testDate: Date
    result: string
    referenceRange: string
    status: string
    patientId: string
    serviceProvideId: string
    _count: LabResultCountAggregateOutputType | null
    _min: LabResultMinAggregateOutputType | null
    _max: LabResultMaxAggregateOutputType | null
  }

  type GetLabResultGroupByPayload<T extends LabResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabResultGroupByOutputType[P]>
            : GetScalarType<T[P], LabResultGroupByOutputType[P]>
        }
      >
    >


  export type LabResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testName?: boolean
    testDate?: boolean
    result?: boolean
    referenceRange?: boolean
    status?: boolean
    patientId?: boolean
    serviceProvideId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testName?: boolean
    testDate?: boolean
    result?: boolean
    referenceRange?: boolean
    status?: boolean
    patientId?: boolean
    serviceProvideId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testName?: boolean
    testDate?: boolean
    result?: boolean
    referenceRange?: boolean
    status?: boolean
    patientId?: boolean
    serviceProvideId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectScalar = {
    id?: boolean
    testName?: boolean
    testDate?: boolean
    result?: boolean
    referenceRange?: boolean
    status?: boolean
    patientId?: boolean
    serviceProvideId?: boolean
  }

  export type LabResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testName" | "testDate" | "result" | "referenceRange" | "status" | "patientId" | "serviceProvideId", ExtArgs["result"]["labResult"]>
  export type LabResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type LabResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type LabResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $LabResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabResult"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testName: string
      testDate: Date
      result: string
      referenceRange: string
      status: string
      patientId: string
      serviceProvideId: string
    }, ExtArgs["result"]["labResult"]>
    composites: {}
  }

  type LabResultGetPayload<S extends boolean | null | undefined | LabResultDefaultArgs> = $Result.GetResult<Prisma.$LabResultPayload, S>

  type LabResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabResultCountAggregateInputType | true
    }

  export interface LabResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabResult'], meta: { name: 'LabResult' } }
    /**
     * Find zero or one LabResult that matches the filter.
     * @param {LabResultFindUniqueArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabResultFindUniqueArgs>(args: SelectSubset<T, LabResultFindUniqueArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabResultFindUniqueOrThrowArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabResultFindUniqueOrThrowArgs>(args: SelectSubset<T, LabResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindFirstArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabResultFindFirstArgs>(args?: SelectSubset<T, LabResultFindFirstArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindFirstOrThrowArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabResultFindFirstOrThrowArgs>(args?: SelectSubset<T, LabResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabResults
     * const labResults = await prisma.labResult.findMany()
     * 
     * // Get first 10 LabResults
     * const labResults = await prisma.labResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labResultWithIdOnly = await prisma.labResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabResultFindManyArgs>(args?: SelectSubset<T, LabResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabResult.
     * @param {LabResultCreateArgs} args - Arguments to create a LabResult.
     * @example
     * // Create one LabResult
     * const LabResult = await prisma.labResult.create({
     *   data: {
     *     // ... data to create a LabResult
     *   }
     * })
     * 
     */
    create<T extends LabResultCreateArgs>(args: SelectSubset<T, LabResultCreateArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabResults.
     * @param {LabResultCreateManyArgs} args - Arguments to create many LabResults.
     * @example
     * // Create many LabResults
     * const labResult = await prisma.labResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabResultCreateManyArgs>(args?: SelectSubset<T, LabResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabResults and returns the data saved in the database.
     * @param {LabResultCreateManyAndReturnArgs} args - Arguments to create many LabResults.
     * @example
     * // Create many LabResults
     * const labResult = await prisma.labResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabResults and only return the `id`
     * const labResultWithIdOnly = await prisma.labResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabResultCreateManyAndReturnArgs>(args?: SelectSubset<T, LabResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabResult.
     * @param {LabResultDeleteArgs} args - Arguments to delete one LabResult.
     * @example
     * // Delete one LabResult
     * const LabResult = await prisma.labResult.delete({
     *   where: {
     *     // ... filter to delete one LabResult
     *   }
     * })
     * 
     */
    delete<T extends LabResultDeleteArgs>(args: SelectSubset<T, LabResultDeleteArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabResult.
     * @param {LabResultUpdateArgs} args - Arguments to update one LabResult.
     * @example
     * // Update one LabResult
     * const labResult = await prisma.labResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabResultUpdateArgs>(args: SelectSubset<T, LabResultUpdateArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabResults.
     * @param {LabResultDeleteManyArgs} args - Arguments to filter LabResults to delete.
     * @example
     * // Delete a few LabResults
     * const { count } = await prisma.labResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabResultDeleteManyArgs>(args?: SelectSubset<T, LabResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabResults
     * const labResult = await prisma.labResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabResultUpdateManyArgs>(args: SelectSubset<T, LabResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabResults and returns the data updated in the database.
     * @param {LabResultUpdateManyAndReturnArgs} args - Arguments to update many LabResults.
     * @example
     * // Update many LabResults
     * const labResult = await prisma.labResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabResults and only return the `id`
     * const labResultWithIdOnly = await prisma.labResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabResultUpdateManyAndReturnArgs>(args: SelectSubset<T, LabResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabResult.
     * @param {LabResultUpsertArgs} args - Arguments to update or create a LabResult.
     * @example
     * // Update or create a LabResult
     * const labResult = await prisma.labResult.upsert({
     *   create: {
     *     // ... data to create a LabResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabResult we want to update
     *   }
     * })
     */
    upsert<T extends LabResultUpsertArgs>(args: SelectSubset<T, LabResultUpsertArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultCountArgs} args - Arguments to filter LabResults to count.
     * @example
     * // Count the number of LabResults
     * const count = await prisma.labResult.count({
     *   where: {
     *     // ... the filter for the LabResults we want to count
     *   }
     * })
    **/
    count<T extends LabResultCountArgs>(
      args?: Subset<T, LabResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabResultAggregateArgs>(args: Subset<T, LabResultAggregateArgs>): Prisma.PrismaPromise<GetLabResultAggregateType<T>>

    /**
     * Group by LabResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabResultGroupByArgs['orderBy'] }
        : { orderBy?: LabResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabResult model
   */
  readonly fields: LabResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabResult model
   */
  interface LabResultFieldRefs {
    readonly id: FieldRef<"LabResult", 'String'>
    readonly testName: FieldRef<"LabResult", 'String'>
    readonly testDate: FieldRef<"LabResult", 'DateTime'>
    readonly result: FieldRef<"LabResult", 'String'>
    readonly referenceRange: FieldRef<"LabResult", 'String'>
    readonly status: FieldRef<"LabResult", 'String'>
    readonly patientId: FieldRef<"LabResult", 'String'>
    readonly serviceProvideId: FieldRef<"LabResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabResult findUnique
   */
  export type LabResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult findUniqueOrThrow
   */
  export type LabResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult findFirst
   */
  export type LabResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabResults.
     */
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult findFirstOrThrow
   */
  export type LabResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabResults.
     */
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult findMany
   */
  export type LabResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResults to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult create
   */
  export type LabResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The data needed to create a LabResult.
     */
    data: XOR<LabResultCreateInput, LabResultUncheckedCreateInput>
  }

  /**
   * LabResult createMany
   */
  export type LabResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabResults.
     */
    data: LabResultCreateManyInput | LabResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabResult createManyAndReturn
   */
  export type LabResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * The data used to create many LabResults.
     */
    data: LabResultCreateManyInput | LabResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabResult update
   */
  export type LabResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The data needed to update a LabResult.
     */
    data: XOR<LabResultUpdateInput, LabResultUncheckedUpdateInput>
    /**
     * Choose, which LabResult to update.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult updateMany
   */
  export type LabResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabResults.
     */
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyInput>
    /**
     * Filter which LabResults to update
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to update.
     */
    limit?: number
  }

  /**
   * LabResult updateManyAndReturn
   */
  export type LabResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * The data used to update LabResults.
     */
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyInput>
    /**
     * Filter which LabResults to update
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabResult upsert
   */
  export type LabResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The filter to search for the LabResult to update in case it exists.
     */
    where: LabResultWhereUniqueInput
    /**
     * In case the LabResult found by the `where` argument doesn't exist, create a new LabResult with this data.
     */
    create: XOR<LabResultCreateInput, LabResultUncheckedCreateInput>
    /**
     * In case the LabResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabResultUpdateInput, LabResultUncheckedUpdateInput>
  }

  /**
   * LabResult delete
   */
  export type LabResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter which LabResult to delete.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult deleteMany
   */
  export type LabResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabResults to delete
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to delete.
     */
    limit?: number
  }

  /**
   * LabResult without action
   */
  export type LabResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
  }


  /**
   * Model MedicalRecord
   */

  export type AggregateMedicalRecord = {
    _count: MedicalRecordCountAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  export type MedicalRecordMinAggregateOutputType = {
    id: string | null
    diagnosis: string | null
    prescription: string | null
    notes: string | null
    userId: string | null
    description: string | null
    recordId: string | null
    attachment: string | null
    serviceProviderId: string | null
  }

  export type MedicalRecordMaxAggregateOutputType = {
    id: string | null
    diagnosis: string | null
    prescription: string | null
    notes: string | null
    userId: string | null
    description: string | null
    recordId: string | null
    attachment: string | null
    serviceProviderId: string | null
  }

  export type MedicalRecordCountAggregateOutputType = {
    id: number
    diagnosis: number
    prescription: number
    notes: number
    userId: number
    description: number
    recordId: number
    attachment: number
    serviceProviderId: number
    _all: number
  }


  export type MedicalRecordMinAggregateInputType = {
    id?: true
    diagnosis?: true
    prescription?: true
    notes?: true
    userId?: true
    description?: true
    recordId?: true
    attachment?: true
    serviceProviderId?: true
  }

  export type MedicalRecordMaxAggregateInputType = {
    id?: true
    diagnosis?: true
    prescription?: true
    notes?: true
    userId?: true
    description?: true
    recordId?: true
    attachment?: true
    serviceProviderId?: true
  }

  export type MedicalRecordCountAggregateInputType = {
    id?: true
    diagnosis?: true
    prescription?: true
    notes?: true
    userId?: true
    description?: true
    recordId?: true
    attachment?: true
    serviceProviderId?: true
    _all?: true
  }

  export type MedicalRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecord to aggregate.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalRecords
    **/
    _count?: true | MedicalRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type GetMedicalRecordAggregateType<T extends MedicalRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalRecord[P]>
      : GetScalarType<T[P], AggregateMedicalRecord[P]>
  }




  export type MedicalRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithAggregationInput | MedicalRecordOrderByWithAggregationInput[]
    by: MedicalRecordScalarFieldEnum[] | MedicalRecordScalarFieldEnum
    having?: MedicalRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalRecordCountAggregateInputType | true
    _min?: MedicalRecordMinAggregateInputType
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type MedicalRecordGroupByOutputType = {
    id: string
    diagnosis: string
    prescription: string
    notes: string | null
    userId: string
    description: string | null
    recordId: string | null
    attachment: string | null
    serviceProviderId: string | null
    _count: MedicalRecordCountAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  type GetMedicalRecordGroupByPayload<T extends MedicalRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
        }
      >
    >


  export type MedicalRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnosis?: boolean
    prescription?: boolean
    notes?: boolean
    userId?: boolean
    description?: boolean
    recordId?: boolean
    attachment?: boolean
    serviceProviderId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | MedicalRecord$serviceProviderArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnosis?: boolean
    prescription?: boolean
    notes?: boolean
    userId?: boolean
    description?: boolean
    recordId?: boolean
    attachment?: boolean
    serviceProviderId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | MedicalRecord$serviceProviderArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnosis?: boolean
    prescription?: boolean
    notes?: boolean
    userId?: boolean
    description?: boolean
    recordId?: boolean
    attachment?: boolean
    serviceProviderId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | MedicalRecord$serviceProviderArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectScalar = {
    id?: boolean
    diagnosis?: boolean
    prescription?: boolean
    notes?: boolean
    userId?: boolean
    description?: boolean
    recordId?: boolean
    attachment?: boolean
    serviceProviderId?: boolean
  }

  export type MedicalRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "diagnosis" | "prescription" | "notes" | "userId" | "description" | "recordId" | "attachment" | "serviceProviderId", ExtArgs["result"]["medicalRecord"]>
  export type MedicalRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | MedicalRecord$serviceProviderArgs<ExtArgs>
  }
  export type MedicalRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | MedicalRecord$serviceProviderArgs<ExtArgs>
  }
  export type MedicalRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | MedicalRecord$serviceProviderArgs<ExtArgs>
  }

  export type $MedicalRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      diagnosis: string
      prescription: string
      notes: string | null
      userId: string
      description: string | null
      recordId: string | null
      attachment: string | null
      serviceProviderId: string | null
    }, ExtArgs["result"]["medicalRecord"]>
    composites: {}
  }

  type MedicalRecordGetPayload<S extends boolean | null | undefined | MedicalRecordDefaultArgs> = $Result.GetResult<Prisma.$MedicalRecordPayload, S>

  type MedicalRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalRecordCountAggregateInputType | true
    }

  export interface MedicalRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalRecord'], meta: { name: 'MedicalRecord' } }
    /**
     * Find zero or one MedicalRecord that matches the filter.
     * @param {MedicalRecordFindUniqueArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalRecordFindUniqueArgs>(args: SelectSubset<T, MedicalRecordFindUniqueArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalRecordFindUniqueOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalRecordFindFirstArgs>(args?: SelectSubset<T, MedicalRecordFindFirstArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany()
     * 
     * // Get first 10 MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalRecordFindManyArgs>(args?: SelectSubset<T, MedicalRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalRecord.
     * @param {MedicalRecordCreateArgs} args - Arguments to create a MedicalRecord.
     * @example
     * // Create one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.create({
     *   data: {
     *     // ... data to create a MedicalRecord
     *   }
     * })
     * 
     */
    create<T extends MedicalRecordCreateArgs>(args: SelectSubset<T, MedicalRecordCreateArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalRecords.
     * @param {MedicalRecordCreateManyArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalRecordCreateManyArgs>(args?: SelectSubset<T, MedicalRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalRecords and returns the data saved in the database.
     * @param {MedicalRecordCreateManyAndReturnArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalRecords and only return the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalRecord.
     * @param {MedicalRecordDeleteArgs} args - Arguments to delete one MedicalRecord.
     * @example
     * // Delete one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.delete({
     *   where: {
     *     // ... filter to delete one MedicalRecord
     *   }
     * })
     * 
     */
    delete<T extends MedicalRecordDeleteArgs>(args: SelectSubset<T, MedicalRecordDeleteArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalRecord.
     * @param {MedicalRecordUpdateArgs} args - Arguments to update one MedicalRecord.
     * @example
     * // Update one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalRecordUpdateArgs>(args: SelectSubset<T, MedicalRecordUpdateArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalRecords.
     * @param {MedicalRecordDeleteManyArgs} args - Arguments to filter MedicalRecords to delete.
     * @example
     * // Delete a few MedicalRecords
     * const { count } = await prisma.medicalRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalRecordDeleteManyArgs>(args?: SelectSubset<T, MedicalRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalRecordUpdateManyArgs>(args: SelectSubset<T, MedicalRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords and returns the data updated in the database.
     * @param {MedicalRecordUpdateManyAndReturnArgs} args - Arguments to update many MedicalRecords.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalRecords and only return the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalRecord.
     * @param {MedicalRecordUpsertArgs} args - Arguments to update or create a MedicalRecord.
     * @example
     * // Update or create a MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.upsert({
     *   create: {
     *     // ... data to create a MedicalRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalRecord we want to update
     *   }
     * })
     */
    upsert<T extends MedicalRecordUpsertArgs>(args: SelectSubset<T, MedicalRecordUpsertArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordCountArgs} args - Arguments to filter MedicalRecords to count.
     * @example
     * // Count the number of MedicalRecords
     * const count = await prisma.medicalRecord.count({
     *   where: {
     *     // ... the filter for the MedicalRecords we want to count
     *   }
     * })
    **/
    count<T extends MedicalRecordCountArgs>(
      args?: Subset<T, MedicalRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalRecordAggregateArgs>(args: Subset<T, MedicalRecordAggregateArgs>): Prisma.PrismaPromise<GetMedicalRecordAggregateType<T>>

    /**
     * Group by MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalRecordGroupByArgs['orderBy'] }
        : { orderBy?: MedicalRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalRecord model
   */
  readonly fields: MedicalRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends MedicalRecord$serviceProviderArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecord$serviceProviderArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalRecord model
   */
  interface MedicalRecordFieldRefs {
    readonly id: FieldRef<"MedicalRecord", 'String'>
    readonly diagnosis: FieldRef<"MedicalRecord", 'String'>
    readonly prescription: FieldRef<"MedicalRecord", 'String'>
    readonly notes: FieldRef<"MedicalRecord", 'String'>
    readonly userId: FieldRef<"MedicalRecord", 'String'>
    readonly description: FieldRef<"MedicalRecord", 'String'>
    readonly recordId: FieldRef<"MedicalRecord", 'String'>
    readonly attachment: FieldRef<"MedicalRecord", 'String'>
    readonly serviceProviderId: FieldRef<"MedicalRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MedicalRecord findUnique
   */
  export type MedicalRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findUniqueOrThrow
   */
  export type MedicalRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findFirst
   */
  export type MedicalRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord findFirstOrThrow
   */
  export type MedicalRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord findMany
   */
  export type MedicalRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord create
   */
  export type MedicalRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalRecord.
     */
    data: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
  }

  /**
   * MedicalRecord createMany
   */
  export type MedicalRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordCreateManyInput | MedicalRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalRecord createManyAndReturn
   */
  export type MedicalRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordCreateManyInput | MedicalRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecord update
   */
  export type MedicalRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalRecord.
     */
    data: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
    /**
     * Choose, which MedicalRecord to update.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord updateMany
   */
  export type MedicalRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
  }

  /**
   * MedicalRecord updateManyAndReturn
   */
  export type MedicalRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecord upsert
   */
  export type MedicalRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalRecord to update in case it exists.
     */
    where: MedicalRecordWhereUniqueInput
    /**
     * In case the MedicalRecord found by the `where` argument doesn't exist, create a new MedicalRecord with this data.
     */
    create: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
    /**
     * In case the MedicalRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
  }

  /**
   * MedicalRecord delete
   */
  export type MedicalRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter which MedicalRecord to delete.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord deleteMany
   */
  export type MedicalRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecords to delete
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to delete.
     */
    limit?: number
  }

  /**
   * MedicalRecord.serviceProvider
   */
  export type MedicalRecord$serviceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    where?: ServiceProviderWhereInput
  }

  /**
   * MedicalRecord without action
   */
  export type MedicalRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    notes: string | null
    dateIssued: Date | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    notes: string | null
    dateIssued: Date | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    notes: number
    dateIssued: number
    _all: number
  }


  export type PrescriptionMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    notes?: true
    dateIssued?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    notes?: true
    dateIssued?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    notes?: true
    dateIssued?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: string
    patientId: string
    doctorId: string
    notes: string | null
    dateIssued: Date
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    notes?: boolean
    dateIssued?: boolean
    medications?: boolean | Prescription$medicationsArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    notes?: boolean
    dateIssued?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    notes?: boolean
    dateIssued?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    notes?: boolean
    dateIssued?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "notes" | "dateIssued", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medications?: boolean | Prescription$medicationsArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      medications: Prisma.$MedicationPayload<ExtArgs>[]
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$DoctorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      doctorId: string
      notes: string | null
      dateIssued: Date
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medications<T extends Prescription$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'String'>
    readonly patientId: FieldRef<"Prescription", 'String'>
    readonly doctorId: FieldRef<"Prescription", 'String'>
    readonly notes: FieldRef<"Prescription", 'String'>
    readonly dateIssued: FieldRef<"Prescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to delete.
     */
    limit?: number
  }

  /**
   * Prescription.medications
   */
  export type Prescription$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    cursor?: MedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model TherapyPlan
   */

  export type AggregateTherapyPlan = {
    _count: TherapyPlanCountAggregateOutputType | null
    _min: TherapyPlanMinAggregateOutputType | null
    _max: TherapyPlanMaxAggregateOutputType | null
  }

  export type TherapyPlanMinAggregateOutputType = {
    id: string | null
    planName: string | null
    date: Date | null
    type: string | null
    status: string | null
    details: string | null
    patientId: string | null
    serviceProvideId: string | null
  }

  export type TherapyPlanMaxAggregateOutputType = {
    id: string | null
    planName: string | null
    date: Date | null
    type: string | null
    status: string | null
    details: string | null
    patientId: string | null
    serviceProvideId: string | null
  }

  export type TherapyPlanCountAggregateOutputType = {
    id: number
    planName: number
    date: number
    type: number
    status: number
    details: number
    patientId: number
    serviceProvideId: number
    _all: number
  }


  export type TherapyPlanMinAggregateInputType = {
    id?: true
    planName?: true
    date?: true
    type?: true
    status?: true
    details?: true
    patientId?: true
    serviceProvideId?: true
  }

  export type TherapyPlanMaxAggregateInputType = {
    id?: true
    planName?: true
    date?: true
    type?: true
    status?: true
    details?: true
    patientId?: true
    serviceProvideId?: true
  }

  export type TherapyPlanCountAggregateInputType = {
    id?: true
    planName?: true
    date?: true
    type?: true
    status?: true
    details?: true
    patientId?: true
    serviceProvideId?: true
    _all?: true
  }

  export type TherapyPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TherapyPlan to aggregate.
     */
    where?: TherapyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TherapyPlans to fetch.
     */
    orderBy?: TherapyPlanOrderByWithRelationInput | TherapyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TherapyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TherapyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TherapyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TherapyPlans
    **/
    _count?: true | TherapyPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TherapyPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TherapyPlanMaxAggregateInputType
  }

  export type GetTherapyPlanAggregateType<T extends TherapyPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTherapyPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTherapyPlan[P]>
      : GetScalarType<T[P], AggregateTherapyPlan[P]>
  }




  export type TherapyPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TherapyPlanWhereInput
    orderBy?: TherapyPlanOrderByWithAggregationInput | TherapyPlanOrderByWithAggregationInput[]
    by: TherapyPlanScalarFieldEnum[] | TherapyPlanScalarFieldEnum
    having?: TherapyPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TherapyPlanCountAggregateInputType | true
    _min?: TherapyPlanMinAggregateInputType
    _max?: TherapyPlanMaxAggregateInputType
  }

  export type TherapyPlanGroupByOutputType = {
    id: string
    planName: string
    date: Date
    type: string
    status: string
    details: string
    patientId: string
    serviceProvideId: string
    _count: TherapyPlanCountAggregateOutputType | null
    _min: TherapyPlanMinAggregateOutputType | null
    _max: TherapyPlanMaxAggregateOutputType | null
  }

  type GetTherapyPlanGroupByPayload<T extends TherapyPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TherapyPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TherapyPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TherapyPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TherapyPlanGroupByOutputType[P]>
        }
      >
    >


  export type TherapyPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planName?: boolean
    date?: boolean
    type?: boolean
    status?: boolean
    details?: boolean
    patientId?: boolean
    serviceProvideId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["therapyPlan"]>

  export type TherapyPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planName?: boolean
    date?: boolean
    type?: boolean
    status?: boolean
    details?: boolean
    patientId?: boolean
    serviceProvideId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["therapyPlan"]>

  export type TherapyPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planName?: boolean
    date?: boolean
    type?: boolean
    status?: boolean
    details?: boolean
    patientId?: boolean
    serviceProvideId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["therapyPlan"]>

  export type TherapyPlanSelectScalar = {
    id?: boolean
    planName?: boolean
    date?: boolean
    type?: boolean
    status?: boolean
    details?: boolean
    patientId?: boolean
    serviceProvideId?: boolean
  }

  export type TherapyPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planName" | "date" | "type" | "status" | "details" | "patientId" | "serviceProvideId", ExtArgs["result"]["therapyPlan"]>
  export type TherapyPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type TherapyPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type TherapyPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $TherapyPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TherapyPlan"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planName: string
      date: Date
      type: string
      status: string
      details: string
      patientId: string
      serviceProvideId: string
    }, ExtArgs["result"]["therapyPlan"]>
    composites: {}
  }

  type TherapyPlanGetPayload<S extends boolean | null | undefined | TherapyPlanDefaultArgs> = $Result.GetResult<Prisma.$TherapyPlanPayload, S>

  type TherapyPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TherapyPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TherapyPlanCountAggregateInputType | true
    }

  export interface TherapyPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TherapyPlan'], meta: { name: 'TherapyPlan' } }
    /**
     * Find zero or one TherapyPlan that matches the filter.
     * @param {TherapyPlanFindUniqueArgs} args - Arguments to find a TherapyPlan
     * @example
     * // Get one TherapyPlan
     * const therapyPlan = await prisma.therapyPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TherapyPlanFindUniqueArgs>(args: SelectSubset<T, TherapyPlanFindUniqueArgs<ExtArgs>>): Prisma__TherapyPlanClient<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TherapyPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TherapyPlanFindUniqueOrThrowArgs} args - Arguments to find a TherapyPlan
     * @example
     * // Get one TherapyPlan
     * const therapyPlan = await prisma.therapyPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TherapyPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TherapyPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TherapyPlanClient<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TherapyPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TherapyPlanFindFirstArgs} args - Arguments to find a TherapyPlan
     * @example
     * // Get one TherapyPlan
     * const therapyPlan = await prisma.therapyPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TherapyPlanFindFirstArgs>(args?: SelectSubset<T, TherapyPlanFindFirstArgs<ExtArgs>>): Prisma__TherapyPlanClient<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TherapyPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TherapyPlanFindFirstOrThrowArgs} args - Arguments to find a TherapyPlan
     * @example
     * // Get one TherapyPlan
     * const therapyPlan = await prisma.therapyPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TherapyPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TherapyPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TherapyPlanClient<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TherapyPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TherapyPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TherapyPlans
     * const therapyPlans = await prisma.therapyPlan.findMany()
     * 
     * // Get first 10 TherapyPlans
     * const therapyPlans = await prisma.therapyPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const therapyPlanWithIdOnly = await prisma.therapyPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TherapyPlanFindManyArgs>(args?: SelectSubset<T, TherapyPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TherapyPlan.
     * @param {TherapyPlanCreateArgs} args - Arguments to create a TherapyPlan.
     * @example
     * // Create one TherapyPlan
     * const TherapyPlan = await prisma.therapyPlan.create({
     *   data: {
     *     // ... data to create a TherapyPlan
     *   }
     * })
     * 
     */
    create<T extends TherapyPlanCreateArgs>(args: SelectSubset<T, TherapyPlanCreateArgs<ExtArgs>>): Prisma__TherapyPlanClient<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TherapyPlans.
     * @param {TherapyPlanCreateManyArgs} args - Arguments to create many TherapyPlans.
     * @example
     * // Create many TherapyPlans
     * const therapyPlan = await prisma.therapyPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TherapyPlanCreateManyArgs>(args?: SelectSubset<T, TherapyPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TherapyPlans and returns the data saved in the database.
     * @param {TherapyPlanCreateManyAndReturnArgs} args - Arguments to create many TherapyPlans.
     * @example
     * // Create many TherapyPlans
     * const therapyPlan = await prisma.therapyPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TherapyPlans and only return the `id`
     * const therapyPlanWithIdOnly = await prisma.therapyPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TherapyPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TherapyPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TherapyPlan.
     * @param {TherapyPlanDeleteArgs} args - Arguments to delete one TherapyPlan.
     * @example
     * // Delete one TherapyPlan
     * const TherapyPlan = await prisma.therapyPlan.delete({
     *   where: {
     *     // ... filter to delete one TherapyPlan
     *   }
     * })
     * 
     */
    delete<T extends TherapyPlanDeleteArgs>(args: SelectSubset<T, TherapyPlanDeleteArgs<ExtArgs>>): Prisma__TherapyPlanClient<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TherapyPlan.
     * @param {TherapyPlanUpdateArgs} args - Arguments to update one TherapyPlan.
     * @example
     * // Update one TherapyPlan
     * const therapyPlan = await prisma.therapyPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TherapyPlanUpdateArgs>(args: SelectSubset<T, TherapyPlanUpdateArgs<ExtArgs>>): Prisma__TherapyPlanClient<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TherapyPlans.
     * @param {TherapyPlanDeleteManyArgs} args - Arguments to filter TherapyPlans to delete.
     * @example
     * // Delete a few TherapyPlans
     * const { count } = await prisma.therapyPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TherapyPlanDeleteManyArgs>(args?: SelectSubset<T, TherapyPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TherapyPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TherapyPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TherapyPlans
     * const therapyPlan = await prisma.therapyPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TherapyPlanUpdateManyArgs>(args: SelectSubset<T, TherapyPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TherapyPlans and returns the data updated in the database.
     * @param {TherapyPlanUpdateManyAndReturnArgs} args - Arguments to update many TherapyPlans.
     * @example
     * // Update many TherapyPlans
     * const therapyPlan = await prisma.therapyPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TherapyPlans and only return the `id`
     * const therapyPlanWithIdOnly = await prisma.therapyPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TherapyPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, TherapyPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TherapyPlan.
     * @param {TherapyPlanUpsertArgs} args - Arguments to update or create a TherapyPlan.
     * @example
     * // Update or create a TherapyPlan
     * const therapyPlan = await prisma.therapyPlan.upsert({
     *   create: {
     *     // ... data to create a TherapyPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TherapyPlan we want to update
     *   }
     * })
     */
    upsert<T extends TherapyPlanUpsertArgs>(args: SelectSubset<T, TherapyPlanUpsertArgs<ExtArgs>>): Prisma__TherapyPlanClient<$Result.GetResult<Prisma.$TherapyPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TherapyPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TherapyPlanCountArgs} args - Arguments to filter TherapyPlans to count.
     * @example
     * // Count the number of TherapyPlans
     * const count = await prisma.therapyPlan.count({
     *   where: {
     *     // ... the filter for the TherapyPlans we want to count
     *   }
     * })
    **/
    count<T extends TherapyPlanCountArgs>(
      args?: Subset<T, TherapyPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TherapyPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TherapyPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TherapyPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TherapyPlanAggregateArgs>(args: Subset<T, TherapyPlanAggregateArgs>): Prisma.PrismaPromise<GetTherapyPlanAggregateType<T>>

    /**
     * Group by TherapyPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TherapyPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TherapyPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TherapyPlanGroupByArgs['orderBy'] }
        : { orderBy?: TherapyPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TherapyPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTherapyPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TherapyPlan model
   */
  readonly fields: TherapyPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TherapyPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TherapyPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TherapyPlan model
   */
  interface TherapyPlanFieldRefs {
    readonly id: FieldRef<"TherapyPlan", 'String'>
    readonly planName: FieldRef<"TherapyPlan", 'String'>
    readonly date: FieldRef<"TherapyPlan", 'DateTime'>
    readonly type: FieldRef<"TherapyPlan", 'String'>
    readonly status: FieldRef<"TherapyPlan", 'String'>
    readonly details: FieldRef<"TherapyPlan", 'String'>
    readonly patientId: FieldRef<"TherapyPlan", 'String'>
    readonly serviceProvideId: FieldRef<"TherapyPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TherapyPlan findUnique
   */
  export type TherapyPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * Filter, which TherapyPlan to fetch.
     */
    where: TherapyPlanWhereUniqueInput
  }

  /**
   * TherapyPlan findUniqueOrThrow
   */
  export type TherapyPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * Filter, which TherapyPlan to fetch.
     */
    where: TherapyPlanWhereUniqueInput
  }

  /**
   * TherapyPlan findFirst
   */
  export type TherapyPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * Filter, which TherapyPlan to fetch.
     */
    where?: TherapyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TherapyPlans to fetch.
     */
    orderBy?: TherapyPlanOrderByWithRelationInput | TherapyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TherapyPlans.
     */
    cursor?: TherapyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TherapyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TherapyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TherapyPlans.
     */
    distinct?: TherapyPlanScalarFieldEnum | TherapyPlanScalarFieldEnum[]
  }

  /**
   * TherapyPlan findFirstOrThrow
   */
  export type TherapyPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * Filter, which TherapyPlan to fetch.
     */
    where?: TherapyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TherapyPlans to fetch.
     */
    orderBy?: TherapyPlanOrderByWithRelationInput | TherapyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TherapyPlans.
     */
    cursor?: TherapyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TherapyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TherapyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TherapyPlans.
     */
    distinct?: TherapyPlanScalarFieldEnum | TherapyPlanScalarFieldEnum[]
  }

  /**
   * TherapyPlan findMany
   */
  export type TherapyPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * Filter, which TherapyPlans to fetch.
     */
    where?: TherapyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TherapyPlans to fetch.
     */
    orderBy?: TherapyPlanOrderByWithRelationInput | TherapyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TherapyPlans.
     */
    cursor?: TherapyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TherapyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TherapyPlans.
     */
    skip?: number
    distinct?: TherapyPlanScalarFieldEnum | TherapyPlanScalarFieldEnum[]
  }

  /**
   * TherapyPlan create
   */
  export type TherapyPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TherapyPlan.
     */
    data: XOR<TherapyPlanCreateInput, TherapyPlanUncheckedCreateInput>
  }

  /**
   * TherapyPlan createMany
   */
  export type TherapyPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TherapyPlans.
     */
    data: TherapyPlanCreateManyInput | TherapyPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TherapyPlan createManyAndReturn
   */
  export type TherapyPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * The data used to create many TherapyPlans.
     */
    data: TherapyPlanCreateManyInput | TherapyPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TherapyPlan update
   */
  export type TherapyPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TherapyPlan.
     */
    data: XOR<TherapyPlanUpdateInput, TherapyPlanUncheckedUpdateInput>
    /**
     * Choose, which TherapyPlan to update.
     */
    where: TherapyPlanWhereUniqueInput
  }

  /**
   * TherapyPlan updateMany
   */
  export type TherapyPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TherapyPlans.
     */
    data: XOR<TherapyPlanUpdateManyMutationInput, TherapyPlanUncheckedUpdateManyInput>
    /**
     * Filter which TherapyPlans to update
     */
    where?: TherapyPlanWhereInput
    /**
     * Limit how many TherapyPlans to update.
     */
    limit?: number
  }

  /**
   * TherapyPlan updateManyAndReturn
   */
  export type TherapyPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * The data used to update TherapyPlans.
     */
    data: XOR<TherapyPlanUpdateManyMutationInput, TherapyPlanUncheckedUpdateManyInput>
    /**
     * Filter which TherapyPlans to update
     */
    where?: TherapyPlanWhereInput
    /**
     * Limit how many TherapyPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TherapyPlan upsert
   */
  export type TherapyPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TherapyPlan to update in case it exists.
     */
    where: TherapyPlanWhereUniqueInput
    /**
     * In case the TherapyPlan found by the `where` argument doesn't exist, create a new TherapyPlan with this data.
     */
    create: XOR<TherapyPlanCreateInput, TherapyPlanUncheckedCreateInput>
    /**
     * In case the TherapyPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TherapyPlanUpdateInput, TherapyPlanUncheckedUpdateInput>
  }

  /**
   * TherapyPlan delete
   */
  export type TherapyPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
    /**
     * Filter which TherapyPlan to delete.
     */
    where: TherapyPlanWhereUniqueInput
  }

  /**
   * TherapyPlan deleteMany
   */
  export type TherapyPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TherapyPlans to delete
     */
    where?: TherapyPlanWhereInput
    /**
     * Limit how many TherapyPlans to delete.
     */
    limit?: number
  }

  /**
   * TherapyPlan without action
   */
  export type TherapyPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TherapyPlan
     */
    select?: TherapyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TherapyPlan
     */
    omit?: TherapyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TherapyPlanInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    amount: number | null
    status: $Enums.Status | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    refundDetails: string | null
    userId: string | null
    appointmentId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    amount: number | null
    status: $Enums.Status | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    refundDetails: string | null
    userId: string | null
    appointmentId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    transactionId: number
    amount: number
    status: number
    paymentMethod: number
    paymentDate: number
    refundDetails: number
    userId: number
    appointmentId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    refundDetails?: true
    userId?: true
    appointmentId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    refundDetails?: true
    userId?: true
    appointmentId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    refundDetails?: true
    userId?: true
    appointmentId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date
    refundDetails: string | null
    userId: string
    appointmentId: string
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    refundDetails?: boolean
    userId?: boolean
    appointmentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    refundDetails?: boolean
    userId?: boolean
    appointmentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    refundDetails?: boolean
    userId?: boolean
    appointmentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    refundDetails?: boolean
    userId?: boolean
    appointmentId?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "amount" | "status" | "paymentMethod" | "paymentDate" | "refundDetails" | "userId" | "appointmentId", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      amount: number
      status: $Enums.Status
      paymentMethod: $Enums.PaymentMethod
      paymentDate: Date
      refundDetails: string | null
      userId: string
      appointmentId: string
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends Payment$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly status: FieldRef<"Payment", 'Status'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly refundDetails: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly appointmentId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.transaction
   */
  export type Payment$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    gatewayTransactionId: string | null
    amount: number | null
    status: $Enums.Status | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
    refundDetails: string | null
    paymentId: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    gatewayTransactionId: string | null
    amount: number | null
    status: $Enums.Status | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
    refundDetails: string | null
    paymentId: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    gatewayTransactionId: number
    amount: number
    status: number
    paymentMethod: number
    createdAt: number
    updatedAt: number
    refundDetails: number
    paymentId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    gatewayTransactionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    refundDetails?: true
    paymentId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    gatewayTransactionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    refundDetails?: true
    paymentId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    gatewayTransactionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    refundDetails?: true
    paymentId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    gatewayTransactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    createdAt: Date
    updatedAt: Date
    refundDetails: string | null
    paymentId: string
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gatewayTransactionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundDetails?: boolean
    paymentId?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gatewayTransactionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundDetails?: boolean
    paymentId?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gatewayTransactionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundDetails?: boolean
    paymentId?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    gatewayTransactionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundDetails?: boolean
    paymentId?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gatewayTransactionId" | "amount" | "status" | "paymentMethod" | "createdAt" | "updatedAt" | "refundDetails" | "paymentId", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gatewayTransactionId: string
      amount: number
      status: $Enums.Status
      paymentMethod: $Enums.PaymentMethod
      createdAt: Date
      updatedAt: Date
      refundDetails: string | null
      paymentId: string
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly gatewayTransactionId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly status: FieldRef<"Transaction", 'Status'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly refundDetails: FieldRef<"Transaction", 'String'>
    readonly paymentId: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    score: number | null
  }

  export type RatingSumAggregateOutputType = {
    score: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceProviderType: $Enums.ProviderType | null
    serviceProviderId: string | null
    score: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceProviderType: $Enums.ProviderType | null
    serviceProviderId: string | null
    score: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    userId: number
    serviceProviderType: number
    serviceProviderId: number
    score: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    score?: true
  }

  export type RatingSumAggregateInputType = {
    score?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    userId?: true
    serviceProviderType?: true
    serviceProviderId?: true
    score?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceProviderType?: true
    serviceProviderId?: true
    score?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    userId?: true
    serviceProviderType?: true
    serviceProviderId?: true
    score?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: string
    userId: string
    serviceProviderType: $Enums.ProviderType
    serviceProviderId: string
    score: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceProviderType?: boolean
    serviceProviderId?: boolean
    score?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceProviderType?: boolean
    serviceProviderId?: boolean
    score?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceProviderType?: boolean
    serviceProviderId?: boolean
    score?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceProviderType?: boolean
    serviceProviderId?: boolean
    score?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "serviceProviderType" | "serviceProviderId" | "score" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["rating"]>
  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceProviderType: $Enums.ProviderType
      serviceProviderId: string
      score: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingFindUniqueArgs>(args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingFindFirstArgs>(args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingFindManyArgs>(args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends RatingCreateArgs>(args: SelectSubset<T, RatingCreateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingCreateManyArgs>(args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ratings and returns the data saved in the database.
     * @param {RatingCreateManyAndReturnArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatingCreateManyAndReturnArgs>(args?: SelectSubset<T, RatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends RatingDeleteArgs>(args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingUpdateArgs>(args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingDeleteManyArgs>(args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingUpdateManyArgs>(args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings and returns the data updated in the database.
     * @param {RatingUpdateManyAndReturnArgs} args - Arguments to update many Ratings.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RatingUpdateManyAndReturnArgs>(args: SelectSubset<T, RatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends RatingUpsertArgs>(args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rating model
   */
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'String'>
    readonly userId: FieldRef<"Rating", 'String'>
    readonly serviceProviderType: FieldRef<"Rating", 'ProviderType'>
    readonly serviceProviderId: FieldRef<"Rating", 'String'>
    readonly score: FieldRef<"Rating", 'Float'>
    readonly comment: FieldRef<"Rating", 'String'>
    readonly createdAt: FieldRef<"Rating", 'DateTime'>
    readonly updatedAt: FieldRef<"Rating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }

  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating createManyAndReturn
   */
  export type RatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
  }

  /**
   * Rating updateManyAndReturn
   */
  export type RatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }

  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to delete.
     */
    limit?: number
  }

  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
  }


  /**
   * Model RequestPermission
   */

  export type AggregateRequestPermission = {
    _count: RequestPermissionCountAggregateOutputType | null
    _min: RequestPermissionMinAggregateOutputType | null
    _max: RequestPermissionMaxAggregateOutputType | null
  }

  export type RequestPermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    accessType: $Enums.PermissionType | null
    doctorsAssistantId: string | null
  }

  export type RequestPermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    accessType: $Enums.PermissionType | null
    doctorsAssistantId: string | null
  }

  export type RequestPermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    accessType: number
    doctorsAssistantId: number
    _all: number
  }


  export type RequestPermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    accessType?: true
    doctorsAssistantId?: true
  }

  export type RequestPermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    accessType?: true
    doctorsAssistantId?: true
  }

  export type RequestPermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    accessType?: true
    doctorsAssistantId?: true
    _all?: true
  }

  export type RequestPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestPermission to aggregate.
     */
    where?: RequestPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPermissions to fetch.
     */
    orderBy?: RequestPermissionOrderByWithRelationInput | RequestPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestPermissions
    **/
    _count?: true | RequestPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestPermissionMaxAggregateInputType
  }

  export type GetRequestPermissionAggregateType<T extends RequestPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestPermission[P]>
      : GetScalarType<T[P], AggregateRequestPermission[P]>
  }




  export type RequestPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestPermissionWhereInput
    orderBy?: RequestPermissionOrderByWithAggregationInput | RequestPermissionOrderByWithAggregationInput[]
    by: RequestPermissionScalarFieldEnum[] | RequestPermissionScalarFieldEnum
    having?: RequestPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestPermissionCountAggregateInputType | true
    _min?: RequestPermissionMinAggregateInputType
    _max?: RequestPermissionMaxAggregateInputType
  }

  export type RequestPermissionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    accessType: $Enums.PermissionType
    doctorsAssistantId: string | null
    _count: RequestPermissionCountAggregateOutputType | null
    _min: RequestPermissionMinAggregateOutputType | null
    _max: RequestPermissionMaxAggregateOutputType | null
  }

  type GetRequestPermissionGroupByPayload<T extends RequestPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RequestPermissionGroupByOutputType[P]>
        }
      >
    >


  export type RequestPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    accessType?: boolean
    doctorsAssistantId?: boolean
    requests?: boolean | RequestPermission$requestsArgs<ExtArgs>
    doctorsAssistant?: boolean | RequestPermission$doctorsAssistantArgs<ExtArgs>
    _count?: boolean | RequestPermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestPermission"]>

  export type RequestPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    accessType?: boolean
    doctorsAssistantId?: boolean
    doctorsAssistant?: boolean | RequestPermission$doctorsAssistantArgs<ExtArgs>
  }, ExtArgs["result"]["requestPermission"]>

  export type RequestPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    accessType?: boolean
    doctorsAssistantId?: boolean
    doctorsAssistant?: boolean | RequestPermission$doctorsAssistantArgs<ExtArgs>
  }, ExtArgs["result"]["requestPermission"]>

  export type RequestPermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    accessType?: boolean
    doctorsAssistantId?: boolean
  }

  export type RequestPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "accessType" | "doctorsAssistantId", ExtArgs["result"]["requestPermission"]>
  export type RequestPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requests?: boolean | RequestPermission$requestsArgs<ExtArgs>
    doctorsAssistant?: boolean | RequestPermission$doctorsAssistantArgs<ExtArgs>
    _count?: boolean | RequestPermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctorsAssistant?: boolean | RequestPermission$doctorsAssistantArgs<ExtArgs>
  }
  export type RequestPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctorsAssistant?: boolean | RequestPermission$doctorsAssistantArgs<ExtArgs>
  }

  export type $RequestPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestPermission"
    objects: {
      requests: Prisma.$RequestPayload<ExtArgs>[]
      doctorsAssistant: Prisma.$DoctorsAssistantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      accessType: $Enums.PermissionType
      doctorsAssistantId: string | null
    }, ExtArgs["result"]["requestPermission"]>
    composites: {}
  }

  type RequestPermissionGetPayload<S extends boolean | null | undefined | RequestPermissionDefaultArgs> = $Result.GetResult<Prisma.$RequestPermissionPayload, S>

  type RequestPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestPermissionCountAggregateInputType | true
    }

  export interface RequestPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestPermission'], meta: { name: 'RequestPermission' } }
    /**
     * Find zero or one RequestPermission that matches the filter.
     * @param {RequestPermissionFindUniqueArgs} args - Arguments to find a RequestPermission
     * @example
     * // Get one RequestPermission
     * const requestPermission = await prisma.requestPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestPermissionFindUniqueArgs>(args: SelectSubset<T, RequestPermissionFindUniqueArgs<ExtArgs>>): Prisma__RequestPermissionClient<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestPermissionFindUniqueOrThrowArgs} args - Arguments to find a RequestPermission
     * @example
     * // Get one RequestPermission
     * const requestPermission = await prisma.requestPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestPermissionClient<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPermissionFindFirstArgs} args - Arguments to find a RequestPermission
     * @example
     * // Get one RequestPermission
     * const requestPermission = await prisma.requestPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestPermissionFindFirstArgs>(args?: SelectSubset<T, RequestPermissionFindFirstArgs<ExtArgs>>): Prisma__RequestPermissionClient<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPermissionFindFirstOrThrowArgs} args - Arguments to find a RequestPermission
     * @example
     * // Get one RequestPermission
     * const requestPermission = await prisma.requestPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestPermissionClient<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestPermissions
     * const requestPermissions = await prisma.requestPermission.findMany()
     * 
     * // Get first 10 RequestPermissions
     * const requestPermissions = await prisma.requestPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestPermissionWithIdOnly = await prisma.requestPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestPermissionFindManyArgs>(args?: SelectSubset<T, RequestPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestPermission.
     * @param {RequestPermissionCreateArgs} args - Arguments to create a RequestPermission.
     * @example
     * // Create one RequestPermission
     * const RequestPermission = await prisma.requestPermission.create({
     *   data: {
     *     // ... data to create a RequestPermission
     *   }
     * })
     * 
     */
    create<T extends RequestPermissionCreateArgs>(args: SelectSubset<T, RequestPermissionCreateArgs<ExtArgs>>): Prisma__RequestPermissionClient<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestPermissions.
     * @param {RequestPermissionCreateManyArgs} args - Arguments to create many RequestPermissions.
     * @example
     * // Create many RequestPermissions
     * const requestPermission = await prisma.requestPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestPermissionCreateManyArgs>(args?: SelectSubset<T, RequestPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestPermissions and returns the data saved in the database.
     * @param {RequestPermissionCreateManyAndReturnArgs} args - Arguments to create many RequestPermissions.
     * @example
     * // Create many RequestPermissions
     * const requestPermission = await prisma.requestPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestPermissions and only return the `id`
     * const requestPermissionWithIdOnly = await prisma.requestPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestPermission.
     * @param {RequestPermissionDeleteArgs} args - Arguments to delete one RequestPermission.
     * @example
     * // Delete one RequestPermission
     * const RequestPermission = await prisma.requestPermission.delete({
     *   where: {
     *     // ... filter to delete one RequestPermission
     *   }
     * })
     * 
     */
    delete<T extends RequestPermissionDeleteArgs>(args: SelectSubset<T, RequestPermissionDeleteArgs<ExtArgs>>): Prisma__RequestPermissionClient<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestPermission.
     * @param {RequestPermissionUpdateArgs} args - Arguments to update one RequestPermission.
     * @example
     * // Update one RequestPermission
     * const requestPermission = await prisma.requestPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestPermissionUpdateArgs>(args: SelectSubset<T, RequestPermissionUpdateArgs<ExtArgs>>): Prisma__RequestPermissionClient<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestPermissions.
     * @param {RequestPermissionDeleteManyArgs} args - Arguments to filter RequestPermissions to delete.
     * @example
     * // Delete a few RequestPermissions
     * const { count } = await prisma.requestPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestPermissionDeleteManyArgs>(args?: SelectSubset<T, RequestPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestPermissions
     * const requestPermission = await prisma.requestPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestPermissionUpdateManyArgs>(args: SelectSubset<T, RequestPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestPermissions and returns the data updated in the database.
     * @param {RequestPermissionUpdateManyAndReturnArgs} args - Arguments to update many RequestPermissions.
     * @example
     * // Update many RequestPermissions
     * const requestPermission = await prisma.requestPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestPermissions and only return the `id`
     * const requestPermissionWithIdOnly = await prisma.requestPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestPermission.
     * @param {RequestPermissionUpsertArgs} args - Arguments to update or create a RequestPermission.
     * @example
     * // Update or create a RequestPermission
     * const requestPermission = await prisma.requestPermission.upsert({
     *   create: {
     *     // ... data to create a RequestPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestPermission we want to update
     *   }
     * })
     */
    upsert<T extends RequestPermissionUpsertArgs>(args: SelectSubset<T, RequestPermissionUpsertArgs<ExtArgs>>): Prisma__RequestPermissionClient<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPermissionCountArgs} args - Arguments to filter RequestPermissions to count.
     * @example
     * // Count the number of RequestPermissions
     * const count = await prisma.requestPermission.count({
     *   where: {
     *     // ... the filter for the RequestPermissions we want to count
     *   }
     * })
    **/
    count<T extends RequestPermissionCountArgs>(
      args?: Subset<T, RequestPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestPermissionAggregateArgs>(args: Subset<T, RequestPermissionAggregateArgs>): Prisma.PrismaPromise<GetRequestPermissionAggregateType<T>>

    /**
     * Group by RequestPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestPermissionGroupByArgs['orderBy'] }
        : { orderBy?: RequestPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestPermission model
   */
  readonly fields: RequestPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requests<T extends RequestPermission$requestsArgs<ExtArgs> = {}>(args?: Subset<T, RequestPermission$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctorsAssistant<T extends RequestPermission$doctorsAssistantArgs<ExtArgs> = {}>(args?: Subset<T, RequestPermission$doctorsAssistantArgs<ExtArgs>>): Prisma__DoctorsAssistantClient<$Result.GetResult<Prisma.$DoctorsAssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestPermission model
   */
  interface RequestPermissionFieldRefs {
    readonly id: FieldRef<"RequestPermission", 'String'>
    readonly name: FieldRef<"RequestPermission", 'String'>
    readonly description: FieldRef<"RequestPermission", 'String'>
    readonly accessType: FieldRef<"RequestPermission", 'PermissionType'>
    readonly doctorsAssistantId: FieldRef<"RequestPermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RequestPermission findUnique
   */
  export type RequestPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RequestPermission to fetch.
     */
    where: RequestPermissionWhereUniqueInput
  }

  /**
   * RequestPermission findUniqueOrThrow
   */
  export type RequestPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RequestPermission to fetch.
     */
    where: RequestPermissionWhereUniqueInput
  }

  /**
   * RequestPermission findFirst
   */
  export type RequestPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RequestPermission to fetch.
     */
    where?: RequestPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPermissions to fetch.
     */
    orderBy?: RequestPermissionOrderByWithRelationInput | RequestPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestPermissions.
     */
    cursor?: RequestPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestPermissions.
     */
    distinct?: RequestPermissionScalarFieldEnum | RequestPermissionScalarFieldEnum[]
  }

  /**
   * RequestPermission findFirstOrThrow
   */
  export type RequestPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RequestPermission to fetch.
     */
    where?: RequestPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPermissions to fetch.
     */
    orderBy?: RequestPermissionOrderByWithRelationInput | RequestPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestPermissions.
     */
    cursor?: RequestPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestPermissions.
     */
    distinct?: RequestPermissionScalarFieldEnum | RequestPermissionScalarFieldEnum[]
  }

  /**
   * RequestPermission findMany
   */
  export type RequestPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RequestPermissions to fetch.
     */
    where?: RequestPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPermissions to fetch.
     */
    orderBy?: RequestPermissionOrderByWithRelationInput | RequestPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestPermissions.
     */
    cursor?: RequestPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPermissions.
     */
    skip?: number
    distinct?: RequestPermissionScalarFieldEnum | RequestPermissionScalarFieldEnum[]
  }

  /**
   * RequestPermission create
   */
  export type RequestPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestPermission.
     */
    data: XOR<RequestPermissionCreateInput, RequestPermissionUncheckedCreateInput>
  }

  /**
   * RequestPermission createMany
   */
  export type RequestPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestPermissions.
     */
    data: RequestPermissionCreateManyInput | RequestPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestPermission createManyAndReturn
   */
  export type RequestPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RequestPermissions.
     */
    data: RequestPermissionCreateManyInput | RequestPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestPermission update
   */
  export type RequestPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestPermission.
     */
    data: XOR<RequestPermissionUpdateInput, RequestPermissionUncheckedUpdateInput>
    /**
     * Choose, which RequestPermission to update.
     */
    where: RequestPermissionWhereUniqueInput
  }

  /**
   * RequestPermission updateMany
   */
  export type RequestPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestPermissions.
     */
    data: XOR<RequestPermissionUpdateManyMutationInput, RequestPermissionUncheckedUpdateManyInput>
    /**
     * Filter which RequestPermissions to update
     */
    where?: RequestPermissionWhereInput
    /**
     * Limit how many RequestPermissions to update.
     */
    limit?: number
  }

  /**
   * RequestPermission updateManyAndReturn
   */
  export type RequestPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * The data used to update RequestPermissions.
     */
    data: XOR<RequestPermissionUpdateManyMutationInput, RequestPermissionUncheckedUpdateManyInput>
    /**
     * Filter which RequestPermissions to update
     */
    where?: RequestPermissionWhereInput
    /**
     * Limit how many RequestPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestPermission upsert
   */
  export type RequestPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestPermission to update in case it exists.
     */
    where: RequestPermissionWhereUniqueInput
    /**
     * In case the RequestPermission found by the `where` argument doesn't exist, create a new RequestPermission with this data.
     */
    create: XOR<RequestPermissionCreateInput, RequestPermissionUncheckedCreateInput>
    /**
     * In case the RequestPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestPermissionUpdateInput, RequestPermissionUncheckedUpdateInput>
  }

  /**
   * RequestPermission delete
   */
  export type RequestPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    /**
     * Filter which RequestPermission to delete.
     */
    where: RequestPermissionWhereUniqueInput
  }

  /**
   * RequestPermission deleteMany
   */
  export type RequestPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestPermissions to delete
     */
    where?: RequestPermissionWhereInput
    /**
     * Limit how many RequestPermissions to delete.
     */
    limit?: number
  }

  /**
   * RequestPermission.requests
   */
  export type RequestPermission$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * RequestPermission.doctorsAssistant
   */
  export type RequestPermission$doctorsAssistantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsAssistant
     */
    select?: DoctorsAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorsAssistant
     */
    omit?: DoctorsAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsAssistantInclude<ExtArgs> | null
    where?: DoctorsAssistantWhereInput
  }

  /**
   * RequestPermission without action
   */
  export type RequestPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
  }


  /**
   * Model Request
   */

  export type AggregateRequest = {
    _count: RequestCountAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  export type RequestMinAggregateOutputType = {
    id: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    doctorId: string | null
  }

  export type RequestMaxAggregateOutputType = {
    id: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    doctorId: string | null
  }

  export type RequestCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    doctorId: number
    _all: number
  }


  export type RequestMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    doctorId?: true
  }

  export type RequestMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    doctorId?: true
  }

  export type RequestCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    doctorId?: true
    _all?: true
  }

  export type RequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Request to aggregate.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requests
    **/
    _count?: true | RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestMaxAggregateInputType
  }

  export type GetRequestAggregateType<T extends RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest[P]>
      : GetScalarType<T[P], AggregateRequest[P]>
  }




  export type RequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithAggregationInput | RequestOrderByWithAggregationInput[]
    by: RequestScalarFieldEnum[] | RequestScalarFieldEnum
    having?: RequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCountAggregateInputType | true
    _min?: RequestMinAggregateInputType
    _max?: RequestMaxAggregateInputType
  }

  export type RequestGroupByOutputType = {
    id: string
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    doctorId: string | null
    _count: RequestCountAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  type GetRequestGroupByPayload<T extends RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestGroupByOutputType[P]>
            : GetScalarType<T[P], RequestGroupByOutputType[P]>
        }
      >
    >


  export type RequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorId?: boolean
    requestPermissions?: boolean | Request$requestPermissionsArgs<ExtArgs>
    doctor?: boolean | Request$doctorArgs<ExtArgs>
    _count?: boolean | RequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorId?: boolean
    doctor?: boolean | Request$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorId?: boolean
    doctor?: boolean | Request$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorId?: boolean
  }

  export type RequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "createdAt" | "updatedAt" | "doctorId", ExtArgs["result"]["request"]>
  export type RequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestPermissions?: boolean | Request$requestPermissionsArgs<ExtArgs>
    doctor?: boolean | Request$doctorArgs<ExtArgs>
    _count?: boolean | RequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | Request$doctorArgs<ExtArgs>
  }
  export type RequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | Request$doctorArgs<ExtArgs>
  }

  export type $RequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Request"
    objects: {
      requestPermissions: Prisma.$RequestPermissionPayload<ExtArgs>[]
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      doctorId: string | null
    }, ExtArgs["result"]["request"]>
    composites: {}
  }

  type RequestGetPayload<S extends boolean | null | undefined | RequestDefaultArgs> = $Result.GetResult<Prisma.$RequestPayload, S>

  type RequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestCountAggregateInputType | true
    }

  export interface RequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Request'], meta: { name: 'Request' } }
    /**
     * Find zero or one Request that matches the filter.
     * @param {RequestFindUniqueArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestFindUniqueArgs>(args: SelectSubset<T, RequestFindUniqueArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Request that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestFindUniqueOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestFindFirstArgs>(args?: SelectSubset<T, RequestFindFirstArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.request.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestWithIdOnly = await prisma.request.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestFindManyArgs>(args?: SelectSubset<T, RequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Request.
     * @param {RequestCreateArgs} args - Arguments to create a Request.
     * @example
     * // Create one Request
     * const Request = await prisma.request.create({
     *   data: {
     *     // ... data to create a Request
     *   }
     * })
     * 
     */
    create<T extends RequestCreateArgs>(args: SelectSubset<T, RequestCreateArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requests.
     * @param {RequestCreateManyArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const request = await prisma.request.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestCreateManyArgs>(args?: SelectSubset<T, RequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requests and returns the data saved in the database.
     * @param {RequestCreateManyAndReturnArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const request = await prisma.request.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requests and only return the `id`
     * const requestWithIdOnly = await prisma.request.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Request.
     * @param {RequestDeleteArgs} args - Arguments to delete one Request.
     * @example
     * // Delete one Request
     * const Request = await prisma.request.delete({
     *   where: {
     *     // ... filter to delete one Request
     *   }
     * })
     * 
     */
    delete<T extends RequestDeleteArgs>(args: SelectSubset<T, RequestDeleteArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Request.
     * @param {RequestUpdateArgs} args - Arguments to update one Request.
     * @example
     * // Update one Request
     * const request = await prisma.request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestUpdateArgs>(args: SelectSubset<T, RequestUpdateArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requests.
     * @param {RequestDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestDeleteManyArgs>(args?: SelectSubset<T, RequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestUpdateManyArgs>(args: SelectSubset<T, RequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests and returns the data updated in the database.
     * @param {RequestUpdateManyAndReturnArgs} args - Arguments to update many Requests.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requests and only return the `id`
     * const requestWithIdOnly = await prisma.request.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Request.
     * @param {RequestUpsertArgs} args - Arguments to update or create a Request.
     * @example
     * // Update or create a Request
     * const request = await prisma.request.upsert({
     *   create: {
     *     // ... data to create a Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request we want to update
     *   }
     * })
     */
    upsert<T extends RequestUpsertArgs>(args: SelectSubset<T, RequestUpsertArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.request.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends RequestCountArgs>(
      args?: Subset<T, RequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAggregateArgs>(args: Subset<T, RequestAggregateArgs>): Prisma.PrismaPromise<GetRequestAggregateType<T>>

    /**
     * Group by Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestGroupByArgs['orderBy'] }
        : { orderBy?: RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Request model
   */
  readonly fields: RequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requestPermissions<T extends Request$requestPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Request$requestPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctor<T extends Request$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Request$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Request model
   */
  interface RequestFieldRefs {
    readonly id: FieldRef<"Request", 'String'>
    readonly status: FieldRef<"Request", 'Status'>
    readonly createdAt: FieldRef<"Request", 'DateTime'>
    readonly updatedAt: FieldRef<"Request", 'DateTime'>
    readonly doctorId: FieldRef<"Request", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Request findUnique
   */
  export type RequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findUniqueOrThrow
   */
  export type RequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findFirst
   */
  export type RequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request findFirstOrThrow
   */
  export type RequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request findMany
   */
  export type RequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request create
   */
  export type RequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to create a Request.
     */
    data: XOR<RequestCreateInput, RequestUncheckedCreateInput>
  }

  /**
   * Request createMany
   */
  export type RequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Request createManyAndReturn
   */
  export type RequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Request update
   */
  export type RequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to update a Request.
     */
    data: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
    /**
     * Choose, which Request to update.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request updateMany
   */
  export type RequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to update.
     */
    limit?: number
  }

  /**
   * Request updateManyAndReturn
   */
  export type RequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Request upsert
   */
  export type RequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The filter to search for the Request to update in case it exists.
     */
    where: RequestWhereUniqueInput
    /**
     * In case the Request found by the `where` argument doesn't exist, create a new Request with this data.
     */
    create: XOR<RequestCreateInput, RequestUncheckedCreateInput>
    /**
     * In case the Request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
  }

  /**
   * Request delete
   */
  export type RequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter which Request to delete.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request deleteMany
   */
  export type RequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requests to delete
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to delete.
     */
    limit?: number
  }

  /**
   * Request.requestPermissions
   */
  export type Request$requestPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestPermission
     */
    select?: RequestPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestPermission
     */
    omit?: RequestPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestPermissionInclude<ExtArgs> | null
    where?: RequestPermissionWhereInput
    orderBy?: RequestPermissionOrderByWithRelationInput | RequestPermissionOrderByWithRelationInput[]
    cursor?: RequestPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestPermissionScalarFieldEnum | RequestPermissionScalarFieldEnum[]
  }

  /**
   * Request.doctor
   */
  export type Request$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * Request without action
   */
  export type RequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    status: $Enums.Status | null
    appointmentTime: Date | null
    bookedAt: Date | null
    reason: string | null
    isForOthers: boolean | null
    slotId: string | null
    userId: string | null
    serviceProviderId: string | null
    patientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    status: $Enums.Status | null
    appointmentTime: Date | null
    bookedAt: Date | null
    reason: string | null
    isForOthers: boolean | null
    slotId: string | null
    userId: string | null
    serviceProviderId: string | null
    patientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    service: number
    status: number
    appointmentTime: number
    bookedAt: number
    reason: number
    isForOthers: number
    slotId: number
    userId: number
    serviceProviderId: number
    patientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    status?: true
    appointmentTime?: true
    bookedAt?: true
    reason?: true
    isForOthers?: true
    slotId?: true
    userId?: true
    serviceProviderId?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    status?: true
    appointmentTime?: true
    bookedAt?: true
    reason?: true
    isForOthers?: true
    slotId?: true
    userId?: true
    serviceProviderId?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    service?: true
    status?: true
    appointmentTime?: true
    bookedAt?: true
    reason?: true
    isForOthers?: true
    slotId?: true
    userId?: true
    serviceProviderId?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    service: $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date
    bookedAt: Date
    reason: string | null
    isForOthers: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    patientId: string
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    status?: boolean
    appointmentTime?: boolean
    bookedAt?: boolean
    reason?: boolean
    isForOthers?: boolean
    slotId?: boolean
    userId?: boolean
    serviceProviderId?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    othersAppointment?: boolean | Appointment$othersAppointmentArgs<ExtArgs>
    currentLocation?: boolean | Appointment$currentLocationArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    payment?: boolean | Appointment$paymentArgs<ExtArgs>
    tags?: boolean | Appointment$tagsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    status?: boolean
    appointmentTime?: boolean
    bookedAt?: boolean
    reason?: boolean
    isForOthers?: boolean
    slotId?: boolean
    userId?: boolean
    serviceProviderId?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    status?: boolean
    appointmentTime?: boolean
    bookedAt?: boolean
    reason?: boolean
    isForOthers?: boolean
    slotId?: boolean
    userId?: boolean
    serviceProviderId?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    service?: boolean
    status?: boolean
    appointmentTime?: boolean
    bookedAt?: boolean
    reason?: boolean
    isForOthers?: boolean
    slotId?: boolean
    userId?: boolean
    serviceProviderId?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service" | "status" | "appointmentTime" | "bookedAt" | "reason" | "isForOthers" | "slotId" | "userId" | "serviceProviderId" | "patientId" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    othersAppointment?: boolean | Appointment$othersAppointmentArgs<ExtArgs>
    currentLocation?: boolean | Appointment$currentLocationArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    payment?: boolean | Appointment$paymentArgs<ExtArgs>
    tags?: boolean | Appointment$tagsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      othersAppointment: Prisma.$OthersAppointmentPayload<ExtArgs> | null
      currentLocation: Prisma.$CurrentLocationPayload<ExtArgs> | null
      slot: Prisma.$SlotPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service: $Enums.Service[]
      status: $Enums.Status
      appointmentTime: Date
      bookedAt: Date
      reason: string | null
      isForOthers: boolean
      slotId: string
      userId: string
      serviceProviderId: string
      patientId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    othersAppointment<T extends Appointment$othersAppointmentArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$othersAppointmentArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currentLocation<T extends Appointment$currentLocationArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$currentLocationArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    slot<T extends SlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SlotDefaultArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends Appointment$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Appointment$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly service: FieldRef<"Appointment", 'Service[]'>
    readonly status: FieldRef<"Appointment", 'Status'>
    readonly appointmentTime: FieldRef<"Appointment", 'DateTime'>
    readonly bookedAt: FieldRef<"Appointment", 'DateTime'>
    readonly reason: FieldRef<"Appointment", 'String'>
    readonly isForOthers: FieldRef<"Appointment", 'Boolean'>
    readonly slotId: FieldRef<"Appointment", 'String'>
    readonly userId: FieldRef<"Appointment", 'String'>
    readonly serviceProviderId: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.othersAppointment
   */
  export type Appointment$othersAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    where?: OthersAppointmentWhereInput
  }

  /**
   * Appointment.currentLocation
   */
  export type Appointment$currentLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    where?: CurrentLocationWhereInput
  }

  /**
   * Appointment.payment
   */
  export type Appointment$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Appointment.tags
   */
  export type Appointment$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model OthersAppointment
   */

  export type AggregateOthersAppointment = {
    _count: OthersAppointmentCountAggregateOutputType | null
    _avg: OthersAppointmentAvgAggregateOutputType | null
    _sum: OthersAppointmentSumAggregateOutputType | null
    _min: OthersAppointmentMinAggregateOutputType | null
    _max: OthersAppointmentMaxAggregateOutputType | null
  }

  export type OthersAppointmentAvgAggregateOutputType = {
    age: number | null
  }

  export type OthersAppointmentSumAggregateOutputType = {
    age: number | null
  }

  export type OthersAppointmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    email: string | null
    relationship: string | null
    age: number | null
    gender: $Enums.Gender | null
    reason: string | null
    appointmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OthersAppointmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    email: string | null
    relationship: string | null
    age: number | null
    gender: $Enums.Gender | null
    reason: string | null
    appointmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OthersAppointmentCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    email: number
    relationship: number
    age: number
    gender: number
    reason: number
    appointmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OthersAppointmentAvgAggregateInputType = {
    age?: true
  }

  export type OthersAppointmentSumAggregateInputType = {
    age?: true
  }

  export type OthersAppointmentMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    relationship?: true
    age?: true
    gender?: true
    reason?: true
    appointmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OthersAppointmentMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    relationship?: true
    age?: true
    gender?: true
    reason?: true
    appointmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OthersAppointmentCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    relationship?: true
    age?: true
    gender?: true
    reason?: true
    appointmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OthersAppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OthersAppointment to aggregate.
     */
    where?: OthersAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OthersAppointments to fetch.
     */
    orderBy?: OthersAppointmentOrderByWithRelationInput | OthersAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OthersAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OthersAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OthersAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OthersAppointments
    **/
    _count?: true | OthersAppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OthersAppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OthersAppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OthersAppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OthersAppointmentMaxAggregateInputType
  }

  export type GetOthersAppointmentAggregateType<T extends OthersAppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateOthersAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOthersAppointment[P]>
      : GetScalarType<T[P], AggregateOthersAppointment[P]>
  }




  export type OthersAppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OthersAppointmentWhereInput
    orderBy?: OthersAppointmentOrderByWithAggregationInput | OthersAppointmentOrderByWithAggregationInput[]
    by: OthersAppointmentScalarFieldEnum[] | OthersAppointmentScalarFieldEnum
    having?: OthersAppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OthersAppointmentCountAggregateInputType | true
    _avg?: OthersAppointmentAvgAggregateInputType
    _sum?: OthersAppointmentSumAggregateInputType
    _min?: OthersAppointmentMinAggregateInputType
    _max?: OthersAppointmentMaxAggregateInputType
  }

  export type OthersAppointmentGroupByOutputType = {
    id: string
    name: string
    contact: string
    email: string | null
    relationship: string
    age: number
    gender: $Enums.Gender
    reason: string | null
    appointmentId: string
    createdAt: Date
    updatedAt: Date
    _count: OthersAppointmentCountAggregateOutputType | null
    _avg: OthersAppointmentAvgAggregateOutputType | null
    _sum: OthersAppointmentSumAggregateOutputType | null
    _min: OthersAppointmentMinAggregateOutputType | null
    _max: OthersAppointmentMaxAggregateOutputType | null
  }

  type GetOthersAppointmentGroupByPayload<T extends OthersAppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OthersAppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OthersAppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OthersAppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], OthersAppointmentGroupByOutputType[P]>
        }
      >
    >


  export type OthersAppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    relationship?: boolean
    age?: boolean
    gender?: boolean
    reason?: boolean
    appointmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["othersAppointment"]>

  export type OthersAppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    relationship?: boolean
    age?: boolean
    gender?: boolean
    reason?: boolean
    appointmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["othersAppointment"]>

  export type OthersAppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    relationship?: boolean
    age?: boolean
    gender?: boolean
    reason?: boolean
    appointmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["othersAppointment"]>

  export type OthersAppointmentSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    relationship?: boolean
    age?: boolean
    gender?: boolean
    reason?: boolean
    appointmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OthersAppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contact" | "email" | "relationship" | "age" | "gender" | "reason" | "appointmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["othersAppointment"]>
  export type OthersAppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }
  export type OthersAppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }
  export type OthersAppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }

  export type $OthersAppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OthersAppointment"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contact: string
      email: string | null
      relationship: string
      age: number
      gender: $Enums.Gender
      reason: string | null
      appointmentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["othersAppointment"]>
    composites: {}
  }

  type OthersAppointmentGetPayload<S extends boolean | null | undefined | OthersAppointmentDefaultArgs> = $Result.GetResult<Prisma.$OthersAppointmentPayload, S>

  type OthersAppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OthersAppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OthersAppointmentCountAggregateInputType | true
    }

  export interface OthersAppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OthersAppointment'], meta: { name: 'OthersAppointment' } }
    /**
     * Find zero or one OthersAppointment that matches the filter.
     * @param {OthersAppointmentFindUniqueArgs} args - Arguments to find a OthersAppointment
     * @example
     * // Get one OthersAppointment
     * const othersAppointment = await prisma.othersAppointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OthersAppointmentFindUniqueArgs>(args: SelectSubset<T, OthersAppointmentFindUniqueArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OthersAppointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OthersAppointmentFindUniqueOrThrowArgs} args - Arguments to find a OthersAppointment
     * @example
     * // Get one OthersAppointment
     * const othersAppointment = await prisma.othersAppointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OthersAppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, OthersAppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OthersAppointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OthersAppointmentFindFirstArgs} args - Arguments to find a OthersAppointment
     * @example
     * // Get one OthersAppointment
     * const othersAppointment = await prisma.othersAppointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OthersAppointmentFindFirstArgs>(args?: SelectSubset<T, OthersAppointmentFindFirstArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OthersAppointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OthersAppointmentFindFirstOrThrowArgs} args - Arguments to find a OthersAppointment
     * @example
     * // Get one OthersAppointment
     * const othersAppointment = await prisma.othersAppointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OthersAppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, OthersAppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OthersAppointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OthersAppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OthersAppointments
     * const othersAppointments = await prisma.othersAppointment.findMany()
     * 
     * // Get first 10 OthersAppointments
     * const othersAppointments = await prisma.othersAppointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const othersAppointmentWithIdOnly = await prisma.othersAppointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OthersAppointmentFindManyArgs>(args?: SelectSubset<T, OthersAppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OthersAppointment.
     * @param {OthersAppointmentCreateArgs} args - Arguments to create a OthersAppointment.
     * @example
     * // Create one OthersAppointment
     * const OthersAppointment = await prisma.othersAppointment.create({
     *   data: {
     *     // ... data to create a OthersAppointment
     *   }
     * })
     * 
     */
    create<T extends OthersAppointmentCreateArgs>(args: SelectSubset<T, OthersAppointmentCreateArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OthersAppointments.
     * @param {OthersAppointmentCreateManyArgs} args - Arguments to create many OthersAppointments.
     * @example
     * // Create many OthersAppointments
     * const othersAppointment = await prisma.othersAppointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OthersAppointmentCreateManyArgs>(args?: SelectSubset<T, OthersAppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OthersAppointments and returns the data saved in the database.
     * @param {OthersAppointmentCreateManyAndReturnArgs} args - Arguments to create many OthersAppointments.
     * @example
     * // Create many OthersAppointments
     * const othersAppointment = await prisma.othersAppointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OthersAppointments and only return the `id`
     * const othersAppointmentWithIdOnly = await prisma.othersAppointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OthersAppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, OthersAppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OthersAppointment.
     * @param {OthersAppointmentDeleteArgs} args - Arguments to delete one OthersAppointment.
     * @example
     * // Delete one OthersAppointment
     * const OthersAppointment = await prisma.othersAppointment.delete({
     *   where: {
     *     // ... filter to delete one OthersAppointment
     *   }
     * })
     * 
     */
    delete<T extends OthersAppointmentDeleteArgs>(args: SelectSubset<T, OthersAppointmentDeleteArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OthersAppointment.
     * @param {OthersAppointmentUpdateArgs} args - Arguments to update one OthersAppointment.
     * @example
     * // Update one OthersAppointment
     * const othersAppointment = await prisma.othersAppointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OthersAppointmentUpdateArgs>(args: SelectSubset<T, OthersAppointmentUpdateArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OthersAppointments.
     * @param {OthersAppointmentDeleteManyArgs} args - Arguments to filter OthersAppointments to delete.
     * @example
     * // Delete a few OthersAppointments
     * const { count } = await prisma.othersAppointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OthersAppointmentDeleteManyArgs>(args?: SelectSubset<T, OthersAppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OthersAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OthersAppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OthersAppointments
     * const othersAppointment = await prisma.othersAppointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OthersAppointmentUpdateManyArgs>(args: SelectSubset<T, OthersAppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OthersAppointments and returns the data updated in the database.
     * @param {OthersAppointmentUpdateManyAndReturnArgs} args - Arguments to update many OthersAppointments.
     * @example
     * // Update many OthersAppointments
     * const othersAppointment = await prisma.othersAppointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OthersAppointments and only return the `id`
     * const othersAppointmentWithIdOnly = await prisma.othersAppointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OthersAppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, OthersAppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OthersAppointment.
     * @param {OthersAppointmentUpsertArgs} args - Arguments to update or create a OthersAppointment.
     * @example
     * // Update or create a OthersAppointment
     * const othersAppointment = await prisma.othersAppointment.upsert({
     *   create: {
     *     // ... data to create a OthersAppointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OthersAppointment we want to update
     *   }
     * })
     */
    upsert<T extends OthersAppointmentUpsertArgs>(args: SelectSubset<T, OthersAppointmentUpsertArgs<ExtArgs>>): Prisma__OthersAppointmentClient<$Result.GetResult<Prisma.$OthersAppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OthersAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OthersAppointmentCountArgs} args - Arguments to filter OthersAppointments to count.
     * @example
     * // Count the number of OthersAppointments
     * const count = await prisma.othersAppointment.count({
     *   where: {
     *     // ... the filter for the OthersAppointments we want to count
     *   }
     * })
    **/
    count<T extends OthersAppointmentCountArgs>(
      args?: Subset<T, OthersAppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OthersAppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OthersAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OthersAppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OthersAppointmentAggregateArgs>(args: Subset<T, OthersAppointmentAggregateArgs>): Prisma.PrismaPromise<GetOthersAppointmentAggregateType<T>>

    /**
     * Group by OthersAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OthersAppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OthersAppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OthersAppointmentGroupByArgs['orderBy'] }
        : { orderBy?: OthersAppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OthersAppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOthersAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OthersAppointment model
   */
  readonly fields: OthersAppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OthersAppointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OthersAppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OthersAppointment model
   */
  interface OthersAppointmentFieldRefs {
    readonly id: FieldRef<"OthersAppointment", 'String'>
    readonly name: FieldRef<"OthersAppointment", 'String'>
    readonly contact: FieldRef<"OthersAppointment", 'String'>
    readonly email: FieldRef<"OthersAppointment", 'String'>
    readonly relationship: FieldRef<"OthersAppointment", 'String'>
    readonly age: FieldRef<"OthersAppointment", 'Int'>
    readonly gender: FieldRef<"OthersAppointment", 'Gender'>
    readonly reason: FieldRef<"OthersAppointment", 'String'>
    readonly appointmentId: FieldRef<"OthersAppointment", 'String'>
    readonly createdAt: FieldRef<"OthersAppointment", 'DateTime'>
    readonly updatedAt: FieldRef<"OthersAppointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OthersAppointment findUnique
   */
  export type OthersAppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which OthersAppointment to fetch.
     */
    where: OthersAppointmentWhereUniqueInput
  }

  /**
   * OthersAppointment findUniqueOrThrow
   */
  export type OthersAppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which OthersAppointment to fetch.
     */
    where: OthersAppointmentWhereUniqueInput
  }

  /**
   * OthersAppointment findFirst
   */
  export type OthersAppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which OthersAppointment to fetch.
     */
    where?: OthersAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OthersAppointments to fetch.
     */
    orderBy?: OthersAppointmentOrderByWithRelationInput | OthersAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OthersAppointments.
     */
    cursor?: OthersAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OthersAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OthersAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OthersAppointments.
     */
    distinct?: OthersAppointmentScalarFieldEnum | OthersAppointmentScalarFieldEnum[]
  }

  /**
   * OthersAppointment findFirstOrThrow
   */
  export type OthersAppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which OthersAppointment to fetch.
     */
    where?: OthersAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OthersAppointments to fetch.
     */
    orderBy?: OthersAppointmentOrderByWithRelationInput | OthersAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OthersAppointments.
     */
    cursor?: OthersAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OthersAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OthersAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OthersAppointments.
     */
    distinct?: OthersAppointmentScalarFieldEnum | OthersAppointmentScalarFieldEnum[]
  }

  /**
   * OthersAppointment findMany
   */
  export type OthersAppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which OthersAppointments to fetch.
     */
    where?: OthersAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OthersAppointments to fetch.
     */
    orderBy?: OthersAppointmentOrderByWithRelationInput | OthersAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OthersAppointments.
     */
    cursor?: OthersAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OthersAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OthersAppointments.
     */
    skip?: number
    distinct?: OthersAppointmentScalarFieldEnum | OthersAppointmentScalarFieldEnum[]
  }

  /**
   * OthersAppointment create
   */
  export type OthersAppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a OthersAppointment.
     */
    data: XOR<OthersAppointmentCreateInput, OthersAppointmentUncheckedCreateInput>
  }

  /**
   * OthersAppointment createMany
   */
  export type OthersAppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OthersAppointments.
     */
    data: OthersAppointmentCreateManyInput | OthersAppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OthersAppointment createManyAndReturn
   */
  export type OthersAppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many OthersAppointments.
     */
    data: OthersAppointmentCreateManyInput | OthersAppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OthersAppointment update
   */
  export type OthersAppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a OthersAppointment.
     */
    data: XOR<OthersAppointmentUpdateInput, OthersAppointmentUncheckedUpdateInput>
    /**
     * Choose, which OthersAppointment to update.
     */
    where: OthersAppointmentWhereUniqueInput
  }

  /**
   * OthersAppointment updateMany
   */
  export type OthersAppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OthersAppointments.
     */
    data: XOR<OthersAppointmentUpdateManyMutationInput, OthersAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which OthersAppointments to update
     */
    where?: OthersAppointmentWhereInput
    /**
     * Limit how many OthersAppointments to update.
     */
    limit?: number
  }

  /**
   * OthersAppointment updateManyAndReturn
   */
  export type OthersAppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * The data used to update OthersAppointments.
     */
    data: XOR<OthersAppointmentUpdateManyMutationInput, OthersAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which OthersAppointments to update
     */
    where?: OthersAppointmentWhereInput
    /**
     * Limit how many OthersAppointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OthersAppointment upsert
   */
  export type OthersAppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the OthersAppointment to update in case it exists.
     */
    where: OthersAppointmentWhereUniqueInput
    /**
     * In case the OthersAppointment found by the `where` argument doesn't exist, create a new OthersAppointment with this data.
     */
    create: XOR<OthersAppointmentCreateInput, OthersAppointmentUncheckedCreateInput>
    /**
     * In case the OthersAppointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OthersAppointmentUpdateInput, OthersAppointmentUncheckedUpdateInput>
  }

  /**
   * OthersAppointment delete
   */
  export type OthersAppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
    /**
     * Filter which OthersAppointment to delete.
     */
    where: OthersAppointmentWhereUniqueInput
  }

  /**
   * OthersAppointment deleteMany
   */
  export type OthersAppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OthersAppointments to delete
     */
    where?: OthersAppointmentWhereInput
    /**
     * Limit how many OthersAppointments to delete.
     */
    limit?: number
  }

  /**
   * OthersAppointment without action
   */
  export type OthersAppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OthersAppointment
     */
    select?: OthersAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OthersAppointment
     */
    omit?: OthersAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OthersAppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    slotDuration: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    slotDuration: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    date: Date | null
    dayOfWeek: $Enums.WeekDay | null
    isRecurring: boolean | null
    recurrenceType: $Enums.RecurrenceType | null
    startTime: Date | null
    endTime: Date | null
    slotDuration: number | null
    location: string | null
    isAvailable: boolean | null
    service: $Enums.Service | null
    status: $Enums.Status | null
    serviceProviderId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    dayOfWeek: $Enums.WeekDay | null
    isRecurring: boolean | null
    recurrenceType: $Enums.RecurrenceType | null
    startTime: Date | null
    endTime: Date | null
    slotDuration: number | null
    location: string | null
    isAvailable: boolean | null
    service: $Enums.Service | null
    status: $Enums.Status | null
    serviceProviderId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    date: number
    dayOfWeek: number
    isRecurring: number
    recurrenceType: number
    startTime: number
    endTime: number
    slotDuration: number
    location: number
    isAvailable: number
    service: number
    status: number
    serviceProviderId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    slotDuration?: true
  }

  export type ScheduleSumAggregateInputType = {
    slotDuration?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    date?: true
    dayOfWeek?: true
    isRecurring?: true
    recurrenceType?: true
    startTime?: true
    endTime?: true
    slotDuration?: true
    location?: true
    isAvailable?: true
    service?: true
    status?: true
    serviceProviderId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    date?: true
    dayOfWeek?: true
    isRecurring?: true
    recurrenceType?: true
    startTime?: true
    endTime?: true
    slotDuration?: true
    location?: true
    isAvailable?: true
    service?: true
    status?: true
    serviceProviderId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    date?: true
    dayOfWeek?: true
    isRecurring?: true
    recurrenceType?: true
    startTime?: true
    endTime?: true
    slotDuration?: true
    location?: true
    isAvailable?: true
    service?: true
    status?: true
    serviceProviderId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    date: Date | null
    dayOfWeek: $Enums.WeekDay | null
    isRecurring: boolean
    recurrenceType: $Enums.RecurrenceType | null
    startTime: Date
    endTime: Date
    slotDuration: number
    location: string
    isAvailable: boolean
    service: $Enums.Service
    status: $Enums.Status
    serviceProviderId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    dayOfWeek?: boolean
    isRecurring?: boolean
    recurrenceType?: boolean
    startTime?: boolean
    endTime?: boolean
    slotDuration?: boolean
    location?: boolean
    isAvailable?: boolean
    service?: boolean
    status?: boolean
    serviceProviderId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceProviders?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    slots?: boolean | Schedule$slotsArgs<ExtArgs>
    clinicInfo?: boolean | Schedule$clinicInfoArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    dayOfWeek?: boolean
    isRecurring?: boolean
    recurrenceType?: boolean
    startTime?: boolean
    endTime?: boolean
    slotDuration?: boolean
    location?: boolean
    isAvailable?: boolean
    service?: boolean
    status?: boolean
    serviceProviderId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceProviders?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    dayOfWeek?: boolean
    isRecurring?: boolean
    recurrenceType?: boolean
    startTime?: boolean
    endTime?: boolean
    slotDuration?: boolean
    location?: boolean
    isAvailable?: boolean
    service?: boolean
    status?: boolean
    serviceProviderId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceProviders?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    date?: boolean
    dayOfWeek?: boolean
    isRecurring?: boolean
    recurrenceType?: boolean
    startTime?: boolean
    endTime?: boolean
    slotDuration?: boolean
    location?: boolean
    isAvailable?: boolean
    service?: boolean
    status?: boolean
    serviceProviderId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "dayOfWeek" | "isRecurring" | "recurrenceType" | "startTime" | "endTime" | "slotDuration" | "location" | "isAvailable" | "service" | "status" | "serviceProviderId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProviders?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    slots?: boolean | Schedule$slotsArgs<ExtArgs>
    clinicInfo?: boolean | Schedule$clinicInfoArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProviders?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProviders?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      serviceProviders: Prisma.$ServiceProviderPayload<ExtArgs>
      slots: Prisma.$SlotPayload<ExtArgs>[]
      clinicInfo: Prisma.$ClinicInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date | null
      dayOfWeek: $Enums.WeekDay | null
      isRecurring: boolean
      recurrenceType: $Enums.RecurrenceType | null
      startTime: Date
      endTime: Date
      slotDuration: number
      location: string
      isAvailable: boolean
      service: $Enums.Service
      status: $Enums.Status
      serviceProviderId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProviders<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slots<T extends Schedule$slotsArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$slotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinicInfo<T extends Schedule$clinicInfoArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$clinicInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly date: FieldRef<"Schedule", 'DateTime'>
    readonly dayOfWeek: FieldRef<"Schedule", 'WeekDay'>
    readonly isRecurring: FieldRef<"Schedule", 'Boolean'>
    readonly recurrenceType: FieldRef<"Schedule", 'RecurrenceType'>
    readonly startTime: FieldRef<"Schedule", 'DateTime'>
    readonly endTime: FieldRef<"Schedule", 'DateTime'>
    readonly slotDuration: FieldRef<"Schedule", 'Int'>
    readonly location: FieldRef<"Schedule", 'String'>
    readonly isAvailable: FieldRef<"Schedule", 'Boolean'>
    readonly service: FieldRef<"Schedule", 'Service'>
    readonly status: FieldRef<"Schedule", 'Status'>
    readonly serviceProviderId: FieldRef<"Schedule", 'String'>
    readonly userId: FieldRef<"Schedule", 'String'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule.slots
   */
  export type Schedule$slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    where?: SlotWhereInput
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    cursor?: SlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Schedule.clinicInfo
   */
  export type Schedule$clinicInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    where?: ClinicInfoWhereInput
    orderBy?: ClinicInfoOrderByWithRelationInput | ClinicInfoOrderByWithRelationInput[]
    cursor?: ClinicInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicInfoScalarFieldEnum | ClinicInfoScalarFieldEnum[]
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Slot
   */

  export type AggregateSlot = {
    _count: SlotCountAggregateOutputType | null
    _min: SlotMinAggregateOutputType | null
    _max: SlotMaxAggregateOutputType | null
  }

  export type SlotMinAggregateOutputType = {
    id: string | null
    slotDate: Date | null
    startTime: Date | null
    endTime: Date | null
    isBooked: boolean | null
    scheduleId: string | null
    bookedAt: Date | null
    updatedAt: Date | null
  }

  export type SlotMaxAggregateOutputType = {
    id: string | null
    slotDate: Date | null
    startTime: Date | null
    endTime: Date | null
    isBooked: boolean | null
    scheduleId: string | null
    bookedAt: Date | null
    updatedAt: Date | null
  }

  export type SlotCountAggregateOutputType = {
    id: number
    slotDate: number
    startTime: number
    endTime: number
    isBooked: number
    scheduleId: number
    bookedAt: number
    updatedAt: number
    _all: number
  }


  export type SlotMinAggregateInputType = {
    id?: true
    slotDate?: true
    startTime?: true
    endTime?: true
    isBooked?: true
    scheduleId?: true
    bookedAt?: true
    updatedAt?: true
  }

  export type SlotMaxAggregateInputType = {
    id?: true
    slotDate?: true
    startTime?: true
    endTime?: true
    isBooked?: true
    scheduleId?: true
    bookedAt?: true
    updatedAt?: true
  }

  export type SlotCountAggregateInputType = {
    id?: true
    slotDate?: true
    startTime?: true
    endTime?: true
    isBooked?: true
    scheduleId?: true
    bookedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Slot to aggregate.
     */
    where?: SlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Slots
    **/
    _count?: true | SlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlotMaxAggregateInputType
  }

  export type GetSlotAggregateType<T extends SlotAggregateArgs> = {
        [P in keyof T & keyof AggregateSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlot[P]>
      : GetScalarType<T[P], AggregateSlot[P]>
  }




  export type SlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlotWhereInput
    orderBy?: SlotOrderByWithAggregationInput | SlotOrderByWithAggregationInput[]
    by: SlotScalarFieldEnum[] | SlotScalarFieldEnum
    having?: SlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlotCountAggregateInputType | true
    _min?: SlotMinAggregateInputType
    _max?: SlotMaxAggregateInputType
  }

  export type SlotGroupByOutputType = {
    id: string
    slotDate: Date | null
    startTime: Date
    endTime: Date
    isBooked: boolean
    scheduleId: string
    bookedAt: Date | null
    updatedAt: Date
    _count: SlotCountAggregateOutputType | null
    _min: SlotMinAggregateOutputType | null
    _max: SlotMaxAggregateOutputType | null
  }

  type GetSlotGroupByPayload<T extends SlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlotGroupByOutputType[P]>
            : GetScalarType<T[P], SlotGroupByOutputType[P]>
        }
      >
    >


  export type SlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slotDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isBooked?: boolean
    scheduleId?: boolean
    bookedAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    appointment?: boolean | Slot$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type SlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slotDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isBooked?: boolean
    scheduleId?: boolean
    bookedAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type SlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slotDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isBooked?: boolean
    scheduleId?: boolean
    bookedAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type SlotSelectScalar = {
    id?: boolean
    slotDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isBooked?: boolean
    scheduleId?: boolean
    bookedAt?: boolean
    updatedAt?: boolean
  }

  export type SlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slotDate" | "startTime" | "endTime" | "isBooked" | "scheduleId" | "bookedAt" | "updatedAt", ExtArgs["result"]["slot"]>
  export type SlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    appointment?: boolean | Slot$appointmentArgs<ExtArgs>
  }
  export type SlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }
  export type SlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }

  export type $SlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Slot"
    objects: {
      schedule: Prisma.$SchedulePayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slotDate: Date | null
      startTime: Date
      endTime: Date
      isBooked: boolean
      scheduleId: string
      bookedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["slot"]>
    composites: {}
  }

  type SlotGetPayload<S extends boolean | null | undefined | SlotDefaultArgs> = $Result.GetResult<Prisma.$SlotPayload, S>

  type SlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SlotCountAggregateInputType | true
    }

  export interface SlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Slot'], meta: { name: 'Slot' } }
    /**
     * Find zero or one Slot that matches the filter.
     * @param {SlotFindUniqueArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlotFindUniqueArgs>(args: SelectSubset<T, SlotFindUniqueArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Slot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SlotFindUniqueOrThrowArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlotFindUniqueOrThrowArgs>(args: SelectSubset<T, SlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Slot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindFirstArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlotFindFirstArgs>(args?: SelectSubset<T, SlotFindFirstArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Slot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindFirstOrThrowArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlotFindFirstOrThrowArgs>(args?: SelectSubset<T, SlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slots
     * const slots = await prisma.slot.findMany()
     * 
     * // Get first 10 Slots
     * const slots = await prisma.slot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slotWithIdOnly = await prisma.slot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SlotFindManyArgs>(args?: SelectSubset<T, SlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Slot.
     * @param {SlotCreateArgs} args - Arguments to create a Slot.
     * @example
     * // Create one Slot
     * const Slot = await prisma.slot.create({
     *   data: {
     *     // ... data to create a Slot
     *   }
     * })
     * 
     */
    create<T extends SlotCreateArgs>(args: SelectSubset<T, SlotCreateArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Slots.
     * @param {SlotCreateManyArgs} args - Arguments to create many Slots.
     * @example
     * // Create many Slots
     * const slot = await prisma.slot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SlotCreateManyArgs>(args?: SelectSubset<T, SlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Slots and returns the data saved in the database.
     * @param {SlotCreateManyAndReturnArgs} args - Arguments to create many Slots.
     * @example
     * // Create many Slots
     * const slot = await prisma.slot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Slots and only return the `id`
     * const slotWithIdOnly = await prisma.slot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SlotCreateManyAndReturnArgs>(args?: SelectSubset<T, SlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Slot.
     * @param {SlotDeleteArgs} args - Arguments to delete one Slot.
     * @example
     * // Delete one Slot
     * const Slot = await prisma.slot.delete({
     *   where: {
     *     // ... filter to delete one Slot
     *   }
     * })
     * 
     */
    delete<T extends SlotDeleteArgs>(args: SelectSubset<T, SlotDeleteArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Slot.
     * @param {SlotUpdateArgs} args - Arguments to update one Slot.
     * @example
     * // Update one Slot
     * const slot = await prisma.slot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SlotUpdateArgs>(args: SelectSubset<T, SlotUpdateArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Slots.
     * @param {SlotDeleteManyArgs} args - Arguments to filter Slots to delete.
     * @example
     * // Delete a few Slots
     * const { count } = await prisma.slot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SlotDeleteManyArgs>(args?: SelectSubset<T, SlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slots
     * const slot = await prisma.slot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SlotUpdateManyArgs>(args: SelectSubset<T, SlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slots and returns the data updated in the database.
     * @param {SlotUpdateManyAndReturnArgs} args - Arguments to update many Slots.
     * @example
     * // Update many Slots
     * const slot = await prisma.slot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Slots and only return the `id`
     * const slotWithIdOnly = await prisma.slot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SlotUpdateManyAndReturnArgs>(args: SelectSubset<T, SlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Slot.
     * @param {SlotUpsertArgs} args - Arguments to update or create a Slot.
     * @example
     * // Update or create a Slot
     * const slot = await prisma.slot.upsert({
     *   create: {
     *     // ... data to create a Slot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slot we want to update
     *   }
     * })
     */
    upsert<T extends SlotUpsertArgs>(args: SelectSubset<T, SlotUpsertArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotCountArgs} args - Arguments to filter Slots to count.
     * @example
     * // Count the number of Slots
     * const count = await prisma.slot.count({
     *   where: {
     *     // ... the filter for the Slots we want to count
     *   }
     * })
    **/
    count<T extends SlotCountArgs>(
      args?: Subset<T, SlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlotAggregateArgs>(args: Subset<T, SlotAggregateArgs>): Prisma.PrismaPromise<GetSlotAggregateType<T>>

    /**
     * Group by Slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlotGroupByArgs['orderBy'] }
        : { orderBy?: SlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Slot model
   */
  readonly fields: SlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Slot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleDefaultArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends Slot$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Slot$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Slot model
   */
  interface SlotFieldRefs {
    readonly id: FieldRef<"Slot", 'String'>
    readonly slotDate: FieldRef<"Slot", 'DateTime'>
    readonly startTime: FieldRef<"Slot", 'DateTime'>
    readonly endTime: FieldRef<"Slot", 'DateTime'>
    readonly isBooked: FieldRef<"Slot", 'Boolean'>
    readonly scheduleId: FieldRef<"Slot", 'String'>
    readonly bookedAt: FieldRef<"Slot", 'DateTime'>
    readonly updatedAt: FieldRef<"Slot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Slot findUnique
   */
  export type SlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slot to fetch.
     */
    where: SlotWhereUniqueInput
  }

  /**
   * Slot findUniqueOrThrow
   */
  export type SlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slot to fetch.
     */
    where: SlotWhereUniqueInput
  }

  /**
   * Slot findFirst
   */
  export type SlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slot to fetch.
     */
    where?: SlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Slots.
     */
    cursor?: SlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Slots.
     */
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Slot findFirstOrThrow
   */
  export type SlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slot to fetch.
     */
    where?: SlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Slots.
     */
    cursor?: SlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Slots.
     */
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Slot findMany
   */
  export type SlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slots to fetch.
     */
    where?: SlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Slots.
     */
    cursor?: SlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slots.
     */
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Slot create
   */
  export type SlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * The data needed to create a Slot.
     */
    data: XOR<SlotCreateInput, SlotUncheckedCreateInput>
  }

  /**
   * Slot createMany
   */
  export type SlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Slots.
     */
    data: SlotCreateManyInput | SlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Slot createManyAndReturn
   */
  export type SlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * The data used to create many Slots.
     */
    data: SlotCreateManyInput | SlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Slot update
   */
  export type SlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * The data needed to update a Slot.
     */
    data: XOR<SlotUpdateInput, SlotUncheckedUpdateInput>
    /**
     * Choose, which Slot to update.
     */
    where: SlotWhereUniqueInput
  }

  /**
   * Slot updateMany
   */
  export type SlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Slots.
     */
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyInput>
    /**
     * Filter which Slots to update
     */
    where?: SlotWhereInput
    /**
     * Limit how many Slots to update.
     */
    limit?: number
  }

  /**
   * Slot updateManyAndReturn
   */
  export type SlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * The data used to update Slots.
     */
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyInput>
    /**
     * Filter which Slots to update
     */
    where?: SlotWhereInput
    /**
     * Limit how many Slots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Slot upsert
   */
  export type SlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * The filter to search for the Slot to update in case it exists.
     */
    where: SlotWhereUniqueInput
    /**
     * In case the Slot found by the `where` argument doesn't exist, create a new Slot with this data.
     */
    create: XOR<SlotCreateInput, SlotUncheckedCreateInput>
    /**
     * In case the Slot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlotUpdateInput, SlotUncheckedUpdateInput>
  }

  /**
   * Slot delete
   */
  export type SlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter which Slot to delete.
     */
    where: SlotWhereUniqueInput
  }

  /**
   * Slot deleteMany
   */
  export type SlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Slots to delete
     */
    where?: SlotWhereInput
    /**
     * Limit how many Slots to delete.
     */
    limit?: number
  }

  /**
   * Slot.appointment
   */
  export type Slot$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Slot without action
   */
  export type SlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
  }


  /**
   * Model ClinicInfo
   */

  export type AggregateClinicInfo = {
    _count: ClinicInfoCountAggregateOutputType | null
    _min: ClinicInfoMinAggregateOutputType | null
    _max: ClinicInfoMaxAggregateOutputType | null
  }

  export type ClinicInfoMinAggregateOutputType = {
    id: string | null
    clinicName: string | null
    addressId: string | null
    phone: string | null
    scheduleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicInfoMaxAggregateOutputType = {
    id: string | null
    clinicName: string | null
    addressId: string | null
    phone: string | null
    scheduleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicInfoCountAggregateOutputType = {
    id: number
    clinicName: number
    addressId: number
    phone: number
    images: number
    scheduleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicInfoMinAggregateInputType = {
    id?: true
    clinicName?: true
    addressId?: true
    phone?: true
    scheduleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicInfoMaxAggregateInputType = {
    id?: true
    clinicName?: true
    addressId?: true
    phone?: true
    scheduleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicInfoCountAggregateInputType = {
    id?: true
    clinicName?: true
    addressId?: true
    phone?: true
    images?: true
    scheduleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicInfo to aggregate.
     */
    where?: ClinicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicInfos to fetch.
     */
    orderBy?: ClinicInfoOrderByWithRelationInput | ClinicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicInfos
    **/
    _count?: true | ClinicInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicInfoMaxAggregateInputType
  }

  export type GetClinicInfoAggregateType<T extends ClinicInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicInfo[P]>
      : GetScalarType<T[P], AggregateClinicInfo[P]>
  }




  export type ClinicInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicInfoWhereInput
    orderBy?: ClinicInfoOrderByWithAggregationInput | ClinicInfoOrderByWithAggregationInput[]
    by: ClinicInfoScalarFieldEnum[] | ClinicInfoScalarFieldEnum
    having?: ClinicInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicInfoCountAggregateInputType | true
    _min?: ClinicInfoMinAggregateInputType
    _max?: ClinicInfoMaxAggregateInputType
  }

  export type ClinicInfoGroupByOutputType = {
    id: string
    clinicName: string
    addressId: string
    phone: string
    images: string[]
    scheduleId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClinicInfoCountAggregateOutputType | null
    _min: ClinicInfoMinAggregateOutputType | null
    _max: ClinicInfoMaxAggregateOutputType | null
  }

  type GetClinicInfoGroupByPayload<T extends ClinicInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicInfoGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicInfoGroupByOutputType[P]>
        }
      >
    >


  export type ClinicInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicName?: boolean
    addressId?: boolean
    phone?: boolean
    images?: boolean
    scheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    serviceProviders?: boolean | ClinicInfo$serviceProvidersArgs<ExtArgs>
    schedule?: boolean | ClinicInfo$scheduleArgs<ExtArgs>
    _count?: boolean | ClinicInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicInfo"]>

  export type ClinicInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicName?: boolean
    addressId?: boolean
    phone?: boolean
    images?: boolean
    scheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    schedule?: boolean | ClinicInfo$scheduleArgs<ExtArgs>
  }, ExtArgs["result"]["clinicInfo"]>

  export type ClinicInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicName?: boolean
    addressId?: boolean
    phone?: boolean
    images?: boolean
    scheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    schedule?: boolean | ClinicInfo$scheduleArgs<ExtArgs>
  }, ExtArgs["result"]["clinicInfo"]>

  export type ClinicInfoSelectScalar = {
    id?: boolean
    clinicName?: boolean
    addressId?: boolean
    phone?: boolean
    images?: boolean
    scheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicName" | "addressId" | "phone" | "images" | "scheduleId" | "createdAt" | "updatedAt", ExtArgs["result"]["clinicInfo"]>
  export type ClinicInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    serviceProviders?: boolean | ClinicInfo$serviceProvidersArgs<ExtArgs>
    schedule?: boolean | ClinicInfo$scheduleArgs<ExtArgs>
    _count?: boolean | ClinicInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    schedule?: boolean | ClinicInfo$scheduleArgs<ExtArgs>
  }
  export type ClinicInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    schedule?: boolean | ClinicInfo$scheduleArgs<ExtArgs>
  }

  export type $ClinicInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicInfo"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>
      serviceProviders: Prisma.$ServiceProviderPayload<ExtArgs>[]
      schedule: Prisma.$SchedulePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicName: string
      addressId: string
      phone: string
      images: string[]
      scheduleId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicInfo"]>
    composites: {}
  }

  type ClinicInfoGetPayload<S extends boolean | null | undefined | ClinicInfoDefaultArgs> = $Result.GetResult<Prisma.$ClinicInfoPayload, S>

  type ClinicInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicInfoCountAggregateInputType | true
    }

  export interface ClinicInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicInfo'], meta: { name: 'ClinicInfo' } }
    /**
     * Find zero or one ClinicInfo that matches the filter.
     * @param {ClinicInfoFindUniqueArgs} args - Arguments to find a ClinicInfo
     * @example
     * // Get one ClinicInfo
     * const clinicInfo = await prisma.clinicInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicInfoFindUniqueArgs>(args: SelectSubset<T, ClinicInfoFindUniqueArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicInfoFindUniqueOrThrowArgs} args - Arguments to find a ClinicInfo
     * @example
     * // Get one ClinicInfo
     * const clinicInfo = await prisma.clinicInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicInfoFindFirstArgs} args - Arguments to find a ClinicInfo
     * @example
     * // Get one ClinicInfo
     * const clinicInfo = await prisma.clinicInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicInfoFindFirstArgs>(args?: SelectSubset<T, ClinicInfoFindFirstArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicInfoFindFirstOrThrowArgs} args - Arguments to find a ClinicInfo
     * @example
     * // Get one ClinicInfo
     * const clinicInfo = await prisma.clinicInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicInfos
     * const clinicInfos = await prisma.clinicInfo.findMany()
     * 
     * // Get first 10 ClinicInfos
     * const clinicInfos = await prisma.clinicInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicInfoWithIdOnly = await prisma.clinicInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicInfoFindManyArgs>(args?: SelectSubset<T, ClinicInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicInfo.
     * @param {ClinicInfoCreateArgs} args - Arguments to create a ClinicInfo.
     * @example
     * // Create one ClinicInfo
     * const ClinicInfo = await prisma.clinicInfo.create({
     *   data: {
     *     // ... data to create a ClinicInfo
     *   }
     * })
     * 
     */
    create<T extends ClinicInfoCreateArgs>(args: SelectSubset<T, ClinicInfoCreateArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicInfos.
     * @param {ClinicInfoCreateManyArgs} args - Arguments to create many ClinicInfos.
     * @example
     * // Create many ClinicInfos
     * const clinicInfo = await prisma.clinicInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicInfoCreateManyArgs>(args?: SelectSubset<T, ClinicInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicInfos and returns the data saved in the database.
     * @param {ClinicInfoCreateManyAndReturnArgs} args - Arguments to create many ClinicInfos.
     * @example
     * // Create many ClinicInfos
     * const clinicInfo = await prisma.clinicInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicInfos and only return the `id`
     * const clinicInfoWithIdOnly = await prisma.clinicInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicInfo.
     * @param {ClinicInfoDeleteArgs} args - Arguments to delete one ClinicInfo.
     * @example
     * // Delete one ClinicInfo
     * const ClinicInfo = await prisma.clinicInfo.delete({
     *   where: {
     *     // ... filter to delete one ClinicInfo
     *   }
     * })
     * 
     */
    delete<T extends ClinicInfoDeleteArgs>(args: SelectSubset<T, ClinicInfoDeleteArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicInfo.
     * @param {ClinicInfoUpdateArgs} args - Arguments to update one ClinicInfo.
     * @example
     * // Update one ClinicInfo
     * const clinicInfo = await prisma.clinicInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicInfoUpdateArgs>(args: SelectSubset<T, ClinicInfoUpdateArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicInfos.
     * @param {ClinicInfoDeleteManyArgs} args - Arguments to filter ClinicInfos to delete.
     * @example
     * // Delete a few ClinicInfos
     * const { count } = await prisma.clinicInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicInfoDeleteManyArgs>(args?: SelectSubset<T, ClinicInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicInfos
     * const clinicInfo = await prisma.clinicInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicInfoUpdateManyArgs>(args: SelectSubset<T, ClinicInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicInfos and returns the data updated in the database.
     * @param {ClinicInfoUpdateManyAndReturnArgs} args - Arguments to update many ClinicInfos.
     * @example
     * // Update many ClinicInfos
     * const clinicInfo = await prisma.clinicInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicInfos and only return the `id`
     * const clinicInfoWithIdOnly = await prisma.clinicInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicInfo.
     * @param {ClinicInfoUpsertArgs} args - Arguments to update or create a ClinicInfo.
     * @example
     * // Update or create a ClinicInfo
     * const clinicInfo = await prisma.clinicInfo.upsert({
     *   create: {
     *     // ... data to create a ClinicInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicInfo we want to update
     *   }
     * })
     */
    upsert<T extends ClinicInfoUpsertArgs>(args: SelectSubset<T, ClinicInfoUpsertArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicInfoCountArgs} args - Arguments to filter ClinicInfos to count.
     * @example
     * // Count the number of ClinicInfos
     * const count = await prisma.clinicInfo.count({
     *   where: {
     *     // ... the filter for the ClinicInfos we want to count
     *   }
     * })
    **/
    count<T extends ClinicInfoCountArgs>(
      args?: Subset<T, ClinicInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicInfoAggregateArgs>(args: Subset<T, ClinicInfoAggregateArgs>): Prisma.PrismaPromise<GetClinicInfoAggregateType<T>>

    /**
     * Group by ClinicInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicInfoGroupByArgs['orderBy'] }
        : { orderBy?: ClinicInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicInfo model
   */
  readonly fields: ClinicInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProviders<T extends ClinicInfo$serviceProvidersArgs<ExtArgs> = {}>(args?: Subset<T, ClinicInfo$serviceProvidersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedule<T extends ClinicInfo$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, ClinicInfo$scheduleArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicInfo model
   */
  interface ClinicInfoFieldRefs {
    readonly id: FieldRef<"ClinicInfo", 'String'>
    readonly clinicName: FieldRef<"ClinicInfo", 'String'>
    readonly addressId: FieldRef<"ClinicInfo", 'String'>
    readonly phone: FieldRef<"ClinicInfo", 'String'>
    readonly images: FieldRef<"ClinicInfo", 'String[]'>
    readonly scheduleId: FieldRef<"ClinicInfo", 'String'>
    readonly createdAt: FieldRef<"ClinicInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicInfo findUnique
   */
  export type ClinicInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClinicInfo to fetch.
     */
    where: ClinicInfoWhereUniqueInput
  }

  /**
   * ClinicInfo findUniqueOrThrow
   */
  export type ClinicInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClinicInfo to fetch.
     */
    where: ClinicInfoWhereUniqueInput
  }

  /**
   * ClinicInfo findFirst
   */
  export type ClinicInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClinicInfo to fetch.
     */
    where?: ClinicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicInfos to fetch.
     */
    orderBy?: ClinicInfoOrderByWithRelationInput | ClinicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicInfos.
     */
    cursor?: ClinicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicInfos.
     */
    distinct?: ClinicInfoScalarFieldEnum | ClinicInfoScalarFieldEnum[]
  }

  /**
   * ClinicInfo findFirstOrThrow
   */
  export type ClinicInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClinicInfo to fetch.
     */
    where?: ClinicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicInfos to fetch.
     */
    orderBy?: ClinicInfoOrderByWithRelationInput | ClinicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicInfos.
     */
    cursor?: ClinicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicInfos.
     */
    distinct?: ClinicInfoScalarFieldEnum | ClinicInfoScalarFieldEnum[]
  }

  /**
   * ClinicInfo findMany
   */
  export type ClinicInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClinicInfos to fetch.
     */
    where?: ClinicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicInfos to fetch.
     */
    orderBy?: ClinicInfoOrderByWithRelationInput | ClinicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicInfos.
     */
    cursor?: ClinicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicInfos.
     */
    skip?: number
    distinct?: ClinicInfoScalarFieldEnum | ClinicInfoScalarFieldEnum[]
  }

  /**
   * ClinicInfo create
   */
  export type ClinicInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicInfo.
     */
    data: XOR<ClinicInfoCreateInput, ClinicInfoUncheckedCreateInput>
  }

  /**
   * ClinicInfo createMany
   */
  export type ClinicInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicInfos.
     */
    data: ClinicInfoCreateManyInput | ClinicInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicInfo createManyAndReturn
   */
  export type ClinicInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicInfos.
     */
    data: ClinicInfoCreateManyInput | ClinicInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicInfo update
   */
  export type ClinicInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicInfo.
     */
    data: XOR<ClinicInfoUpdateInput, ClinicInfoUncheckedUpdateInput>
    /**
     * Choose, which ClinicInfo to update.
     */
    where: ClinicInfoWhereUniqueInput
  }

  /**
   * ClinicInfo updateMany
   */
  export type ClinicInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicInfos.
     */
    data: XOR<ClinicInfoUpdateManyMutationInput, ClinicInfoUncheckedUpdateManyInput>
    /**
     * Filter which ClinicInfos to update
     */
    where?: ClinicInfoWhereInput
    /**
     * Limit how many ClinicInfos to update.
     */
    limit?: number
  }

  /**
   * ClinicInfo updateManyAndReturn
   */
  export type ClinicInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * The data used to update ClinicInfos.
     */
    data: XOR<ClinicInfoUpdateManyMutationInput, ClinicInfoUncheckedUpdateManyInput>
    /**
     * Filter which ClinicInfos to update
     */
    where?: ClinicInfoWhereInput
    /**
     * Limit how many ClinicInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicInfo upsert
   */
  export type ClinicInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicInfo to update in case it exists.
     */
    where: ClinicInfoWhereUniqueInput
    /**
     * In case the ClinicInfo found by the `where` argument doesn't exist, create a new ClinicInfo with this data.
     */
    create: XOR<ClinicInfoCreateInput, ClinicInfoUncheckedCreateInput>
    /**
     * In case the ClinicInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicInfoUpdateInput, ClinicInfoUncheckedUpdateInput>
  }

  /**
   * ClinicInfo delete
   */
  export type ClinicInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    /**
     * Filter which ClinicInfo to delete.
     */
    where: ClinicInfoWhereUniqueInput
  }

  /**
   * ClinicInfo deleteMany
   */
  export type ClinicInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicInfos to delete
     */
    where?: ClinicInfoWhereInput
    /**
     * Limit how many ClinicInfos to delete.
     */
    limit?: number
  }

  /**
   * ClinicInfo.serviceProviders
   */
  export type ClinicInfo$serviceProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    where?: ServiceProviderWhereInput
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    cursor?: ServiceProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ClinicInfo.schedule
   */
  export type ClinicInfo$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
  }

  /**
   * ClinicInfo without action
   */
  export type ClinicInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    userId: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    userId: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    address: number
    city: number
    state: number
    country: number
    pincode: number
    userId: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    address?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    userId?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    address?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    userId?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    address?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    userId?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    userId: string | null
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    userId?: boolean
    user?: boolean | Address$userArgs<ExtArgs>
    clinicInfo?: boolean | Address$clinicInfoArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    userId?: boolean
    user?: boolean | Address$userArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    userId?: boolean
    user?: boolean | Address$userArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    userId?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "city" | "state" | "country" | "pincode" | "userId", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>
    clinicInfo?: boolean | Address$clinicInfoArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      clinicInfo: Prisma.$ClinicInfoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      pincode: string | null
      userId: string | null
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Address$userArgs<ExtArgs> = {}>(args?: Subset<T, Address$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clinicInfo<T extends Address$clinicInfoArgs<ExtArgs> = {}>(args?: Subset<T, Address$clinicInfoArgs<ExtArgs>>): Prisma__ClinicInfoClient<$Result.GetResult<Prisma.$ClinicInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly address: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly pincode: FieldRef<"Address", 'String'>
    readonly userId: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data?: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.user
   */
  export type Address$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Address.clinicInfo
   */
  export type Address$clinicInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicInfo
     */
    select?: ClinicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicInfo
     */
    omit?: ClinicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInfoInclude<ExtArgs> | null
    where?: ClinicInfoWhereInput
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Education
   */

  export type AggregateEducation = {
    _count: EducationCountAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  export type EducationMinAggregateOutputType = {
    id: string | null
    university: string | null
    degree: string | null
    duration: string | null
    serviceProviderId: string | null
  }

  export type EducationMaxAggregateOutputType = {
    id: string | null
    university: string | null
    degree: string | null
    duration: string | null
    serviceProviderId: string | null
  }

  export type EducationCountAggregateOutputType = {
    id: number
    university: number
    degree: number
    duration: number
    serviceProviderId: number
    _all: number
  }


  export type EducationMinAggregateInputType = {
    id?: true
    university?: true
    degree?: true
    duration?: true
    serviceProviderId?: true
  }

  export type EducationMaxAggregateInputType = {
    id?: true
    university?: true
    degree?: true
    duration?: true
    serviceProviderId?: true
  }

  export type EducationCountAggregateInputType = {
    id?: true
    university?: true
    degree?: true
    duration?: true
    serviceProviderId?: true
    _all?: true
  }

  export type EducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Education to aggregate.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Educations
    **/
    _count?: true | EducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationMaxAggregateInputType
  }

  export type GetEducationAggregateType<T extends EducationAggregateArgs> = {
        [P in keyof T & keyof AggregateEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducation[P]>
      : GetScalarType<T[P], AggregateEducation[P]>
  }




  export type EducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithAggregationInput | EducationOrderByWithAggregationInput[]
    by: EducationScalarFieldEnum[] | EducationScalarFieldEnum
    having?: EducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationCountAggregateInputType | true
    _min?: EducationMinAggregateInputType
    _max?: EducationMaxAggregateInputType
  }

  export type EducationGroupByOutputType = {
    id: string
    university: string
    degree: string
    duration: string
    serviceProviderId: string
    _count: EducationCountAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  type GetEducationGroupByPayload<T extends EducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationGroupByOutputType[P]>
            : GetScalarType<T[P], EducationGroupByOutputType[P]>
        }
      >
    >


  export type EducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    university?: boolean
    degree?: boolean
    duration?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    university?: boolean
    degree?: boolean
    duration?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    university?: boolean
    degree?: boolean
    duration?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectScalar = {
    id?: boolean
    university?: boolean
    degree?: boolean
    duration?: boolean
    serviceProviderId?: boolean
  }

  export type EducationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "university" | "degree" | "duration" | "serviceProviderId", ExtArgs["result"]["education"]>
  export type EducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type EducationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type EducationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $EducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Education"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      university: string
      degree: string
      duration: string
      serviceProviderId: string
    }, ExtArgs["result"]["education"]>
    composites: {}
  }

  type EducationGetPayload<S extends boolean | null | undefined | EducationDefaultArgs> = $Result.GetResult<Prisma.$EducationPayload, S>

  type EducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationCountAggregateInputType | true
    }

  export interface EducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Education'], meta: { name: 'Education' } }
    /**
     * Find zero or one Education that matches the filter.
     * @param {EducationFindUniqueArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationFindUniqueArgs>(args: SelectSubset<T, EducationFindUniqueArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Education that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationFindUniqueOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationFindFirstArgs>(args?: SelectSubset<T, EducationFindFirstArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.education.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.education.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationWithIdOnly = await prisma.education.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationFindManyArgs>(args?: SelectSubset<T, EducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Education.
     * @param {EducationCreateArgs} args - Arguments to create a Education.
     * @example
     * // Create one Education
     * const Education = await prisma.education.create({
     *   data: {
     *     // ... data to create a Education
     *   }
     * })
     * 
     */
    create<T extends EducationCreateArgs>(args: SelectSubset<T, EducationCreateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Educations.
     * @param {EducationCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationCreateManyArgs>(args?: SelectSubset<T, EducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Educations and returns the data saved in the database.
     * @param {EducationCreateManyAndReturnArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationCreateManyAndReturnArgs>(args?: SelectSubset<T, EducationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Education.
     * @param {EducationDeleteArgs} args - Arguments to delete one Education.
     * @example
     * // Delete one Education
     * const Education = await prisma.education.delete({
     *   where: {
     *     // ... filter to delete one Education
     *   }
     * })
     * 
     */
    delete<T extends EducationDeleteArgs>(args: SelectSubset<T, EducationDeleteArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Education.
     * @param {EducationUpdateArgs} args - Arguments to update one Education.
     * @example
     * // Update one Education
     * const education = await prisma.education.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationUpdateArgs>(args: SelectSubset<T, EducationUpdateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Educations.
     * @param {EducationDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.education.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationDeleteManyArgs>(args?: SelectSubset<T, EducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationUpdateManyArgs>(args: SelectSubset<T, EducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations and returns the data updated in the database.
     * @param {EducationUpdateManyAndReturnArgs} args - Arguments to update many Educations.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EducationUpdateManyAndReturnArgs>(args: SelectSubset<T, EducationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Education.
     * @param {EducationUpsertArgs} args - Arguments to update or create a Education.
     * @example
     * // Update or create a Education
     * const education = await prisma.education.upsert({
     *   create: {
     *     // ... data to create a Education
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Education we want to update
     *   }
     * })
     */
    upsert<T extends EducationUpsertArgs>(args: SelectSubset<T, EducationUpsertArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.education.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends EducationCountArgs>(
      args?: Subset<T, EducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationAggregateArgs>(args: Subset<T, EducationAggregateArgs>): Prisma.PrismaPromise<GetEducationAggregateType<T>>

    /**
     * Group by Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationGroupByArgs['orderBy'] }
        : { orderBy?: EducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Education model
   */
  readonly fields: EducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Education model
   */
  interface EducationFieldRefs {
    readonly id: FieldRef<"Education", 'String'>
    readonly university: FieldRef<"Education", 'String'>
    readonly degree: FieldRef<"Education", 'String'>
    readonly duration: FieldRef<"Education", 'String'>
    readonly serviceProviderId: FieldRef<"Education", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Education findUnique
   */
  export type EducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findUniqueOrThrow
   */
  export type EducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findFirst
   */
  export type EducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findFirstOrThrow
   */
  export type EducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findMany
   */
  export type EducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Educations to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education create
   */
  export type EducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to create a Education.
     */
    data: XOR<EducationCreateInput, EducationUncheckedCreateInput>
  }

  /**
   * Education createMany
   */
  export type EducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Education createManyAndReturn
   */
  export type EducationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education update
   */
  export type EducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to update a Education.
     */
    data: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
    /**
     * Choose, which Education to update.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education updateMany
   */
  export type EducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
  }

  /**
   * Education updateManyAndReturn
   */
  export type EducationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education upsert
   */
  export type EducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The filter to search for the Education to update in case it exists.
     */
    where: EducationWhereUniqueInput
    /**
     * In case the Education found by the `where` argument doesn't exist, create a new Education with this data.
     */
    create: XOR<EducationCreateInput, EducationUncheckedCreateInput>
    /**
     * In case the Education was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
  }

  /**
   * Education delete
   */
  export type EducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter which Education to delete.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education deleteMany
   */
  export type EducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Educations to delete
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to delete.
     */
    limit?: number
  }

  /**
   * Education without action
   */
  export type EducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
  }


  /**
   * Model WorkExperience
   */

  export type AggregateWorkExperience = {
    _count: WorkExperienceCountAggregateOutputType | null
    _min: WorkExperienceMinAggregateOutputType | null
    _max: WorkExperienceMaxAggregateOutputType | null
  }

  export type WorkExperienceMinAggregateOutputType = {
    id: string | null
    clinic: string | null
    duration: string | null
    serviceProviderId: string | null
  }

  export type WorkExperienceMaxAggregateOutputType = {
    id: string | null
    clinic: string | null
    duration: string | null
    serviceProviderId: string | null
  }

  export type WorkExperienceCountAggregateOutputType = {
    id: number
    clinic: number
    duration: number
    serviceProviderId: number
    _all: number
  }


  export type WorkExperienceMinAggregateInputType = {
    id?: true
    clinic?: true
    duration?: true
    serviceProviderId?: true
  }

  export type WorkExperienceMaxAggregateInputType = {
    id?: true
    clinic?: true
    duration?: true
    serviceProviderId?: true
  }

  export type WorkExperienceCountAggregateInputType = {
    id?: true
    clinic?: true
    duration?: true
    serviceProviderId?: true
    _all?: true
  }

  export type WorkExperienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkExperience to aggregate.
     */
    where?: WorkExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkExperiences to fetch.
     */
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkExperiences
    **/
    _count?: true | WorkExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkExperienceMaxAggregateInputType
  }

  export type GetWorkExperienceAggregateType<T extends WorkExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkExperience[P]>
      : GetScalarType<T[P], AggregateWorkExperience[P]>
  }




  export type WorkExperienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkExperienceWhereInput
    orderBy?: WorkExperienceOrderByWithAggregationInput | WorkExperienceOrderByWithAggregationInput[]
    by: WorkExperienceScalarFieldEnum[] | WorkExperienceScalarFieldEnum
    having?: WorkExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkExperienceCountAggregateInputType | true
    _min?: WorkExperienceMinAggregateInputType
    _max?: WorkExperienceMaxAggregateInputType
  }

  export type WorkExperienceGroupByOutputType = {
    id: string
    clinic: string
    duration: string
    serviceProviderId: string
    _count: WorkExperienceCountAggregateOutputType | null
    _min: WorkExperienceMinAggregateOutputType | null
    _max: WorkExperienceMaxAggregateOutputType | null
  }

  type GetWorkExperienceGroupByPayload<T extends WorkExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkExperienceGroupByOutputType[P]>
        }
      >
    >


  export type WorkExperienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinic?: boolean
    duration?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workExperience"]>

  export type WorkExperienceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinic?: boolean
    duration?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workExperience"]>

  export type WorkExperienceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinic?: boolean
    duration?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workExperience"]>

  export type WorkExperienceSelectScalar = {
    id?: boolean
    clinic?: boolean
    duration?: boolean
    serviceProviderId?: boolean
  }

  export type WorkExperienceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinic" | "duration" | "serviceProviderId", ExtArgs["result"]["workExperience"]>
  export type WorkExperienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type WorkExperienceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type WorkExperienceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $WorkExperiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkExperience"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinic: string
      duration: string
      serviceProviderId: string
    }, ExtArgs["result"]["workExperience"]>
    composites: {}
  }

  type WorkExperienceGetPayload<S extends boolean | null | undefined | WorkExperienceDefaultArgs> = $Result.GetResult<Prisma.$WorkExperiencePayload, S>

  type WorkExperienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkExperienceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkExperienceCountAggregateInputType | true
    }

  export interface WorkExperienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkExperience'], meta: { name: 'WorkExperience' } }
    /**
     * Find zero or one WorkExperience that matches the filter.
     * @param {WorkExperienceFindUniqueArgs} args - Arguments to find a WorkExperience
     * @example
     * // Get one WorkExperience
     * const workExperience = await prisma.workExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkExperienceFindUniqueArgs>(args: SelectSubset<T, WorkExperienceFindUniqueArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkExperience that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkExperienceFindUniqueOrThrowArgs} args - Arguments to find a WorkExperience
     * @example
     * // Get one WorkExperience
     * const workExperience = await prisma.workExperience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkExperienceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkExperienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceFindFirstArgs} args - Arguments to find a WorkExperience
     * @example
     * // Get one WorkExperience
     * const workExperience = await prisma.workExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkExperienceFindFirstArgs>(args?: SelectSubset<T, WorkExperienceFindFirstArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkExperience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceFindFirstOrThrowArgs} args - Arguments to find a WorkExperience
     * @example
     * // Get one WorkExperience
     * const workExperience = await prisma.workExperience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkExperienceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkExperienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkExperiences
     * const workExperiences = await prisma.workExperience.findMany()
     * 
     * // Get first 10 WorkExperiences
     * const workExperiences = await prisma.workExperience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workExperienceWithIdOnly = await prisma.workExperience.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkExperienceFindManyArgs>(args?: SelectSubset<T, WorkExperienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkExperience.
     * @param {WorkExperienceCreateArgs} args - Arguments to create a WorkExperience.
     * @example
     * // Create one WorkExperience
     * const WorkExperience = await prisma.workExperience.create({
     *   data: {
     *     // ... data to create a WorkExperience
     *   }
     * })
     * 
     */
    create<T extends WorkExperienceCreateArgs>(args: SelectSubset<T, WorkExperienceCreateArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkExperiences.
     * @param {WorkExperienceCreateManyArgs} args - Arguments to create many WorkExperiences.
     * @example
     * // Create many WorkExperiences
     * const workExperience = await prisma.workExperience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkExperienceCreateManyArgs>(args?: SelectSubset<T, WorkExperienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkExperiences and returns the data saved in the database.
     * @param {WorkExperienceCreateManyAndReturnArgs} args - Arguments to create many WorkExperiences.
     * @example
     * // Create many WorkExperiences
     * const workExperience = await prisma.workExperience.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkExperiences and only return the `id`
     * const workExperienceWithIdOnly = await prisma.workExperience.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkExperienceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkExperienceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkExperience.
     * @param {WorkExperienceDeleteArgs} args - Arguments to delete one WorkExperience.
     * @example
     * // Delete one WorkExperience
     * const WorkExperience = await prisma.workExperience.delete({
     *   where: {
     *     // ... filter to delete one WorkExperience
     *   }
     * })
     * 
     */
    delete<T extends WorkExperienceDeleteArgs>(args: SelectSubset<T, WorkExperienceDeleteArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkExperience.
     * @param {WorkExperienceUpdateArgs} args - Arguments to update one WorkExperience.
     * @example
     * // Update one WorkExperience
     * const workExperience = await prisma.workExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkExperienceUpdateArgs>(args: SelectSubset<T, WorkExperienceUpdateArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkExperiences.
     * @param {WorkExperienceDeleteManyArgs} args - Arguments to filter WorkExperiences to delete.
     * @example
     * // Delete a few WorkExperiences
     * const { count } = await prisma.workExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkExperienceDeleteManyArgs>(args?: SelectSubset<T, WorkExperienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkExperiences
     * const workExperience = await prisma.workExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkExperienceUpdateManyArgs>(args: SelectSubset<T, WorkExperienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkExperiences and returns the data updated in the database.
     * @param {WorkExperienceUpdateManyAndReturnArgs} args - Arguments to update many WorkExperiences.
     * @example
     * // Update many WorkExperiences
     * const workExperience = await prisma.workExperience.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkExperiences and only return the `id`
     * const workExperienceWithIdOnly = await prisma.workExperience.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkExperienceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkExperienceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkExperience.
     * @param {WorkExperienceUpsertArgs} args - Arguments to update or create a WorkExperience.
     * @example
     * // Update or create a WorkExperience
     * const workExperience = await prisma.workExperience.upsert({
     *   create: {
     *     // ... data to create a WorkExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkExperience we want to update
     *   }
     * })
     */
    upsert<T extends WorkExperienceUpsertArgs>(args: SelectSubset<T, WorkExperienceUpsertArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceCountArgs} args - Arguments to filter WorkExperiences to count.
     * @example
     * // Count the number of WorkExperiences
     * const count = await prisma.workExperience.count({
     *   where: {
     *     // ... the filter for the WorkExperiences we want to count
     *   }
     * })
    **/
    count<T extends WorkExperienceCountArgs>(
      args?: Subset<T, WorkExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkExperienceAggregateArgs>(args: Subset<T, WorkExperienceAggregateArgs>): Prisma.PrismaPromise<GetWorkExperienceAggregateType<T>>

    /**
     * Group by WorkExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkExperienceGroupByArgs['orderBy'] }
        : { orderBy?: WorkExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkExperience model
   */
  readonly fields: WorkExperienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkExperienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkExperience model
   */
  interface WorkExperienceFieldRefs {
    readonly id: FieldRef<"WorkExperience", 'String'>
    readonly clinic: FieldRef<"WorkExperience", 'String'>
    readonly duration: FieldRef<"WorkExperience", 'String'>
    readonly serviceProviderId: FieldRef<"WorkExperience", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkExperience findUnique
   */
  export type WorkExperienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperience to fetch.
     */
    where: WorkExperienceWhereUniqueInput
  }

  /**
   * WorkExperience findUniqueOrThrow
   */
  export type WorkExperienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperience to fetch.
     */
    where: WorkExperienceWhereUniqueInput
  }

  /**
   * WorkExperience findFirst
   */
  export type WorkExperienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperience to fetch.
     */
    where?: WorkExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkExperiences to fetch.
     */
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkExperiences.
     */
    cursor?: WorkExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkExperiences.
     */
    distinct?: WorkExperienceScalarFieldEnum | WorkExperienceScalarFieldEnum[]
  }

  /**
   * WorkExperience findFirstOrThrow
   */
  export type WorkExperienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperience to fetch.
     */
    where?: WorkExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkExperiences to fetch.
     */
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkExperiences.
     */
    cursor?: WorkExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkExperiences.
     */
    distinct?: WorkExperienceScalarFieldEnum | WorkExperienceScalarFieldEnum[]
  }

  /**
   * WorkExperience findMany
   */
  export type WorkExperienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperiences to fetch.
     */
    where?: WorkExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkExperiences to fetch.
     */
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkExperiences.
     */
    cursor?: WorkExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkExperiences.
     */
    skip?: number
    distinct?: WorkExperienceScalarFieldEnum | WorkExperienceScalarFieldEnum[]
  }

  /**
   * WorkExperience create
   */
  export type WorkExperienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkExperience.
     */
    data: XOR<WorkExperienceCreateInput, WorkExperienceUncheckedCreateInput>
  }

  /**
   * WorkExperience createMany
   */
  export type WorkExperienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkExperiences.
     */
    data: WorkExperienceCreateManyInput | WorkExperienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkExperience createManyAndReturn
   */
  export type WorkExperienceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * The data used to create many WorkExperiences.
     */
    data: WorkExperienceCreateManyInput | WorkExperienceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkExperience update
   */
  export type WorkExperienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkExperience.
     */
    data: XOR<WorkExperienceUpdateInput, WorkExperienceUncheckedUpdateInput>
    /**
     * Choose, which WorkExperience to update.
     */
    where: WorkExperienceWhereUniqueInput
  }

  /**
   * WorkExperience updateMany
   */
  export type WorkExperienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkExperiences.
     */
    data: XOR<WorkExperienceUpdateManyMutationInput, WorkExperienceUncheckedUpdateManyInput>
    /**
     * Filter which WorkExperiences to update
     */
    where?: WorkExperienceWhereInput
    /**
     * Limit how many WorkExperiences to update.
     */
    limit?: number
  }

  /**
   * WorkExperience updateManyAndReturn
   */
  export type WorkExperienceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * The data used to update WorkExperiences.
     */
    data: XOR<WorkExperienceUpdateManyMutationInput, WorkExperienceUncheckedUpdateManyInput>
    /**
     * Filter which WorkExperiences to update
     */
    where?: WorkExperienceWhereInput
    /**
     * Limit how many WorkExperiences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkExperience upsert
   */
  export type WorkExperienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkExperience to update in case it exists.
     */
    where: WorkExperienceWhereUniqueInput
    /**
     * In case the WorkExperience found by the `where` argument doesn't exist, create a new WorkExperience with this data.
     */
    create: XOR<WorkExperienceCreateInput, WorkExperienceUncheckedCreateInput>
    /**
     * In case the WorkExperience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkExperienceUpdateInput, WorkExperienceUncheckedUpdateInput>
  }

  /**
   * WorkExperience delete
   */
  export type WorkExperienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter which WorkExperience to delete.
     */
    where: WorkExperienceWhereUniqueInput
  }

  /**
   * WorkExperience deleteMany
   */
  export type WorkExperienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkExperiences to delete
     */
    where?: WorkExperienceWhereInput
    /**
     * Limit how many WorkExperiences to delete.
     */
    limit?: number
  }

  /**
   * WorkExperience without action
   */
  export type WorkExperienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
  }


  /**
   * Model Award
   */

  export type AggregateAward = {
    _count: AwardCountAggregateOutputType | null
    _min: AwardMinAggregateOutputType | null
    _max: AwardMaxAggregateOutputType | null
  }

  export type AwardMinAggregateOutputType = {
    id: string | null
    date: string | null
    title: string | null
    description: string | null
    serviceProviderId: string | null
  }

  export type AwardMaxAggregateOutputType = {
    id: string | null
    date: string | null
    title: string | null
    description: string | null
    serviceProviderId: string | null
  }

  export type AwardCountAggregateOutputType = {
    id: number
    date: number
    title: number
    description: number
    serviceProviderId: number
    _all: number
  }


  export type AwardMinAggregateInputType = {
    id?: true
    date?: true
    title?: true
    description?: true
    serviceProviderId?: true
  }

  export type AwardMaxAggregateInputType = {
    id?: true
    date?: true
    title?: true
    description?: true
    serviceProviderId?: true
  }

  export type AwardCountAggregateInputType = {
    id?: true
    date?: true
    title?: true
    description?: true
    serviceProviderId?: true
    _all?: true
  }

  export type AwardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Award to aggregate.
     */
    where?: AwardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AwardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Awards
    **/
    _count?: true | AwardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AwardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AwardMaxAggregateInputType
  }

  export type GetAwardAggregateType<T extends AwardAggregateArgs> = {
        [P in keyof T & keyof AggregateAward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAward[P]>
      : GetScalarType<T[P], AggregateAward[P]>
  }




  export type AwardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardWhereInput
    orderBy?: AwardOrderByWithAggregationInput | AwardOrderByWithAggregationInput[]
    by: AwardScalarFieldEnum[] | AwardScalarFieldEnum
    having?: AwardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AwardCountAggregateInputType | true
    _min?: AwardMinAggregateInputType
    _max?: AwardMaxAggregateInputType
  }

  export type AwardGroupByOutputType = {
    id: string
    date: string
    title: string
    description: string
    serviceProviderId: string
    _count: AwardCountAggregateOutputType | null
    _min: AwardMinAggregateOutputType | null
    _max: AwardMaxAggregateOutputType | null
  }

  type GetAwardGroupByPayload<T extends AwardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AwardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AwardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AwardGroupByOutputType[P]>
            : GetScalarType<T[P], AwardGroupByOutputType[P]>
        }
      >
    >


  export type AwardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    title?: boolean
    description?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["award"]>

  export type AwardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    title?: boolean
    description?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["award"]>

  export type AwardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    title?: boolean
    description?: boolean
    serviceProviderId?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["award"]>

  export type AwardSelectScalar = {
    id?: boolean
    date?: boolean
    title?: boolean
    description?: boolean
    serviceProviderId?: boolean
  }

  export type AwardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "title" | "description" | "serviceProviderId", ExtArgs["result"]["award"]>
  export type AwardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type AwardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }
  export type AwardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $AwardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Award"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: string
      title: string
      description: string
      serviceProviderId: string
    }, ExtArgs["result"]["award"]>
    composites: {}
  }

  type AwardGetPayload<S extends boolean | null | undefined | AwardDefaultArgs> = $Result.GetResult<Prisma.$AwardPayload, S>

  type AwardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AwardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AwardCountAggregateInputType | true
    }

  export interface AwardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Award'], meta: { name: 'Award' } }
    /**
     * Find zero or one Award that matches the filter.
     * @param {AwardFindUniqueArgs} args - Arguments to find a Award
     * @example
     * // Get one Award
     * const award = await prisma.award.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AwardFindUniqueArgs>(args: SelectSubset<T, AwardFindUniqueArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Award that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AwardFindUniqueOrThrowArgs} args - Arguments to find a Award
     * @example
     * // Get one Award
     * const award = await prisma.award.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AwardFindUniqueOrThrowArgs>(args: SelectSubset<T, AwardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Award that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardFindFirstArgs} args - Arguments to find a Award
     * @example
     * // Get one Award
     * const award = await prisma.award.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AwardFindFirstArgs>(args?: SelectSubset<T, AwardFindFirstArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Award that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardFindFirstOrThrowArgs} args - Arguments to find a Award
     * @example
     * // Get one Award
     * const award = await prisma.award.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AwardFindFirstOrThrowArgs>(args?: SelectSubset<T, AwardFindFirstOrThrowArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Awards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Awards
     * const awards = await prisma.award.findMany()
     * 
     * // Get first 10 Awards
     * const awards = await prisma.award.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const awardWithIdOnly = await prisma.award.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AwardFindManyArgs>(args?: SelectSubset<T, AwardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Award.
     * @param {AwardCreateArgs} args - Arguments to create a Award.
     * @example
     * // Create one Award
     * const Award = await prisma.award.create({
     *   data: {
     *     // ... data to create a Award
     *   }
     * })
     * 
     */
    create<T extends AwardCreateArgs>(args: SelectSubset<T, AwardCreateArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Awards.
     * @param {AwardCreateManyArgs} args - Arguments to create many Awards.
     * @example
     * // Create many Awards
     * const award = await prisma.award.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AwardCreateManyArgs>(args?: SelectSubset<T, AwardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Awards and returns the data saved in the database.
     * @param {AwardCreateManyAndReturnArgs} args - Arguments to create many Awards.
     * @example
     * // Create many Awards
     * const award = await prisma.award.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Awards and only return the `id`
     * const awardWithIdOnly = await prisma.award.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AwardCreateManyAndReturnArgs>(args?: SelectSubset<T, AwardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Award.
     * @param {AwardDeleteArgs} args - Arguments to delete one Award.
     * @example
     * // Delete one Award
     * const Award = await prisma.award.delete({
     *   where: {
     *     // ... filter to delete one Award
     *   }
     * })
     * 
     */
    delete<T extends AwardDeleteArgs>(args: SelectSubset<T, AwardDeleteArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Award.
     * @param {AwardUpdateArgs} args - Arguments to update one Award.
     * @example
     * // Update one Award
     * const award = await prisma.award.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AwardUpdateArgs>(args: SelectSubset<T, AwardUpdateArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Awards.
     * @param {AwardDeleteManyArgs} args - Arguments to filter Awards to delete.
     * @example
     * // Delete a few Awards
     * const { count } = await prisma.award.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AwardDeleteManyArgs>(args?: SelectSubset<T, AwardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Awards
     * const award = await prisma.award.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AwardUpdateManyArgs>(args: SelectSubset<T, AwardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Awards and returns the data updated in the database.
     * @param {AwardUpdateManyAndReturnArgs} args - Arguments to update many Awards.
     * @example
     * // Update many Awards
     * const award = await prisma.award.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Awards and only return the `id`
     * const awardWithIdOnly = await prisma.award.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AwardUpdateManyAndReturnArgs>(args: SelectSubset<T, AwardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Award.
     * @param {AwardUpsertArgs} args - Arguments to update or create a Award.
     * @example
     * // Update or create a Award
     * const award = await prisma.award.upsert({
     *   create: {
     *     // ... data to create a Award
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Award we want to update
     *   }
     * })
     */
    upsert<T extends AwardUpsertArgs>(args: SelectSubset<T, AwardUpsertArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardCountArgs} args - Arguments to filter Awards to count.
     * @example
     * // Count the number of Awards
     * const count = await prisma.award.count({
     *   where: {
     *     // ... the filter for the Awards we want to count
     *   }
     * })
    **/
    count<T extends AwardCountArgs>(
      args?: Subset<T, AwardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AwardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Award.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AwardAggregateArgs>(args: Subset<T, AwardAggregateArgs>): Prisma.PrismaPromise<GetAwardAggregateType<T>>

    /**
     * Group by Award.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AwardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AwardGroupByArgs['orderBy'] }
        : { orderBy?: AwardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AwardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAwardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Award model
   */
  readonly fields: AwardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Award.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AwardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Award model
   */
  interface AwardFieldRefs {
    readonly id: FieldRef<"Award", 'String'>
    readonly date: FieldRef<"Award", 'String'>
    readonly title: FieldRef<"Award", 'String'>
    readonly description: FieldRef<"Award", 'String'>
    readonly serviceProviderId: FieldRef<"Award", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Award findUnique
   */
  export type AwardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Award to fetch.
     */
    where: AwardWhereUniqueInput
  }

  /**
   * Award findUniqueOrThrow
   */
  export type AwardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Award to fetch.
     */
    where: AwardWhereUniqueInput
  }

  /**
   * Award findFirst
   */
  export type AwardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Award to fetch.
     */
    where?: AwardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Awards.
     */
    cursor?: AwardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Awards.
     */
    distinct?: AwardScalarFieldEnum | AwardScalarFieldEnum[]
  }

  /**
   * Award findFirstOrThrow
   */
  export type AwardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Award to fetch.
     */
    where?: AwardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Awards.
     */
    cursor?: AwardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Awards.
     */
    distinct?: AwardScalarFieldEnum | AwardScalarFieldEnum[]
  }

  /**
   * Award findMany
   */
  export type AwardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Awards to fetch.
     */
    where?: AwardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Awards.
     */
    cursor?: AwardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    distinct?: AwardScalarFieldEnum | AwardScalarFieldEnum[]
  }

  /**
   * Award create
   */
  export type AwardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * The data needed to create a Award.
     */
    data: XOR<AwardCreateInput, AwardUncheckedCreateInput>
  }

  /**
   * Award createMany
   */
  export type AwardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Awards.
     */
    data: AwardCreateManyInput | AwardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Award createManyAndReturn
   */
  export type AwardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * The data used to create many Awards.
     */
    data: AwardCreateManyInput | AwardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Award update
   */
  export type AwardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * The data needed to update a Award.
     */
    data: XOR<AwardUpdateInput, AwardUncheckedUpdateInput>
    /**
     * Choose, which Award to update.
     */
    where: AwardWhereUniqueInput
  }

  /**
   * Award updateMany
   */
  export type AwardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Awards.
     */
    data: XOR<AwardUpdateManyMutationInput, AwardUncheckedUpdateManyInput>
    /**
     * Filter which Awards to update
     */
    where?: AwardWhereInput
    /**
     * Limit how many Awards to update.
     */
    limit?: number
  }

  /**
   * Award updateManyAndReturn
   */
  export type AwardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * The data used to update Awards.
     */
    data: XOR<AwardUpdateManyMutationInput, AwardUncheckedUpdateManyInput>
    /**
     * Filter which Awards to update
     */
    where?: AwardWhereInput
    /**
     * Limit how many Awards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Award upsert
   */
  export type AwardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * The filter to search for the Award to update in case it exists.
     */
    where: AwardWhereUniqueInput
    /**
     * In case the Award found by the `where` argument doesn't exist, create a new Award with this data.
     */
    create: XOR<AwardCreateInput, AwardUncheckedCreateInput>
    /**
     * In case the Award was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AwardUpdateInput, AwardUncheckedUpdateInput>
  }

  /**
   * Award delete
   */
  export type AwardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter which Award to delete.
     */
    where: AwardWhereUniqueInput
  }

  /**
   * Award deleteMany
   */
  export type AwardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Awards to delete
     */
    where?: AwardWhereInput
    /**
     * Limit how many Awards to delete.
     */
    limit?: number
  }

  /**
   * Award without action
   */
  export type AwardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Award
     */
    omit?: AwardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
  }


  /**
   * Model CurrentLocation
   */

  export type AggregateCurrentLocation = {
    _count: CurrentLocationCountAggregateOutputType | null
    _avg: CurrentLocationAvgAggregateOutputType | null
    _sum: CurrentLocationSumAggregateOutputType | null
    _min: CurrentLocationMinAggregateOutputType | null
    _max: CurrentLocationMaxAggregateOutputType | null
  }

  export type CurrentLocationAvgAggregateOutputType = {
    lat: number | null
    long: number | null
  }

  export type CurrentLocationSumAggregateOutputType = {
    lat: number | null
    long: number | null
  }

  export type CurrentLocationMinAggregateOutputType = {
    id: string | null
    lat: number | null
    long: number | null
    appointmentId: string | null
  }

  export type CurrentLocationMaxAggregateOutputType = {
    id: string | null
    lat: number | null
    long: number | null
    appointmentId: string | null
  }

  export type CurrentLocationCountAggregateOutputType = {
    id: number
    lat: number
    long: number
    appointmentId: number
    _all: number
  }


  export type CurrentLocationAvgAggregateInputType = {
    lat?: true
    long?: true
  }

  export type CurrentLocationSumAggregateInputType = {
    lat?: true
    long?: true
  }

  export type CurrentLocationMinAggregateInputType = {
    id?: true
    lat?: true
    long?: true
    appointmentId?: true
  }

  export type CurrentLocationMaxAggregateInputType = {
    id?: true
    lat?: true
    long?: true
    appointmentId?: true
  }

  export type CurrentLocationCountAggregateInputType = {
    id?: true
    lat?: true
    long?: true
    appointmentId?: true
    _all?: true
  }

  export type CurrentLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrentLocation to aggregate.
     */
    where?: CurrentLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentLocations to fetch.
     */
    orderBy?: CurrentLocationOrderByWithRelationInput | CurrentLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrentLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurrentLocations
    **/
    _count?: true | CurrentLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrentLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrentLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrentLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrentLocationMaxAggregateInputType
  }

  export type GetCurrentLocationAggregateType<T extends CurrentLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrentLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrentLocation[P]>
      : GetScalarType<T[P], AggregateCurrentLocation[P]>
  }




  export type CurrentLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrentLocationWhereInput
    orderBy?: CurrentLocationOrderByWithAggregationInput | CurrentLocationOrderByWithAggregationInput[]
    by: CurrentLocationScalarFieldEnum[] | CurrentLocationScalarFieldEnum
    having?: CurrentLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrentLocationCountAggregateInputType | true
    _avg?: CurrentLocationAvgAggregateInputType
    _sum?: CurrentLocationSumAggregateInputType
    _min?: CurrentLocationMinAggregateInputType
    _max?: CurrentLocationMaxAggregateInputType
  }

  export type CurrentLocationGroupByOutputType = {
    id: string
    lat: number
    long: number
    appointmentId: string | null
    _count: CurrentLocationCountAggregateOutputType | null
    _avg: CurrentLocationAvgAggregateOutputType | null
    _sum: CurrentLocationSumAggregateOutputType | null
    _min: CurrentLocationMinAggregateOutputType | null
    _max: CurrentLocationMaxAggregateOutputType | null
  }

  type GetCurrentLocationGroupByPayload<T extends CurrentLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrentLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrentLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrentLocationGroupByOutputType[P]>
            : GetScalarType<T[P], CurrentLocationGroupByOutputType[P]>
        }
      >
    >


  export type CurrentLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    long?: boolean
    appointmentId?: boolean
    appointment?: boolean | CurrentLocation$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["currentLocation"]>

  export type CurrentLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    long?: boolean
    appointmentId?: boolean
    appointment?: boolean | CurrentLocation$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["currentLocation"]>

  export type CurrentLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    long?: boolean
    appointmentId?: boolean
    appointment?: boolean | CurrentLocation$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["currentLocation"]>

  export type CurrentLocationSelectScalar = {
    id?: boolean
    lat?: boolean
    long?: boolean
    appointmentId?: boolean
  }

  export type CurrentLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lat" | "long" | "appointmentId", ExtArgs["result"]["currentLocation"]>
  export type CurrentLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | CurrentLocation$appointmentArgs<ExtArgs>
  }
  export type CurrentLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | CurrentLocation$appointmentArgs<ExtArgs>
  }
  export type CurrentLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | CurrentLocation$appointmentArgs<ExtArgs>
  }

  export type $CurrentLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CurrentLocation"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lat: number
      long: number
      appointmentId: string | null
    }, ExtArgs["result"]["currentLocation"]>
    composites: {}
  }

  type CurrentLocationGetPayload<S extends boolean | null | undefined | CurrentLocationDefaultArgs> = $Result.GetResult<Prisma.$CurrentLocationPayload, S>

  type CurrentLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrentLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrentLocationCountAggregateInputType | true
    }

  export interface CurrentLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CurrentLocation'], meta: { name: 'CurrentLocation' } }
    /**
     * Find zero or one CurrentLocation that matches the filter.
     * @param {CurrentLocationFindUniqueArgs} args - Arguments to find a CurrentLocation
     * @example
     * // Get one CurrentLocation
     * const currentLocation = await prisma.currentLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrentLocationFindUniqueArgs>(args: SelectSubset<T, CurrentLocationFindUniqueArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CurrentLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrentLocationFindUniqueOrThrowArgs} args - Arguments to find a CurrentLocation
     * @example
     * // Get one CurrentLocation
     * const currentLocation = await prisma.currentLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrentLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrentLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurrentLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentLocationFindFirstArgs} args - Arguments to find a CurrentLocation
     * @example
     * // Get one CurrentLocation
     * const currentLocation = await prisma.currentLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrentLocationFindFirstArgs>(args?: SelectSubset<T, CurrentLocationFindFirstArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurrentLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentLocationFindFirstOrThrowArgs} args - Arguments to find a CurrentLocation
     * @example
     * // Get one CurrentLocation
     * const currentLocation = await prisma.currentLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrentLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrentLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CurrentLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurrentLocations
     * const currentLocations = await prisma.currentLocation.findMany()
     * 
     * // Get first 10 CurrentLocations
     * const currentLocations = await prisma.currentLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currentLocationWithIdOnly = await prisma.currentLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrentLocationFindManyArgs>(args?: SelectSubset<T, CurrentLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CurrentLocation.
     * @param {CurrentLocationCreateArgs} args - Arguments to create a CurrentLocation.
     * @example
     * // Create one CurrentLocation
     * const CurrentLocation = await prisma.currentLocation.create({
     *   data: {
     *     // ... data to create a CurrentLocation
     *   }
     * })
     * 
     */
    create<T extends CurrentLocationCreateArgs>(args: SelectSubset<T, CurrentLocationCreateArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CurrentLocations.
     * @param {CurrentLocationCreateManyArgs} args - Arguments to create many CurrentLocations.
     * @example
     * // Create many CurrentLocations
     * const currentLocation = await prisma.currentLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrentLocationCreateManyArgs>(args?: SelectSubset<T, CurrentLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CurrentLocations and returns the data saved in the database.
     * @param {CurrentLocationCreateManyAndReturnArgs} args - Arguments to create many CurrentLocations.
     * @example
     * // Create many CurrentLocations
     * const currentLocation = await prisma.currentLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CurrentLocations and only return the `id`
     * const currentLocationWithIdOnly = await prisma.currentLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrentLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrentLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CurrentLocation.
     * @param {CurrentLocationDeleteArgs} args - Arguments to delete one CurrentLocation.
     * @example
     * // Delete one CurrentLocation
     * const CurrentLocation = await prisma.currentLocation.delete({
     *   where: {
     *     // ... filter to delete one CurrentLocation
     *   }
     * })
     * 
     */
    delete<T extends CurrentLocationDeleteArgs>(args: SelectSubset<T, CurrentLocationDeleteArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CurrentLocation.
     * @param {CurrentLocationUpdateArgs} args - Arguments to update one CurrentLocation.
     * @example
     * // Update one CurrentLocation
     * const currentLocation = await prisma.currentLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrentLocationUpdateArgs>(args: SelectSubset<T, CurrentLocationUpdateArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CurrentLocations.
     * @param {CurrentLocationDeleteManyArgs} args - Arguments to filter CurrentLocations to delete.
     * @example
     * // Delete a few CurrentLocations
     * const { count } = await prisma.currentLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrentLocationDeleteManyArgs>(args?: SelectSubset<T, CurrentLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrentLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurrentLocations
     * const currentLocation = await prisma.currentLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrentLocationUpdateManyArgs>(args: SelectSubset<T, CurrentLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrentLocations and returns the data updated in the database.
     * @param {CurrentLocationUpdateManyAndReturnArgs} args - Arguments to update many CurrentLocations.
     * @example
     * // Update many CurrentLocations
     * const currentLocation = await prisma.currentLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CurrentLocations and only return the `id`
     * const currentLocationWithIdOnly = await prisma.currentLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrentLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrentLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CurrentLocation.
     * @param {CurrentLocationUpsertArgs} args - Arguments to update or create a CurrentLocation.
     * @example
     * // Update or create a CurrentLocation
     * const currentLocation = await prisma.currentLocation.upsert({
     *   create: {
     *     // ... data to create a CurrentLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurrentLocation we want to update
     *   }
     * })
     */
    upsert<T extends CurrentLocationUpsertArgs>(args: SelectSubset<T, CurrentLocationUpsertArgs<ExtArgs>>): Prisma__CurrentLocationClient<$Result.GetResult<Prisma.$CurrentLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CurrentLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentLocationCountArgs} args - Arguments to filter CurrentLocations to count.
     * @example
     * // Count the number of CurrentLocations
     * const count = await prisma.currentLocation.count({
     *   where: {
     *     // ... the filter for the CurrentLocations we want to count
     *   }
     * })
    **/
    count<T extends CurrentLocationCountArgs>(
      args?: Subset<T, CurrentLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrentLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurrentLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrentLocationAggregateArgs>(args: Subset<T, CurrentLocationAggregateArgs>): Prisma.PrismaPromise<GetCurrentLocationAggregateType<T>>

    /**
     * Group by CurrentLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrentLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrentLocationGroupByArgs['orderBy'] }
        : { orderBy?: CurrentLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrentLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrentLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CurrentLocation model
   */
  readonly fields: CurrentLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CurrentLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrentLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends CurrentLocation$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, CurrentLocation$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CurrentLocation model
   */
  interface CurrentLocationFieldRefs {
    readonly id: FieldRef<"CurrentLocation", 'String'>
    readonly lat: FieldRef<"CurrentLocation", 'Float'>
    readonly long: FieldRef<"CurrentLocation", 'Float'>
    readonly appointmentId: FieldRef<"CurrentLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CurrentLocation findUnique
   */
  export type CurrentLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * Filter, which CurrentLocation to fetch.
     */
    where: CurrentLocationWhereUniqueInput
  }

  /**
   * CurrentLocation findUniqueOrThrow
   */
  export type CurrentLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * Filter, which CurrentLocation to fetch.
     */
    where: CurrentLocationWhereUniqueInput
  }

  /**
   * CurrentLocation findFirst
   */
  export type CurrentLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * Filter, which CurrentLocation to fetch.
     */
    where?: CurrentLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentLocations to fetch.
     */
    orderBy?: CurrentLocationOrderByWithRelationInput | CurrentLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrentLocations.
     */
    cursor?: CurrentLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrentLocations.
     */
    distinct?: CurrentLocationScalarFieldEnum | CurrentLocationScalarFieldEnum[]
  }

  /**
   * CurrentLocation findFirstOrThrow
   */
  export type CurrentLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * Filter, which CurrentLocation to fetch.
     */
    where?: CurrentLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentLocations to fetch.
     */
    orderBy?: CurrentLocationOrderByWithRelationInput | CurrentLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrentLocations.
     */
    cursor?: CurrentLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrentLocations.
     */
    distinct?: CurrentLocationScalarFieldEnum | CurrentLocationScalarFieldEnum[]
  }

  /**
   * CurrentLocation findMany
   */
  export type CurrentLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * Filter, which CurrentLocations to fetch.
     */
    where?: CurrentLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentLocations to fetch.
     */
    orderBy?: CurrentLocationOrderByWithRelationInput | CurrentLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurrentLocations.
     */
    cursor?: CurrentLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentLocations.
     */
    skip?: number
    distinct?: CurrentLocationScalarFieldEnum | CurrentLocationScalarFieldEnum[]
  }

  /**
   * CurrentLocation create
   */
  export type CurrentLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a CurrentLocation.
     */
    data: XOR<CurrentLocationCreateInput, CurrentLocationUncheckedCreateInput>
  }

  /**
   * CurrentLocation createMany
   */
  export type CurrentLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CurrentLocations.
     */
    data: CurrentLocationCreateManyInput | CurrentLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CurrentLocation createManyAndReturn
   */
  export type CurrentLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * The data used to create many CurrentLocations.
     */
    data: CurrentLocationCreateManyInput | CurrentLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrentLocation update
   */
  export type CurrentLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a CurrentLocation.
     */
    data: XOR<CurrentLocationUpdateInput, CurrentLocationUncheckedUpdateInput>
    /**
     * Choose, which CurrentLocation to update.
     */
    where: CurrentLocationWhereUniqueInput
  }

  /**
   * CurrentLocation updateMany
   */
  export type CurrentLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CurrentLocations.
     */
    data: XOR<CurrentLocationUpdateManyMutationInput, CurrentLocationUncheckedUpdateManyInput>
    /**
     * Filter which CurrentLocations to update
     */
    where?: CurrentLocationWhereInput
    /**
     * Limit how many CurrentLocations to update.
     */
    limit?: number
  }

  /**
   * CurrentLocation updateManyAndReturn
   */
  export type CurrentLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * The data used to update CurrentLocations.
     */
    data: XOR<CurrentLocationUpdateManyMutationInput, CurrentLocationUncheckedUpdateManyInput>
    /**
     * Filter which CurrentLocations to update
     */
    where?: CurrentLocationWhereInput
    /**
     * Limit how many CurrentLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrentLocation upsert
   */
  export type CurrentLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the CurrentLocation to update in case it exists.
     */
    where: CurrentLocationWhereUniqueInput
    /**
     * In case the CurrentLocation found by the `where` argument doesn't exist, create a new CurrentLocation with this data.
     */
    create: XOR<CurrentLocationCreateInput, CurrentLocationUncheckedCreateInput>
    /**
     * In case the CurrentLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrentLocationUpdateInput, CurrentLocationUncheckedUpdateInput>
  }

  /**
   * CurrentLocation delete
   */
  export type CurrentLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
    /**
     * Filter which CurrentLocation to delete.
     */
    where: CurrentLocationWhereUniqueInput
  }

  /**
   * CurrentLocation deleteMany
   */
  export type CurrentLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrentLocations to delete
     */
    where?: CurrentLocationWhereInput
    /**
     * Limit how many CurrentLocations to delete.
     */
    limit?: number
  }

  /**
   * CurrentLocation.appointment
   */
  export type CurrentLocation$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * CurrentLocation without action
   */
  export type CurrentLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentLocation
     */
    select?: CurrentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentLocation
     */
    omit?: CurrentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentLocationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    actionType: $Enums.ActionType | null
    status: $Enums.Status | null
    ipAddress: string | null
    device: string | null
    performedBy: string | null
    timestamp: Date | null
    userId: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    actionType: $Enums.ActionType | null
    status: $Enums.Status | null
    ipAddress: string | null
    device: string | null
    performedBy: string | null
    timestamp: Date | null
    userId: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entity: number
    entityId: number
    actionType: number
    status: number
    ipAddress: number
    device: number
    performedBy: number
    timestamp: number
    userId: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    actionType?: true
    status?: true
    ipAddress?: true
    device?: true
    performedBy?: true
    timestamp?: true
    userId?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    actionType?: true
    status?: true
    ipAddress?: true
    device?: true
    performedBy?: true
    timestamp?: true
    userId?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    actionType?: true
    status?: true
    ipAddress?: true
    device?: true
    performedBy?: true
    timestamp?: true
    userId?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    entity: string
    entityId: string
    actionType: $Enums.ActionType
    status: $Enums.Status
    ipAddress: string | null
    device: string | null
    performedBy: string
    timestamp: Date
    userId: string
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    actionType?: boolean
    status?: boolean
    ipAddress?: boolean
    device?: boolean
    performedBy?: boolean
    timestamp?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    actionType?: boolean
    status?: boolean
    ipAddress?: boolean
    device?: boolean
    performedBy?: boolean
    timestamp?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    actionType?: boolean
    status?: boolean
    ipAddress?: boolean
    device?: boolean
    performedBy?: boolean
    timestamp?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entity?: boolean
    entityId?: boolean
    actionType?: boolean
    status?: boolean
    ipAddress?: boolean
    device?: boolean
    performedBy?: boolean
    timestamp?: boolean
    userId?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entity" | "entityId" | "actionType" | "status" | "ipAddress" | "device" | "performedBy" | "timestamp" | "userId", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entity: string
      entityId: string
      actionType: $Enums.ActionType
      status: $Enums.Status
      ipAddress: string | null
      device: string | null
      performedBy: string
      timestamp: Date
      userId: string
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly actionType: FieldRef<"AuditLog", 'ActionType'>
    readonly status: FieldRef<"AuditLog", 'Status'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly device: FieldRef<"AuditLog", 'String'>
    readonly performedBy: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
    readonly userId: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    type: string | null
    priority: string | null
    isRead: boolean | null
    expiresAt: Date | null
    isRecurring: boolean | null
    groupId: string | null
    createdAt: Date | null
    relatedEntityId: string | null
    relatedEntity: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    type: string | null
    priority: string | null
    isRead: boolean | null
    expiresAt: Date | null
    isRecurring: boolean | null
    groupId: string | null
    createdAt: Date | null
    relatedEntityId: string | null
    relatedEntity: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    type: number
    priority: number
    isRead: number
    expiresAt: number
    isRecurring: number
    groupId: number
    createdAt: number
    relatedEntityId: number
    relatedEntity: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    expiresAt?: true
    isRecurring?: true
    groupId?: true
    createdAt?: true
    relatedEntityId?: true
    relatedEntity?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    expiresAt?: true
    isRecurring?: true
    groupId?: true
    createdAt?: true
    relatedEntityId?: true
    relatedEntity?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    expiresAt?: true
    isRecurring?: true
    groupId?: true
    createdAt?: true
    relatedEntityId?: true
    relatedEntity?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    message: string
    type: string
    priority: string
    isRead: boolean
    expiresAt: Date | null
    isRecurring: boolean
    groupId: string | null
    createdAt: Date
    relatedEntityId: string | null
    relatedEntity: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    expiresAt?: boolean
    isRecurring?: boolean
    groupId?: boolean
    createdAt?: boolean
    relatedEntityId?: boolean
    relatedEntity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    expiresAt?: boolean
    isRecurring?: boolean
    groupId?: boolean
    createdAt?: boolean
    relatedEntityId?: boolean
    relatedEntity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    expiresAt?: boolean
    isRecurring?: boolean
    groupId?: boolean
    createdAt?: boolean
    relatedEntityId?: boolean
    relatedEntity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    expiresAt?: boolean
    isRecurring?: boolean
    groupId?: boolean
    createdAt?: boolean
    relatedEntityId?: boolean
    relatedEntity?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "message" | "type" | "priority" | "isRead" | "expiresAt" | "isRecurring" | "groupId" | "createdAt" | "relatedEntityId" | "relatedEntity", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      message: string
      type: string
      priority: string
      isRead: boolean
      expiresAt: Date | null
      isRecurring: boolean
      groupId: string | null
      createdAt: Date
      relatedEntityId: string | null
      relatedEntity: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly priority: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
    readonly isRecurring: FieldRef<"Notification", 'Boolean'>
    readonly groupId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly relatedEntityId: FieldRef<"Notification", 'String'>
    readonly relatedEntity: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceProviders?: boolean | Tag$serviceProvidersArgs<ExtArgs>
    appointments?: boolean | Tag$appointmentsArgs<ExtArgs>
    patients?: boolean | Tag$patientsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProviders?: boolean | Tag$serviceProvidersArgs<ExtArgs>
    appointments?: boolean | Tag$appointmentsArgs<ExtArgs>
    patients?: boolean | Tag$patientsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      serviceProviders: Prisma.$ServiceProviderPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProviders<T extends Tag$serviceProvidersArgs<ExtArgs> = {}>(args?: Subset<T, Tag$serviceProvidersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Tag$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patients<T extends Tag$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.serviceProviders
   */
  export type Tag$serviceProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    where?: ServiceProviderWhereInput
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    cursor?: ServiceProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * Tag.appointments
   */
  export type Tag$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Tag.patients
   */
  export type Tag$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    username: 'username',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    phone: 'phone',
    role: 'role',
    gender: 'gender',
    dob: 'dob',
    bloodGroup: 'bloodGroup',
    isActive: 'isActive',
    isVerified: 'isVerified',
    profilePic: 'profilePic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    providerType: 'providerType',
    providerId: 'providerId',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    accessTokenExpires: 'accessTokenExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expires: 'expires',
    sessionToken: 'sessionToken',
    accessToken: 'accessToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationRequestScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationRequestScalarFieldEnum = (typeof VerificationRequestScalarFieldEnum)[keyof typeof VerificationRequestScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    age: 'age',
    userId: 'userId',
    conditions: 'conditions',
    bloodGroup: 'bloodGroup',
    adminPanelId: 'adminPanelId'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AdminPanelScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissions: 'permissions',
    canManageUsers: 'canManageUsers',
    canManagePayments: 'canManagePayments',
    canManageReports: 'canManageReports'
  };

  export type AdminPanelScalarFieldEnum = (typeof AdminPanelScalarFieldEnum)[keyof typeof AdminPanelScalarFieldEnum]


  export const SuperAdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissions: 'permissions',
    status: 'status',
    adminPanelId: 'adminPanelId'
  };

  export type SuperAdminScalarFieldEnum = (typeof SuperAdminScalarFieldEnum)[keyof typeof SuperAdminScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissions: 'permissions',
    canManageProviders: 'canManageProviders',
    canViewAllTransactions: 'canViewAllTransactions',
    canViewAllAppointments: 'canViewAllAppointments',
    adminPanelId: 'adminPanelId',
    superAdminId: 'superAdminId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ServiceProviderScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    name: 'name',
    age: 'age',
    dob: 'dob',
    providerType: 'providerType',
    specialization: 'specialization',
    fee: 'fee',
    experience: 'experience',
    description: 'description',
    service: 'service',
    status: 'status',
    document: 'document',
    registrationNumber: 'registrationNumber',
    clinicInfoId: 'clinicInfoId',
    adminPanelId: 'adminPanelId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type ServiceProviderScalarFieldEnum = (typeof ServiceProviderScalarFieldEnum)[keyof typeof ServiceProviderScalarFieldEnum]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceproviderId: 'serviceproviderId'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const DoctorsAssistantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assignedDoctorId: 'assignedDoctorId'
  };

  export type DoctorsAssistantScalarFieldEnum = (typeof DoctorsAssistantScalarFieldEnum)[keyof typeof DoctorsAssistantScalarFieldEnum]


  export const LabScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    servicesOffered: 'servicesOffered'
  };

  export type LabScalarFieldEnum = (typeof LabScalarFieldEnum)[keyof typeof LabScalarFieldEnum]


  export const HospitalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    servicesOffered: 'servicesOffered'
  };

  export type HospitalScalarFieldEnum = (typeof HospitalScalarFieldEnum)[keyof typeof HospitalScalarFieldEnum]


  export const NursingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    servicesOffered: 'servicesOffered'
  };

  export type NursingScalarFieldEnum = (typeof NursingScalarFieldEnum)[keyof typeof NursingScalarFieldEnum]


  export const AllergyScalarFieldEnum: {
    id: 'id',
    allergen: 'allergen',
    type: 'type',
    severity: 'severity',
    reaction: 'reaction',
    patientId: 'patientId'
  };

  export type AllergyScalarFieldEnum = (typeof AllergyScalarFieldEnum)[keyof typeof AllergyScalarFieldEnum]


  export const MedicationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    dosage: 'dosage',
    frequency: 'frequency',
    duration: 'duration',
    status: 'status',
    prescriptionId: 'prescriptionId'
  };

  export type MedicationScalarFieldEnum = (typeof MedicationScalarFieldEnum)[keyof typeof MedicationScalarFieldEnum]


  export const LabResultScalarFieldEnum: {
    id: 'id',
    testName: 'testName',
    testDate: 'testDate',
    result: 'result',
    referenceRange: 'referenceRange',
    status: 'status',
    patientId: 'patientId',
    serviceProvideId: 'serviceProvideId'
  };

  export type LabResultScalarFieldEnum = (typeof LabResultScalarFieldEnum)[keyof typeof LabResultScalarFieldEnum]


  export const MedicalRecordScalarFieldEnum: {
    id: 'id',
    diagnosis: 'diagnosis',
    prescription: 'prescription',
    notes: 'notes',
    userId: 'userId',
    description: 'description',
    recordId: 'recordId',
    attachment: 'attachment',
    serviceProviderId: 'serviceProviderId'
  };

  export type MedicalRecordScalarFieldEnum = (typeof MedicalRecordScalarFieldEnum)[keyof typeof MedicalRecordScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    notes: 'notes',
    dateIssued: 'dateIssued'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const TherapyPlanScalarFieldEnum: {
    id: 'id',
    planName: 'planName',
    date: 'date',
    type: 'type',
    status: 'status',
    details: 'details',
    patientId: 'patientId',
    serviceProvideId: 'serviceProvideId'
  };

  export type TherapyPlanScalarFieldEnum = (typeof TherapyPlanScalarFieldEnum)[keyof typeof TherapyPlanScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    paymentDate: 'paymentDate',
    refundDetails: 'refundDetails',
    userId: 'userId',
    appointmentId: 'appointmentId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    gatewayTransactionId: 'gatewayTransactionId',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    refundDetails: 'refundDetails',
    paymentId: 'paymentId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceProviderType: 'serviceProviderType',
    serviceProviderId: 'serviceProviderId',
    score: 'score',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const RequestPermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    accessType: 'accessType',
    doctorsAssistantId: 'doctorsAssistantId'
  };

  export type RequestPermissionScalarFieldEnum = (typeof RequestPermissionScalarFieldEnum)[keyof typeof RequestPermissionScalarFieldEnum]


  export const RequestScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    doctorId: 'doctorId'
  };

  export type RequestScalarFieldEnum = (typeof RequestScalarFieldEnum)[keyof typeof RequestScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    service: 'service',
    status: 'status',
    appointmentTime: 'appointmentTime',
    bookedAt: 'bookedAt',
    reason: 'reason',
    isForOthers: 'isForOthers',
    slotId: 'slotId',
    userId: 'userId',
    serviceProviderId: 'serviceProviderId',
    patientId: 'patientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const OthersAppointmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    email: 'email',
    relationship: 'relationship',
    age: 'age',
    gender: 'gender',
    reason: 'reason',
    appointmentId: 'appointmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OthersAppointmentScalarFieldEnum = (typeof OthersAppointmentScalarFieldEnum)[keyof typeof OthersAppointmentScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    date: 'date',
    dayOfWeek: 'dayOfWeek',
    isRecurring: 'isRecurring',
    recurrenceType: 'recurrenceType',
    startTime: 'startTime',
    endTime: 'endTime',
    slotDuration: 'slotDuration',
    location: 'location',
    isAvailable: 'isAvailable',
    service: 'service',
    status: 'status',
    serviceProviderId: 'serviceProviderId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const SlotScalarFieldEnum: {
    id: 'id',
    slotDate: 'slotDate',
    startTime: 'startTime',
    endTime: 'endTime',
    isBooked: 'isBooked',
    scheduleId: 'scheduleId',
    bookedAt: 'bookedAt',
    updatedAt: 'updatedAt'
  };

  export type SlotScalarFieldEnum = (typeof SlotScalarFieldEnum)[keyof typeof SlotScalarFieldEnum]


  export const ClinicInfoScalarFieldEnum: {
    id: 'id',
    clinicName: 'clinicName',
    addressId: 'addressId',
    phone: 'phone',
    images: 'images',
    scheduleId: 'scheduleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicInfoScalarFieldEnum = (typeof ClinicInfoScalarFieldEnum)[keyof typeof ClinicInfoScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    pincode: 'pincode',
    userId: 'userId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const EducationScalarFieldEnum: {
    id: 'id',
    university: 'university',
    degree: 'degree',
    duration: 'duration',
    serviceProviderId: 'serviceProviderId'
  };

  export type EducationScalarFieldEnum = (typeof EducationScalarFieldEnum)[keyof typeof EducationScalarFieldEnum]


  export const WorkExperienceScalarFieldEnum: {
    id: 'id',
    clinic: 'clinic',
    duration: 'duration',
    serviceProviderId: 'serviceProviderId'
  };

  export type WorkExperienceScalarFieldEnum = (typeof WorkExperienceScalarFieldEnum)[keyof typeof WorkExperienceScalarFieldEnum]


  export const AwardScalarFieldEnum: {
    id: 'id',
    date: 'date',
    title: 'title',
    description: 'description',
    serviceProviderId: 'serviceProviderId'
  };

  export type AwardScalarFieldEnum = (typeof AwardScalarFieldEnum)[keyof typeof AwardScalarFieldEnum]


  export const CurrentLocationScalarFieldEnum: {
    id: 'id',
    lat: 'lat',
    long: 'long',
    appointmentId: 'appointmentId'
  };

  export type CurrentLocationScalarFieldEnum = (typeof CurrentLocationScalarFieldEnum)[keyof typeof CurrentLocationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entity: 'entity',
    entityId: 'entityId',
    actionType: 'actionType',
    status: 'status',
    ipAddress: 'ipAddress',
    device: 'device',
    performedBy: 'performedBy',
    timestamp: 'timestamp',
    userId: 'userId'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    type: 'type',
    priority: 'priority',
    isRead: 'isRead',
    expiresAt: 'expiresAt',
    isRecurring: 'isRecurring',
    groupId: 'groupId',
    createdAt: 'createdAt',
    relatedEntityId: 'relatedEntityId',
    relatedEntity: 'relatedEntity'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'BloodGroup'
   */
  export type EnumBloodGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BloodGroup'>
    


  /**
   * Reference to a field of type 'BloodGroup[]'
   */
  export type ListEnumBloodGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BloodGroup[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ActionType[]'
   */
  export type ListEnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType[]'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProviderType'
   */
  export type EnumProviderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProviderType'>
    


  /**
   * Reference to a field of type 'ProviderType[]'
   */
  export type ListEnumProviderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProviderType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Service[]'
   */
  export type ListEnumServiceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Service[]'>
    


  /**
   * Reference to a field of type 'Service'
   */
  export type EnumServiceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Service'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PermissionType'
   */
  export type EnumPermissionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionType'>
    


  /**
   * Reference to a field of type 'PermissionType[]'
   */
  export type ListEnumPermissionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionType[]'>
    


  /**
   * Reference to a field of type 'WeekDay'
   */
  export type EnumWeekDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeekDay'>
    


  /**
   * Reference to a field of type 'WeekDay[]'
   */
  export type ListEnumWeekDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeekDay[]'>
    


  /**
   * Reference to a field of type 'RecurrenceType'
   */
  export type EnumRecurrenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceType'>
    


  /**
   * Reference to a field of type 'RecurrenceType[]'
   */
  export type ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    userId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    bloodGroup?: EnumBloodGroupNullableFilter<"User"> | $Enums.BloodGroup | null
    isActive?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    profilePic?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isDeleted?: BoolFilter<"User"> | boolean
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    patient?: PatientListRelationFilter
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    superAdmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    lab?: XOR<LabNullableScalarRelationFilter, LabWhereInput> | null
    hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null
    nursing?: XOR<NursingNullableScalarRelationFilter, NursingWhereInput> | null
    doctorsAssistant?: XOR<DoctorsAssistantNullableScalarRelationFilter, DoctorsAssistantWhereInput> | null
    payments?: PaymentListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    appointments?: AppointmentListRelationFilter
    ratings?: RatingListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    serviceProvider?: ServiceProviderListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    profilePic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    address?: AddressOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    patient?: PatientOrderByRelationAggregateInput
    doctor?: DoctorOrderByWithRelationInput
    superAdmin?: SuperAdminOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    lab?: LabOrderByWithRelationInput
    hospital?: HospitalOrderByWithRelationInput
    nursing?: NursingOrderByWithRelationInput
    doctorsAssistant?: DoctorsAssistantOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    medicalRecords?: MedicalRecordOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    serviceProvider?: ServiceProviderOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    bloodGroup?: EnumBloodGroupNullableFilter<"User"> | $Enums.BloodGroup | null
    isActive?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    profilePic?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isDeleted?: BoolFilter<"User"> | boolean
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    patient?: PatientListRelationFilter
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    superAdmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    lab?: XOR<LabNullableScalarRelationFilter, LabWhereInput> | null
    hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null
    nursing?: XOR<NursingNullableScalarRelationFilter, NursingWhereInput> | null
    doctorsAssistant?: XOR<DoctorsAssistantNullableScalarRelationFilter, DoctorsAssistantWhereInput> | null
    payments?: PaymentListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    appointments?: AppointmentListRelationFilter
    ratings?: RatingListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    serviceProvider?: ServiceProviderListRelationFilter
  }, "id" | "userId" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    profilePic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    userId?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    dob?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    bloodGroup?: EnumBloodGroupNullableWithAggregatesFilter<"User"> | $Enums.BloodGroup | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    profilePic?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    providerType?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpires?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    accessTokenExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_providerAccountId?: AccountProviderIdProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    providerType?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpires?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    accessTokenExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    providerType?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpires?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    sessionToken?: StringFilter<"Session"> | string
    accessToken?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    accessToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken" | "accessToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    accessToken?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationRequestWhereInput = {
    AND?: VerificationRequestWhereInput | VerificationRequestWhereInput[]
    OR?: VerificationRequestWhereInput[]
    NOT?: VerificationRequestWhereInput | VerificationRequestWhereInput[]
    id?: StringFilter<"VerificationRequest"> | string
    identifier?: StringFilter<"VerificationRequest"> | string
    token?: StringFilter<"VerificationRequest"> | string
    expires?: DateTimeFilter<"VerificationRequest"> | Date | string
    createdAt?: DateTimeFilter<"VerificationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"VerificationRequest"> | Date | string
  }

  export type VerificationRequestOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    identifier_token?: VerificationRequestIdentifierTokenCompoundUniqueInput
    AND?: VerificationRequestWhereInput | VerificationRequestWhereInput[]
    OR?: VerificationRequestWhereInput[]
    NOT?: VerificationRequestWhereInput | VerificationRequestWhereInput[]
    identifier?: StringFilter<"VerificationRequest"> | string
    expires?: DateTimeFilter<"VerificationRequest"> | Date | string
    createdAt?: DateTimeFilter<"VerificationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"VerificationRequest"> | Date | string
  }, "id" | "token" | "identifier_token">

  export type VerificationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationRequestCountOrderByAggregateInput
    _max?: VerificationRequestMaxOrderByAggregateInput
    _min?: VerificationRequestMinOrderByAggregateInput
  }

  export type VerificationRequestScalarWhereWithAggregatesInput = {
    AND?: VerificationRequestScalarWhereWithAggregatesInput | VerificationRequestScalarWhereWithAggregatesInput[]
    OR?: VerificationRequestScalarWhereWithAggregatesInput[]
    NOT?: VerificationRequestScalarWhereWithAggregatesInput | VerificationRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationRequest"> | string
    identifier?: StringWithAggregatesFilter<"VerificationRequest"> | string
    token?: StringWithAggregatesFilter<"VerificationRequest"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationRequest"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VerificationRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerificationRequest"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    age?: StringFilter<"Patient"> | string
    userId?: StringFilter<"Patient"> | string
    conditions?: StringNullableListFilter<"Patient">
    bloodGroup?: EnumBloodGroupFilter<"Patient"> | $Enums.BloodGroup
    adminPanelId?: StringFilter<"Patient"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    allergies?: AllergyListRelationFilter
    treatmentPlans?: TherapyPlanListRelationFilter
    appointment?: AppointmentListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    labResults?: LabResultListRelationFilter
    adminPanel?: XOR<AdminPanelScalarRelationFilter, AdminPanelWhereInput>
    tags?: TagListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    age?: SortOrder
    userId?: SortOrder
    conditions?: SortOrder
    bloodGroup?: SortOrder
    adminPanelId?: SortOrder
    user?: UserOrderByWithRelationInput
    allergies?: AllergyOrderByRelationAggregateInput
    treatmentPlans?: TherapyPlanOrderByRelationAggregateInput
    appointment?: AppointmentOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    labResults?: LabResultOrderByRelationAggregateInput
    adminPanel?: AdminPanelOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    age?: StringFilter<"Patient"> | string
    userId?: StringFilter<"Patient"> | string
    conditions?: StringNullableListFilter<"Patient">
    bloodGroup?: EnumBloodGroupFilter<"Patient"> | $Enums.BloodGroup
    adminPanelId?: StringFilter<"Patient"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    allergies?: AllergyListRelationFilter
    treatmentPlans?: TherapyPlanListRelationFilter
    appointment?: AppointmentListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    labResults?: LabResultListRelationFilter
    adminPanel?: XOR<AdminPanelScalarRelationFilter, AdminPanelWhereInput>
    tags?: TagListRelationFilter
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    age?: SortOrder
    userId?: SortOrder
    conditions?: SortOrder
    bloodGroup?: SortOrder
    adminPanelId?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    age?: StringWithAggregatesFilter<"Patient"> | string
    userId?: StringWithAggregatesFilter<"Patient"> | string
    conditions?: StringNullableListFilter<"Patient">
    bloodGroup?: EnumBloodGroupWithAggregatesFilter<"Patient"> | $Enums.BloodGroup
    adminPanelId?: StringWithAggregatesFilter<"Patient"> | string
  }

  export type AdminPanelWhereInput = {
    AND?: AdminPanelWhereInput | AdminPanelWhereInput[]
    OR?: AdminPanelWhereInput[]
    NOT?: AdminPanelWhereInput | AdminPanelWhereInput[]
    id?: StringFilter<"AdminPanel"> | string
    userId?: StringFilter<"AdminPanel"> | string
    permissions?: EnumActionTypeNullableListFilter<"AdminPanel">
    canManageUsers?: BoolFilter<"AdminPanel"> | boolean
    canManagePayments?: BoolFilter<"AdminPanel"> | boolean
    canManageReports?: BoolFilter<"AdminPanel"> | boolean
    serviceProvider?: ServiceProviderListRelationFilter
    patient?: PatientListRelationFilter
    superAdminId?: SuperAdminListRelationFilter
    adminId?: AdminListRelationFilter
  }

  export type AdminPanelOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    canManageUsers?: SortOrder
    canManagePayments?: SortOrder
    canManageReports?: SortOrder
    serviceProvider?: ServiceProviderOrderByRelationAggregateInput
    patient?: PatientOrderByRelationAggregateInput
    superAdminId?: SuperAdminOrderByRelationAggregateInput
    adminId?: AdminOrderByRelationAggregateInput
  }

  export type AdminPanelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminPanelWhereInput | AdminPanelWhereInput[]
    OR?: AdminPanelWhereInput[]
    NOT?: AdminPanelWhereInput | AdminPanelWhereInput[]
    permissions?: EnumActionTypeNullableListFilter<"AdminPanel">
    canManageUsers?: BoolFilter<"AdminPanel"> | boolean
    canManagePayments?: BoolFilter<"AdminPanel"> | boolean
    canManageReports?: BoolFilter<"AdminPanel"> | boolean
    serviceProvider?: ServiceProviderListRelationFilter
    patient?: PatientListRelationFilter
    superAdminId?: SuperAdminListRelationFilter
    adminId?: AdminListRelationFilter
  }, "id" | "userId">

  export type AdminPanelOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    canManageUsers?: SortOrder
    canManagePayments?: SortOrder
    canManageReports?: SortOrder
    _count?: AdminPanelCountOrderByAggregateInput
    _max?: AdminPanelMaxOrderByAggregateInput
    _min?: AdminPanelMinOrderByAggregateInput
  }

  export type AdminPanelScalarWhereWithAggregatesInput = {
    AND?: AdminPanelScalarWhereWithAggregatesInput | AdminPanelScalarWhereWithAggregatesInput[]
    OR?: AdminPanelScalarWhereWithAggregatesInput[]
    NOT?: AdminPanelScalarWhereWithAggregatesInput | AdminPanelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminPanel"> | string
    userId?: StringWithAggregatesFilter<"AdminPanel"> | string
    permissions?: EnumActionTypeNullableListFilter<"AdminPanel">
    canManageUsers?: BoolWithAggregatesFilter<"AdminPanel"> | boolean
    canManagePayments?: BoolWithAggregatesFilter<"AdminPanel"> | boolean
    canManageReports?: BoolWithAggregatesFilter<"AdminPanel"> | boolean
  }

  export type SuperAdminWhereInput = {
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    id?: StringFilter<"SuperAdmin"> | string
    userId?: StringFilter<"SuperAdmin"> | string
    permissions?: StringNullableListFilter<"SuperAdmin">
    status?: EnumStatusFilter<"SuperAdmin"> | $Enums.Status
    adminPanelId?: StringFilter<"SuperAdmin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    admin?: AdminListRelationFilter
    adminPanel?: XOR<AdminPanelScalarRelationFilter, AdminPanelWhereInput>
  }

  export type SuperAdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    status?: SortOrder
    adminPanelId?: SortOrder
    user?: UserOrderByWithRelationInput
    admin?: AdminOrderByRelationAggregateInput
    adminPanel?: AdminPanelOrderByWithRelationInput
  }

  export type SuperAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    permissions?: StringNullableListFilter<"SuperAdmin">
    status?: EnumStatusFilter<"SuperAdmin"> | $Enums.Status
    adminPanelId?: StringFilter<"SuperAdmin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    admin?: AdminListRelationFilter
    adminPanel?: XOR<AdminPanelScalarRelationFilter, AdminPanelWhereInput>
  }, "id" | "userId">

  export type SuperAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    status?: SortOrder
    adminPanelId?: SortOrder
    _count?: SuperAdminCountOrderByAggregateInput
    _max?: SuperAdminMaxOrderByAggregateInput
    _min?: SuperAdminMinOrderByAggregateInput
  }

  export type SuperAdminScalarWhereWithAggregatesInput = {
    AND?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    OR?: SuperAdminScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuperAdmin"> | string
    userId?: StringWithAggregatesFilter<"SuperAdmin"> | string
    permissions?: StringNullableListFilter<"SuperAdmin">
    status?: EnumStatusWithAggregatesFilter<"SuperAdmin"> | $Enums.Status
    adminPanelId?: StringWithAggregatesFilter<"SuperAdmin"> | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    canManageProviders?: BoolFilter<"Admin"> | boolean
    canViewAllTransactions?: BoolFilter<"Admin"> | boolean
    canViewAllAppointments?: BoolFilter<"Admin"> | boolean
    adminPanelId?: StringFilter<"Admin"> | string
    superAdminId?: StringFilter<"Admin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    adminPanel?: XOR<AdminPanelScalarRelationFilter, AdminPanelWhereInput>
    superAdmin?: XOR<SuperAdminScalarRelationFilter, SuperAdminWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    canManageProviders?: SortOrder
    canViewAllTransactions?: SortOrder
    canViewAllAppointments?: SortOrder
    adminPanelId?: SortOrder
    superAdminId?: SortOrder
    user?: UserOrderByWithRelationInput
    adminPanel?: AdminPanelOrderByWithRelationInput
    superAdmin?: SuperAdminOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    permissions?: StringNullableListFilter<"Admin">
    canManageProviders?: BoolFilter<"Admin"> | boolean
    canViewAllTransactions?: BoolFilter<"Admin"> | boolean
    canViewAllAppointments?: BoolFilter<"Admin"> | boolean
    adminPanelId?: StringFilter<"Admin"> | string
    superAdminId?: StringFilter<"Admin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    adminPanel?: XOR<AdminPanelScalarRelationFilter, AdminPanelWhereInput>
    superAdmin?: XOR<SuperAdminScalarRelationFilter, SuperAdminWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    canManageProviders?: SortOrder
    canViewAllTransactions?: SortOrder
    canViewAllAppointments?: SortOrder
    adminPanelId?: SortOrder
    superAdminId?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    canManageProviders?: BoolWithAggregatesFilter<"Admin"> | boolean
    canViewAllTransactions?: BoolWithAggregatesFilter<"Admin"> | boolean
    canViewAllAppointments?: BoolWithAggregatesFilter<"Admin"> | boolean
    adminPanelId?: StringWithAggregatesFilter<"Admin"> | string
    superAdminId?: StringWithAggregatesFilter<"Admin"> | string
  }

  export type ServiceProviderWhereInput = {
    AND?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    OR?: ServiceProviderWhereInput[]
    NOT?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    id?: StringFilter<"ServiceProvider"> | string
    providerId?: StringFilter<"ServiceProvider"> | string
    name?: StringFilter<"ServiceProvider"> | string
    age?: IntNullableFilter<"ServiceProvider"> | number | null
    dob?: DateTimeNullableFilter<"ServiceProvider"> | Date | string | null
    providerType?: EnumProviderTypeFilter<"ServiceProvider"> | $Enums.ProviderType
    specialization?: StringNullableListFilter<"ServiceProvider">
    fee?: FloatNullableFilter<"ServiceProvider"> | number | null
    experience?: IntNullableFilter<"ServiceProvider"> | number | null
    description?: StringNullableFilter<"ServiceProvider"> | string | null
    service?: EnumServiceNullableListFilter<"ServiceProvider">
    status?: EnumStatusFilter<"ServiceProvider"> | $Enums.Status
    document?: StringNullableFilter<"ServiceProvider"> | string | null
    registrationNumber?: StringNullableFilter<"ServiceProvider"> | string | null
    clinicInfoId?: StringNullableFilter<"ServiceProvider"> | string | null
    adminPanelId?: StringNullableFilter<"ServiceProvider"> | string | null
    userId?: StringFilter<"ServiceProvider"> | string
    createdAt?: DateTimeFilter<"ServiceProvider"> | Date | string
    schedule?: ScheduleListRelationFilter
    appointment?: AppointmentListRelationFilter
    education?: EducationListRelationFilter
    workExperience?: WorkExperienceListRelationFilter
    awards?: AwardListRelationFilter
    labResults?: LabResultListRelationFilter
    therapyPlans?: TherapyPlanListRelationFilter
    rating?: RatingListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    doctor?: DoctorListRelationFilter
    clinicInfo?: XOR<ClinicInfoNullableScalarRelationFilter, ClinicInfoWhereInput> | null
    adminPanel?: XOR<AdminPanelNullableScalarRelationFilter, AdminPanelWhereInput> | null
    tags?: TagListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ServiceProviderOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    age?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    providerType?: SortOrder
    specialization?: SortOrder
    fee?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    service?: SortOrder
    status?: SortOrder
    document?: SortOrderInput | SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    clinicInfoId?: SortOrderInput | SortOrder
    adminPanelId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    schedule?: ScheduleOrderByRelationAggregateInput
    appointment?: AppointmentOrderByRelationAggregateInput
    education?: EducationOrderByRelationAggregateInput
    workExperience?: WorkExperienceOrderByRelationAggregateInput
    awards?: AwardOrderByRelationAggregateInput
    labResults?: LabResultOrderByRelationAggregateInput
    therapyPlans?: TherapyPlanOrderByRelationAggregateInput
    rating?: RatingOrderByRelationAggregateInput
    medicalRecords?: MedicalRecordOrderByRelationAggregateInput
    doctor?: DoctorOrderByRelationAggregateInput
    clinicInfo?: ClinicInfoOrderByWithRelationInput
    adminPanel?: AdminPanelOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type ServiceProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId?: string
    userId?: string
    AND?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    OR?: ServiceProviderWhereInput[]
    NOT?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    name?: StringFilter<"ServiceProvider"> | string
    age?: IntNullableFilter<"ServiceProvider"> | number | null
    dob?: DateTimeNullableFilter<"ServiceProvider"> | Date | string | null
    providerType?: EnumProviderTypeFilter<"ServiceProvider"> | $Enums.ProviderType
    specialization?: StringNullableListFilter<"ServiceProvider">
    fee?: FloatNullableFilter<"ServiceProvider"> | number | null
    experience?: IntNullableFilter<"ServiceProvider"> | number | null
    description?: StringNullableFilter<"ServiceProvider"> | string | null
    service?: EnumServiceNullableListFilter<"ServiceProvider">
    status?: EnumStatusFilter<"ServiceProvider"> | $Enums.Status
    document?: StringNullableFilter<"ServiceProvider"> | string | null
    registrationNumber?: StringNullableFilter<"ServiceProvider"> | string | null
    clinicInfoId?: StringNullableFilter<"ServiceProvider"> | string | null
    adminPanelId?: StringNullableFilter<"ServiceProvider"> | string | null
    createdAt?: DateTimeFilter<"ServiceProvider"> | Date | string
    schedule?: ScheduleListRelationFilter
    appointment?: AppointmentListRelationFilter
    education?: EducationListRelationFilter
    workExperience?: WorkExperienceListRelationFilter
    awards?: AwardListRelationFilter
    labResults?: LabResultListRelationFilter
    therapyPlans?: TherapyPlanListRelationFilter
    rating?: RatingListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    doctor?: DoctorListRelationFilter
    clinicInfo?: XOR<ClinicInfoNullableScalarRelationFilter, ClinicInfoWhereInput> | null
    adminPanel?: XOR<AdminPanelNullableScalarRelationFilter, AdminPanelWhereInput> | null
    tags?: TagListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId" | "userId">

  export type ServiceProviderOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    age?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    providerType?: SortOrder
    specialization?: SortOrder
    fee?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    service?: SortOrder
    status?: SortOrder
    document?: SortOrderInput | SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    clinicInfoId?: SortOrderInput | SortOrder
    adminPanelId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceProviderCountOrderByAggregateInput
    _avg?: ServiceProviderAvgOrderByAggregateInput
    _max?: ServiceProviderMaxOrderByAggregateInput
    _min?: ServiceProviderMinOrderByAggregateInput
    _sum?: ServiceProviderSumOrderByAggregateInput
  }

  export type ServiceProviderScalarWhereWithAggregatesInput = {
    AND?: ServiceProviderScalarWhereWithAggregatesInput | ServiceProviderScalarWhereWithAggregatesInput[]
    OR?: ServiceProviderScalarWhereWithAggregatesInput[]
    NOT?: ServiceProviderScalarWhereWithAggregatesInput | ServiceProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceProvider"> | string
    providerId?: StringWithAggregatesFilter<"ServiceProvider"> | string
    name?: StringWithAggregatesFilter<"ServiceProvider"> | string
    age?: IntNullableWithAggregatesFilter<"ServiceProvider"> | number | null
    dob?: DateTimeNullableWithAggregatesFilter<"ServiceProvider"> | Date | string | null
    providerType?: EnumProviderTypeWithAggregatesFilter<"ServiceProvider"> | $Enums.ProviderType
    specialization?: StringNullableListFilter<"ServiceProvider">
    fee?: FloatNullableWithAggregatesFilter<"ServiceProvider"> | number | null
    experience?: IntNullableWithAggregatesFilter<"ServiceProvider"> | number | null
    description?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    service?: EnumServiceNullableListFilter<"ServiceProvider">
    status?: EnumStatusWithAggregatesFilter<"ServiceProvider"> | $Enums.Status
    document?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    registrationNumber?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    clinicInfoId?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    adminPanelId?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    userId?: StringWithAggregatesFilter<"ServiceProvider"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceProvider"> | Date | string
  }

  export type DoctorWhereInput = {
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    id?: StringFilter<"Doctor"> | string
    userId?: StringFilter<"Doctor"> | string
    serviceproviderId?: StringFilter<"Doctor"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    prescriptions?: PrescriptionListRelationFilter
    assistants?: DoctorsAssistantListRelationFilter
    requests?: RequestListRelationFilter
    serviceprovider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceproviderId?: SortOrder
    user?: UserOrderByWithRelationInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    assistants?: DoctorsAssistantOrderByRelationAggregateInput
    requests?: RequestOrderByRelationAggregateInput
    serviceprovider?: ServiceProviderOrderByWithRelationInput
  }

  export type DoctorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    serviceproviderId?: StringFilter<"Doctor"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    prescriptions?: PrescriptionListRelationFilter
    assistants?: DoctorsAssistantListRelationFilter
    requests?: RequestListRelationFilter
    serviceprovider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "id" | "userId">

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceproviderId?: SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    OR?: DoctorScalarWhereWithAggregatesInput[]
    NOT?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Doctor"> | string
    userId?: StringWithAggregatesFilter<"Doctor"> | string
    serviceproviderId?: StringWithAggregatesFilter<"Doctor"> | string
  }

  export type DoctorsAssistantWhereInput = {
    AND?: DoctorsAssistantWhereInput | DoctorsAssistantWhereInput[]
    OR?: DoctorsAssistantWhereInput[]
    NOT?: DoctorsAssistantWhereInput | DoctorsAssistantWhereInput[]
    id?: StringFilter<"DoctorsAssistant"> | string
    userId?: StringFilter<"DoctorsAssistant"> | string
    assignedDoctorId?: StringFilter<"DoctorsAssistant"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    requestPermissions?: RequestPermissionListRelationFilter
  }

  export type DoctorsAssistantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedDoctorId?: SortOrder
    user?: UserOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    requestPermissions?: RequestPermissionOrderByRelationAggregateInput
  }

  export type DoctorsAssistantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DoctorsAssistantWhereInput | DoctorsAssistantWhereInput[]
    OR?: DoctorsAssistantWhereInput[]
    NOT?: DoctorsAssistantWhereInput | DoctorsAssistantWhereInput[]
    assignedDoctorId?: StringFilter<"DoctorsAssistant"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    requestPermissions?: RequestPermissionListRelationFilter
  }, "id" | "userId">

  export type DoctorsAssistantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedDoctorId?: SortOrder
    _count?: DoctorsAssistantCountOrderByAggregateInput
    _max?: DoctorsAssistantMaxOrderByAggregateInput
    _min?: DoctorsAssistantMinOrderByAggregateInput
  }

  export type DoctorsAssistantScalarWhereWithAggregatesInput = {
    AND?: DoctorsAssistantScalarWhereWithAggregatesInput | DoctorsAssistantScalarWhereWithAggregatesInput[]
    OR?: DoctorsAssistantScalarWhereWithAggregatesInput[]
    NOT?: DoctorsAssistantScalarWhereWithAggregatesInput | DoctorsAssistantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DoctorsAssistant"> | string
    userId?: StringWithAggregatesFilter<"DoctorsAssistant"> | string
    assignedDoctorId?: StringWithAggregatesFilter<"DoctorsAssistant"> | string
  }

  export type LabWhereInput = {
    AND?: LabWhereInput | LabWhereInput[]
    OR?: LabWhereInput[]
    NOT?: LabWhereInput | LabWhereInput[]
    id?: StringFilter<"Lab"> | string
    userId?: StringFilter<"Lab"> | string
    servicesOffered?: StringNullableListFilter<"Lab">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LabOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LabWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LabWhereInput | LabWhereInput[]
    OR?: LabWhereInput[]
    NOT?: LabWhereInput | LabWhereInput[]
    servicesOffered?: StringNullableListFilter<"Lab">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type LabOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
    _count?: LabCountOrderByAggregateInput
    _max?: LabMaxOrderByAggregateInput
    _min?: LabMinOrderByAggregateInput
  }

  export type LabScalarWhereWithAggregatesInput = {
    AND?: LabScalarWhereWithAggregatesInput | LabScalarWhereWithAggregatesInput[]
    OR?: LabScalarWhereWithAggregatesInput[]
    NOT?: LabScalarWhereWithAggregatesInput | LabScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lab"> | string
    userId?: StringWithAggregatesFilter<"Lab"> | string
    servicesOffered?: StringNullableListFilter<"Lab">
  }

  export type HospitalWhereInput = {
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    id?: StringFilter<"Hospital"> | string
    userId?: StringFilter<"Hospital"> | string
    servicesOffered?: StringNullableListFilter<"Hospital">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type HospitalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type HospitalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    servicesOffered?: StringNullableListFilter<"Hospital">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type HospitalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
    _count?: HospitalCountOrderByAggregateInput
    _max?: HospitalMaxOrderByAggregateInput
    _min?: HospitalMinOrderByAggregateInput
  }

  export type HospitalScalarWhereWithAggregatesInput = {
    AND?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    OR?: HospitalScalarWhereWithAggregatesInput[]
    NOT?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hospital"> | string
    userId?: StringWithAggregatesFilter<"Hospital"> | string
    servicesOffered?: StringNullableListFilter<"Hospital">
  }

  export type NursingWhereInput = {
    AND?: NursingWhereInput | NursingWhereInput[]
    OR?: NursingWhereInput[]
    NOT?: NursingWhereInput | NursingWhereInput[]
    id?: StringFilter<"Nursing"> | string
    userId?: StringFilter<"Nursing"> | string
    servicesOffered?: StringNullableListFilter<"Nursing">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NursingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NursingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NursingWhereInput | NursingWhereInput[]
    OR?: NursingWhereInput[]
    NOT?: NursingWhereInput | NursingWhereInput[]
    servicesOffered?: StringNullableListFilter<"Nursing">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NursingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
    _count?: NursingCountOrderByAggregateInput
    _max?: NursingMaxOrderByAggregateInput
    _min?: NursingMinOrderByAggregateInput
  }

  export type NursingScalarWhereWithAggregatesInput = {
    AND?: NursingScalarWhereWithAggregatesInput | NursingScalarWhereWithAggregatesInput[]
    OR?: NursingScalarWhereWithAggregatesInput[]
    NOT?: NursingScalarWhereWithAggregatesInput | NursingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Nursing"> | string
    userId?: StringWithAggregatesFilter<"Nursing"> | string
    servicesOffered?: StringNullableListFilter<"Nursing">
  }

  export type AllergyWhereInput = {
    AND?: AllergyWhereInput | AllergyWhereInput[]
    OR?: AllergyWhereInput[]
    NOT?: AllergyWhereInput | AllergyWhereInput[]
    id?: StringFilter<"Allergy"> | string
    allergen?: StringFilter<"Allergy"> | string
    type?: StringFilter<"Allergy"> | string
    severity?: StringFilter<"Allergy"> | string
    reaction?: StringFilter<"Allergy"> | string
    patientId?: StringFilter<"Allergy"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type AllergyOrderByWithRelationInput = {
    id?: SortOrder
    allergen?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    reaction?: SortOrder
    patientId?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type AllergyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AllergyWhereInput | AllergyWhereInput[]
    OR?: AllergyWhereInput[]
    NOT?: AllergyWhereInput | AllergyWhereInput[]
    allergen?: StringFilter<"Allergy"> | string
    type?: StringFilter<"Allergy"> | string
    severity?: StringFilter<"Allergy"> | string
    reaction?: StringFilter<"Allergy"> | string
    patientId?: StringFilter<"Allergy"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type AllergyOrderByWithAggregationInput = {
    id?: SortOrder
    allergen?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    reaction?: SortOrder
    patientId?: SortOrder
    _count?: AllergyCountOrderByAggregateInput
    _max?: AllergyMaxOrderByAggregateInput
    _min?: AllergyMinOrderByAggregateInput
  }

  export type AllergyScalarWhereWithAggregatesInput = {
    AND?: AllergyScalarWhereWithAggregatesInput | AllergyScalarWhereWithAggregatesInput[]
    OR?: AllergyScalarWhereWithAggregatesInput[]
    NOT?: AllergyScalarWhereWithAggregatesInput | AllergyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Allergy"> | string
    allergen?: StringWithAggregatesFilter<"Allergy"> | string
    type?: StringWithAggregatesFilter<"Allergy"> | string
    severity?: StringWithAggregatesFilter<"Allergy"> | string
    reaction?: StringWithAggregatesFilter<"Allergy"> | string
    patientId?: StringWithAggregatesFilter<"Allergy"> | string
  }

  export type MedicationWhereInput = {
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    id?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    dosage?: StringFilter<"Medication"> | string
    frequency?: StringFilter<"Medication"> | string
    duration?: StringFilter<"Medication"> | string
    status?: StringFilter<"Medication"> | string
    prescriptionId?: StringNullableFilter<"Medication"> | string | null
    prescription?: XOR<PrescriptionNullableScalarRelationFilter, PrescriptionWhereInput> | null
  }

  export type MedicationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
  }

  export type MedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    name?: StringFilter<"Medication"> | string
    dosage?: StringFilter<"Medication"> | string
    frequency?: StringFilter<"Medication"> | string
    duration?: StringFilter<"Medication"> | string
    status?: StringFilter<"Medication"> | string
    prescriptionId?: StringNullableFilter<"Medication"> | string | null
    prescription?: XOR<PrescriptionNullableScalarRelationFilter, PrescriptionWhereInput> | null
  }, "id">

  export type MedicationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    _count?: MedicationCountOrderByAggregateInput
    _max?: MedicationMaxOrderByAggregateInput
    _min?: MedicationMinOrderByAggregateInput
  }

  export type MedicationScalarWhereWithAggregatesInput = {
    AND?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    OR?: MedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medication"> | string
    name?: StringWithAggregatesFilter<"Medication"> | string
    dosage?: StringWithAggregatesFilter<"Medication"> | string
    frequency?: StringWithAggregatesFilter<"Medication"> | string
    duration?: StringWithAggregatesFilter<"Medication"> | string
    status?: StringWithAggregatesFilter<"Medication"> | string
    prescriptionId?: StringNullableWithAggregatesFilter<"Medication"> | string | null
  }

  export type LabResultWhereInput = {
    AND?: LabResultWhereInput | LabResultWhereInput[]
    OR?: LabResultWhereInput[]
    NOT?: LabResultWhereInput | LabResultWhereInput[]
    id?: StringFilter<"LabResult"> | string
    testName?: StringFilter<"LabResult"> | string
    testDate?: DateTimeFilter<"LabResult"> | Date | string
    result?: StringFilter<"LabResult"> | string
    referenceRange?: StringFilter<"LabResult"> | string
    status?: StringFilter<"LabResult"> | string
    patientId?: StringFilter<"LabResult"> | string
    serviceProvideId?: StringFilter<"LabResult"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type LabResultOrderByWithRelationInput = {
    id?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    result?: SortOrder
    referenceRange?: SortOrder
    status?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
    patient?: PatientOrderByWithRelationInput
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type LabResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabResultWhereInput | LabResultWhereInput[]
    OR?: LabResultWhereInput[]
    NOT?: LabResultWhereInput | LabResultWhereInput[]
    testName?: StringFilter<"LabResult"> | string
    testDate?: DateTimeFilter<"LabResult"> | Date | string
    result?: StringFilter<"LabResult"> | string
    referenceRange?: StringFilter<"LabResult"> | string
    status?: StringFilter<"LabResult"> | string
    patientId?: StringFilter<"LabResult"> | string
    serviceProvideId?: StringFilter<"LabResult"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "id">

  export type LabResultOrderByWithAggregationInput = {
    id?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    result?: SortOrder
    referenceRange?: SortOrder
    status?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
    _count?: LabResultCountOrderByAggregateInput
    _max?: LabResultMaxOrderByAggregateInput
    _min?: LabResultMinOrderByAggregateInput
  }

  export type LabResultScalarWhereWithAggregatesInput = {
    AND?: LabResultScalarWhereWithAggregatesInput | LabResultScalarWhereWithAggregatesInput[]
    OR?: LabResultScalarWhereWithAggregatesInput[]
    NOT?: LabResultScalarWhereWithAggregatesInput | LabResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabResult"> | string
    testName?: StringWithAggregatesFilter<"LabResult"> | string
    testDate?: DateTimeWithAggregatesFilter<"LabResult"> | Date | string
    result?: StringWithAggregatesFilter<"LabResult"> | string
    referenceRange?: StringWithAggregatesFilter<"LabResult"> | string
    status?: StringWithAggregatesFilter<"LabResult"> | string
    patientId?: StringWithAggregatesFilter<"LabResult"> | string
    serviceProvideId?: StringWithAggregatesFilter<"LabResult"> | string
  }

  export type MedicalRecordWhereInput = {
    AND?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    OR?: MedicalRecordWhereInput[]
    NOT?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    id?: StringFilter<"MedicalRecord"> | string
    diagnosis?: StringFilter<"MedicalRecord"> | string
    prescription?: StringFilter<"MedicalRecord"> | string
    notes?: StringNullableFilter<"MedicalRecord"> | string | null
    userId?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    recordId?: StringNullableFilter<"MedicalRecord"> | string | null
    attachment?: StringNullableFilter<"MedicalRecord"> | string | null
    serviceProviderId?: StringNullableFilter<"MedicalRecord"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceProvider?: XOR<ServiceProviderNullableScalarRelationFilter, ServiceProviderWhereInput> | null
  }

  export type MedicalRecordOrderByWithRelationInput = {
    id?: SortOrder
    diagnosis?: SortOrder
    prescription?: SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    description?: SortOrderInput | SortOrder
    recordId?: SortOrderInput | SortOrder
    attachment?: SortOrderInput | SortOrder
    serviceProviderId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type MedicalRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    OR?: MedicalRecordWhereInput[]
    NOT?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    diagnosis?: StringFilter<"MedicalRecord"> | string
    prescription?: StringFilter<"MedicalRecord"> | string
    notes?: StringNullableFilter<"MedicalRecord"> | string | null
    userId?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    recordId?: StringNullableFilter<"MedicalRecord"> | string | null
    attachment?: StringNullableFilter<"MedicalRecord"> | string | null
    serviceProviderId?: StringNullableFilter<"MedicalRecord"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceProvider?: XOR<ServiceProviderNullableScalarRelationFilter, ServiceProviderWhereInput> | null
  }, "id">

  export type MedicalRecordOrderByWithAggregationInput = {
    id?: SortOrder
    diagnosis?: SortOrder
    prescription?: SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    description?: SortOrderInput | SortOrder
    recordId?: SortOrderInput | SortOrder
    attachment?: SortOrderInput | SortOrder
    serviceProviderId?: SortOrderInput | SortOrder
    _count?: MedicalRecordCountOrderByAggregateInput
    _max?: MedicalRecordMaxOrderByAggregateInput
    _min?: MedicalRecordMinOrderByAggregateInput
  }

  export type MedicalRecordScalarWhereWithAggregatesInput = {
    AND?: MedicalRecordScalarWhereWithAggregatesInput | MedicalRecordScalarWhereWithAggregatesInput[]
    OR?: MedicalRecordScalarWhereWithAggregatesInput[]
    NOT?: MedicalRecordScalarWhereWithAggregatesInput | MedicalRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalRecord"> | string
    diagnosis?: StringWithAggregatesFilter<"MedicalRecord"> | string
    prescription?: StringWithAggregatesFilter<"MedicalRecord"> | string
    notes?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    userId?: StringWithAggregatesFilter<"MedicalRecord"> | string
    description?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    recordId?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    attachment?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    serviceProviderId?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: StringFilter<"Prescription"> | string
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    notes?: StringNullableFilter<"Prescription"> | string | null
    dateIssued?: DateTimeFilter<"Prescription"> | Date | string
    medications?: MedicationListRelationFilter
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrderInput | SortOrder
    dateIssued?: SortOrder
    medications?: MedicationOrderByRelationAggregateInput
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    notes?: StringNullableFilter<"Prescription"> | string | null
    dateIssued?: DateTimeFilter<"Prescription"> | Date | string
    medications?: MedicationListRelationFilter
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
  }, "id">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrderInput | SortOrder
    dateIssued?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prescription"> | string
    patientId?: StringWithAggregatesFilter<"Prescription"> | string
    doctorId?: StringWithAggregatesFilter<"Prescription"> | string
    notes?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    dateIssued?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
  }

  export type TherapyPlanWhereInput = {
    AND?: TherapyPlanWhereInput | TherapyPlanWhereInput[]
    OR?: TherapyPlanWhereInput[]
    NOT?: TherapyPlanWhereInput | TherapyPlanWhereInput[]
    id?: StringFilter<"TherapyPlan"> | string
    planName?: StringFilter<"TherapyPlan"> | string
    date?: DateTimeFilter<"TherapyPlan"> | Date | string
    type?: StringFilter<"TherapyPlan"> | string
    status?: StringFilter<"TherapyPlan"> | string
    details?: StringFilter<"TherapyPlan"> | string
    patientId?: StringFilter<"TherapyPlan"> | string
    serviceProvideId?: StringFilter<"TherapyPlan"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type TherapyPlanOrderByWithRelationInput = {
    id?: SortOrder
    planName?: SortOrder
    date?: SortOrder
    type?: SortOrder
    status?: SortOrder
    details?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
    patient?: PatientOrderByWithRelationInput
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type TherapyPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TherapyPlanWhereInput | TherapyPlanWhereInput[]
    OR?: TherapyPlanWhereInput[]
    NOT?: TherapyPlanWhereInput | TherapyPlanWhereInput[]
    planName?: StringFilter<"TherapyPlan"> | string
    date?: DateTimeFilter<"TherapyPlan"> | Date | string
    type?: StringFilter<"TherapyPlan"> | string
    status?: StringFilter<"TherapyPlan"> | string
    details?: StringFilter<"TherapyPlan"> | string
    patientId?: StringFilter<"TherapyPlan"> | string
    serviceProvideId?: StringFilter<"TherapyPlan"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "id">

  export type TherapyPlanOrderByWithAggregationInput = {
    id?: SortOrder
    planName?: SortOrder
    date?: SortOrder
    type?: SortOrder
    status?: SortOrder
    details?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
    _count?: TherapyPlanCountOrderByAggregateInput
    _max?: TherapyPlanMaxOrderByAggregateInput
    _min?: TherapyPlanMinOrderByAggregateInput
  }

  export type TherapyPlanScalarWhereWithAggregatesInput = {
    AND?: TherapyPlanScalarWhereWithAggregatesInput | TherapyPlanScalarWhereWithAggregatesInput[]
    OR?: TherapyPlanScalarWhereWithAggregatesInput[]
    NOT?: TherapyPlanScalarWhereWithAggregatesInput | TherapyPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TherapyPlan"> | string
    planName?: StringWithAggregatesFilter<"TherapyPlan"> | string
    date?: DateTimeWithAggregatesFilter<"TherapyPlan"> | Date | string
    type?: StringWithAggregatesFilter<"TherapyPlan"> | string
    status?: StringWithAggregatesFilter<"TherapyPlan"> | string
    details?: StringWithAggregatesFilter<"TherapyPlan"> | string
    patientId?: StringWithAggregatesFilter<"TherapyPlan"> | string
    serviceProvideId?: StringWithAggregatesFilter<"TherapyPlan"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    transactionId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: EnumStatusFilter<"Payment"> | $Enums.Status
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    refundDetails?: StringNullableFilter<"Payment"> | string | null
    userId?: StringFilter<"Payment"> | string
    appointmentId?: StringFilter<"Payment"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    transaction?: TransactionListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    refundDetails?: SortOrderInput | SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
    user?: UserOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    transaction?: TransactionOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    status?: EnumStatusFilter<"Payment"> | $Enums.Status
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    refundDetails?: StringNullableFilter<"Payment"> | string | null
    userId?: StringFilter<"Payment"> | string
    appointmentId?: StringFilter<"Payment"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    transaction?: TransactionListRelationFilter
  }, "id" | "transactionId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    refundDetails?: SortOrderInput | SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    status?: EnumStatusWithAggregatesFilter<"Payment"> | $Enums.Status
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    refundDetails?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    userId?: StringWithAggregatesFilter<"Payment"> | string
    appointmentId?: StringWithAggregatesFilter<"Payment"> | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    gatewayTransactionId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: EnumStatusFilter<"Transaction"> | $Enums.Status
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    refundDetails?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringFilter<"Transaction"> | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    gatewayTransactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundDetails?: SortOrderInput | SortOrder
    paymentId?: SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gatewayTransactionId?: string
    paymentId?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    amount?: FloatFilter<"Transaction"> | number
    status?: EnumStatusFilter<"Transaction"> | $Enums.Status
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    refundDetails?: StringNullableFilter<"Transaction"> | string | null
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "id" | "gatewayTransactionId" | "paymentId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    gatewayTransactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundDetails?: SortOrderInput | SortOrder
    paymentId?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    gatewayTransactionId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    status?: EnumStatusWithAggregatesFilter<"Transaction"> | $Enums.Status
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    refundDetails?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentId?: StringWithAggregatesFilter<"Transaction"> | string
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: StringFilter<"Rating"> | string
    userId?: StringFilter<"Rating"> | string
    serviceProviderType?: EnumProviderTypeFilter<"Rating"> | $Enums.ProviderType
    serviceProviderId?: StringFilter<"Rating"> | string
    score?: FloatFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceProviderType?: SortOrder
    serviceProviderId?: SortOrder
    score?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceProvider?: ServiceProviderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    userId?: StringFilter<"Rating"> | string
    serviceProviderType?: EnumProviderTypeFilter<"Rating"> | $Enums.ProviderType
    serviceProviderId?: StringFilter<"Rating"> | string
    score?: FloatFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceProviderType?: SortOrder
    serviceProviderId?: SortOrder
    score?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rating"> | string
    userId?: StringWithAggregatesFilter<"Rating"> | string
    serviceProviderType?: EnumProviderTypeWithAggregatesFilter<"Rating"> | $Enums.ProviderType
    serviceProviderId?: StringWithAggregatesFilter<"Rating"> | string
    score?: FloatWithAggregatesFilter<"Rating"> | number
    comment?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
  }

  export type RequestPermissionWhereInput = {
    AND?: RequestPermissionWhereInput | RequestPermissionWhereInput[]
    OR?: RequestPermissionWhereInput[]
    NOT?: RequestPermissionWhereInput | RequestPermissionWhereInput[]
    id?: StringFilter<"RequestPermission"> | string
    name?: StringFilter<"RequestPermission"> | string
    description?: StringNullableFilter<"RequestPermission"> | string | null
    accessType?: EnumPermissionTypeFilter<"RequestPermission"> | $Enums.PermissionType
    doctorsAssistantId?: StringNullableFilter<"RequestPermission"> | string | null
    requests?: RequestListRelationFilter
    doctorsAssistant?: XOR<DoctorsAssistantNullableScalarRelationFilter, DoctorsAssistantWhereInput> | null
  }

  export type RequestPermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    accessType?: SortOrder
    doctorsAssistantId?: SortOrderInput | SortOrder
    requests?: RequestOrderByRelationAggregateInput
    doctorsAssistant?: DoctorsAssistantOrderByWithRelationInput
  }

  export type RequestPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequestPermissionWhereInput | RequestPermissionWhereInput[]
    OR?: RequestPermissionWhereInput[]
    NOT?: RequestPermissionWhereInput | RequestPermissionWhereInput[]
    name?: StringFilter<"RequestPermission"> | string
    description?: StringNullableFilter<"RequestPermission"> | string | null
    accessType?: EnumPermissionTypeFilter<"RequestPermission"> | $Enums.PermissionType
    doctorsAssistantId?: StringNullableFilter<"RequestPermission"> | string | null
    requests?: RequestListRelationFilter
    doctorsAssistant?: XOR<DoctorsAssistantNullableScalarRelationFilter, DoctorsAssistantWhereInput> | null
  }, "id">

  export type RequestPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    accessType?: SortOrder
    doctorsAssistantId?: SortOrderInput | SortOrder
    _count?: RequestPermissionCountOrderByAggregateInput
    _max?: RequestPermissionMaxOrderByAggregateInput
    _min?: RequestPermissionMinOrderByAggregateInput
  }

  export type RequestPermissionScalarWhereWithAggregatesInput = {
    AND?: RequestPermissionScalarWhereWithAggregatesInput | RequestPermissionScalarWhereWithAggregatesInput[]
    OR?: RequestPermissionScalarWhereWithAggregatesInput[]
    NOT?: RequestPermissionScalarWhereWithAggregatesInput | RequestPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequestPermission"> | string
    name?: StringWithAggregatesFilter<"RequestPermission"> | string
    description?: StringNullableWithAggregatesFilter<"RequestPermission"> | string | null
    accessType?: EnumPermissionTypeWithAggregatesFilter<"RequestPermission"> | $Enums.PermissionType
    doctorsAssistantId?: StringNullableWithAggregatesFilter<"RequestPermission"> | string | null
  }

  export type RequestWhereInput = {
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    id?: StringFilter<"Request"> | string
    status?: EnumStatusFilter<"Request"> | $Enums.Status
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    doctorId?: StringNullableFilter<"Request"> | string | null
    requestPermissions?: RequestPermissionListRelationFilter
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }

  export type RequestOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    requestPermissions?: RequestPermissionOrderByRelationAggregateInput
    doctor?: DoctorOrderByWithRelationInput
  }

  export type RequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    status?: EnumStatusFilter<"Request"> | $Enums.Status
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    doctorId?: StringNullableFilter<"Request"> | string | null
    requestPermissions?: RequestPermissionListRelationFilter
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }, "id">

  export type RequestOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    _count?: RequestCountOrderByAggregateInput
    _max?: RequestMaxOrderByAggregateInput
    _min?: RequestMinOrderByAggregateInput
  }

  export type RequestScalarWhereWithAggregatesInput = {
    AND?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    OR?: RequestScalarWhereWithAggregatesInput[]
    NOT?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Request"> | string
    status?: EnumStatusWithAggregatesFilter<"Request"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
    doctorId?: StringNullableWithAggregatesFilter<"Request"> | string | null
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    service?: EnumServiceNullableListFilter<"Appointment">
    status?: EnumStatusFilter<"Appointment"> | $Enums.Status
    appointmentTime?: DateTimeFilter<"Appointment"> | Date | string
    bookedAt?: DateTimeFilter<"Appointment"> | Date | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    isForOthers?: BoolFilter<"Appointment"> | boolean
    slotId?: StringFilter<"Appointment"> | string
    userId?: StringFilter<"Appointment"> | string
    serviceProviderId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    othersAppointment?: XOR<OthersAppointmentNullableScalarRelationFilter, OthersAppointmentWhereInput> | null
    currentLocation?: XOR<CurrentLocationNullableScalarRelationFilter, CurrentLocationWhereInput> | null
    slot?: XOR<SlotScalarRelationFilter, SlotWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    payment?: PaymentListRelationFilter
    tags?: TagListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    appointmentTime?: SortOrder
    bookedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    isForOthers?: SortOrder
    slotId?: SortOrder
    userId?: SortOrder
    serviceProviderId?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    othersAppointment?: OthersAppointmentOrderByWithRelationInput
    currentLocation?: CurrentLocationOrderByWithRelationInput
    slot?: SlotOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    serviceProvider?: ServiceProviderOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    payment?: PaymentOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slotId?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    service?: EnumServiceNullableListFilter<"Appointment">
    status?: EnumStatusFilter<"Appointment"> | $Enums.Status
    appointmentTime?: DateTimeFilter<"Appointment"> | Date | string
    bookedAt?: DateTimeFilter<"Appointment"> | Date | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    isForOthers?: BoolFilter<"Appointment"> | boolean
    userId?: StringFilter<"Appointment"> | string
    serviceProviderId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    othersAppointment?: XOR<OthersAppointmentNullableScalarRelationFilter, OthersAppointmentWhereInput> | null
    currentLocation?: XOR<CurrentLocationNullableScalarRelationFilter, CurrentLocationWhereInput> | null
    slot?: XOR<SlotScalarRelationFilter, SlotWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    payment?: PaymentListRelationFilter
    tags?: TagListRelationFilter
  }, "id" | "slotId">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    appointmentTime?: SortOrder
    bookedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    isForOthers?: SortOrder
    slotId?: SortOrder
    userId?: SortOrder
    serviceProviderId?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    service?: EnumServiceNullableListFilter<"Appointment">
    status?: EnumStatusWithAggregatesFilter<"Appointment"> | $Enums.Status
    appointmentTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    bookedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    isForOthers?: BoolWithAggregatesFilter<"Appointment"> | boolean
    slotId?: StringWithAggregatesFilter<"Appointment"> | string
    userId?: StringWithAggregatesFilter<"Appointment"> | string
    serviceProviderId?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type OthersAppointmentWhereInput = {
    AND?: OthersAppointmentWhereInput | OthersAppointmentWhereInput[]
    OR?: OthersAppointmentWhereInput[]
    NOT?: OthersAppointmentWhereInput | OthersAppointmentWhereInput[]
    id?: StringFilter<"OthersAppointment"> | string
    name?: StringFilter<"OthersAppointment"> | string
    contact?: StringFilter<"OthersAppointment"> | string
    email?: StringNullableFilter<"OthersAppointment"> | string | null
    relationship?: StringFilter<"OthersAppointment"> | string
    age?: IntFilter<"OthersAppointment"> | number
    gender?: EnumGenderFilter<"OthersAppointment"> | $Enums.Gender
    reason?: StringNullableFilter<"OthersAppointment"> | string | null
    appointmentId?: StringFilter<"OthersAppointment"> | string
    createdAt?: DateTimeFilter<"OthersAppointment"> | Date | string
    updatedAt?: DateTimeFilter<"OthersAppointment"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
  }

  export type OthersAppointmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    relationship?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    reason?: SortOrderInput | SortOrder
    appointmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type OthersAppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    AND?: OthersAppointmentWhereInput | OthersAppointmentWhereInput[]
    OR?: OthersAppointmentWhereInput[]
    NOT?: OthersAppointmentWhereInput | OthersAppointmentWhereInput[]
    name?: StringFilter<"OthersAppointment"> | string
    contact?: StringFilter<"OthersAppointment"> | string
    email?: StringNullableFilter<"OthersAppointment"> | string | null
    relationship?: StringFilter<"OthersAppointment"> | string
    age?: IntFilter<"OthersAppointment"> | number
    gender?: EnumGenderFilter<"OthersAppointment"> | $Enums.Gender
    reason?: StringNullableFilter<"OthersAppointment"> | string | null
    createdAt?: DateTimeFilter<"OthersAppointment"> | Date | string
    updatedAt?: DateTimeFilter<"OthersAppointment"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
  }, "id" | "appointmentId">

  export type OthersAppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    relationship?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    reason?: SortOrderInput | SortOrder
    appointmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OthersAppointmentCountOrderByAggregateInput
    _avg?: OthersAppointmentAvgOrderByAggregateInput
    _max?: OthersAppointmentMaxOrderByAggregateInput
    _min?: OthersAppointmentMinOrderByAggregateInput
    _sum?: OthersAppointmentSumOrderByAggregateInput
  }

  export type OthersAppointmentScalarWhereWithAggregatesInput = {
    AND?: OthersAppointmentScalarWhereWithAggregatesInput | OthersAppointmentScalarWhereWithAggregatesInput[]
    OR?: OthersAppointmentScalarWhereWithAggregatesInput[]
    NOT?: OthersAppointmentScalarWhereWithAggregatesInput | OthersAppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OthersAppointment"> | string
    name?: StringWithAggregatesFilter<"OthersAppointment"> | string
    contact?: StringWithAggregatesFilter<"OthersAppointment"> | string
    email?: StringNullableWithAggregatesFilter<"OthersAppointment"> | string | null
    relationship?: StringWithAggregatesFilter<"OthersAppointment"> | string
    age?: IntWithAggregatesFilter<"OthersAppointment"> | number
    gender?: EnumGenderWithAggregatesFilter<"OthersAppointment"> | $Enums.Gender
    reason?: StringNullableWithAggregatesFilter<"OthersAppointment"> | string | null
    appointmentId?: StringWithAggregatesFilter<"OthersAppointment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OthersAppointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OthersAppointment"> | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    date?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    dayOfWeek?: EnumWeekDayNullableFilter<"Schedule"> | $Enums.WeekDay | null
    isRecurring?: BoolFilter<"Schedule"> | boolean
    recurrenceType?: EnumRecurrenceTypeNullableFilter<"Schedule"> | $Enums.RecurrenceType | null
    startTime?: DateTimeFilter<"Schedule"> | Date | string
    endTime?: DateTimeFilter<"Schedule"> | Date | string
    slotDuration?: IntFilter<"Schedule"> | number
    location?: StringFilter<"Schedule"> | string
    isAvailable?: BoolFilter<"Schedule"> | boolean
    service?: EnumServiceFilter<"Schedule"> | $Enums.Service
    status?: EnumStatusFilter<"Schedule"> | $Enums.Status
    serviceProviderId?: StringFilter<"Schedule"> | string
    userId?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    serviceProviders?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    slots?: SlotListRelationFilter
    clinicInfo?: ClinicInfoListRelationFilter
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurrenceType?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotDuration?: SortOrder
    location?: SortOrder
    isAvailable?: SortOrder
    service?: SortOrder
    status?: SortOrder
    serviceProviderId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceProviders?: ServiceProviderOrderByWithRelationInput
    slots?: SlotOrderByRelationAggregateInput
    clinicInfo?: ClinicInfoOrderByRelationAggregateInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    date?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    dayOfWeek?: EnumWeekDayNullableFilter<"Schedule"> | $Enums.WeekDay | null
    isRecurring?: BoolFilter<"Schedule"> | boolean
    recurrenceType?: EnumRecurrenceTypeNullableFilter<"Schedule"> | $Enums.RecurrenceType | null
    startTime?: DateTimeFilter<"Schedule"> | Date | string
    endTime?: DateTimeFilter<"Schedule"> | Date | string
    slotDuration?: IntFilter<"Schedule"> | number
    location?: StringFilter<"Schedule"> | string
    isAvailable?: BoolFilter<"Schedule"> | boolean
    service?: EnumServiceFilter<"Schedule"> | $Enums.Service
    status?: EnumStatusFilter<"Schedule"> | $Enums.Status
    serviceProviderId?: StringFilter<"Schedule"> | string
    userId?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    serviceProviders?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    slots?: SlotListRelationFilter
    clinicInfo?: ClinicInfoListRelationFilter
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurrenceType?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotDuration?: SortOrder
    location?: SortOrder
    isAvailable?: SortOrder
    service?: SortOrder
    status?: SortOrder
    serviceProviderId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    date?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    dayOfWeek?: EnumWeekDayNullableWithAggregatesFilter<"Schedule"> | $Enums.WeekDay | null
    isRecurring?: BoolWithAggregatesFilter<"Schedule"> | boolean
    recurrenceType?: EnumRecurrenceTypeNullableWithAggregatesFilter<"Schedule"> | $Enums.RecurrenceType | null
    startTime?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    slotDuration?: IntWithAggregatesFilter<"Schedule"> | number
    location?: StringWithAggregatesFilter<"Schedule"> | string
    isAvailable?: BoolWithAggregatesFilter<"Schedule"> | boolean
    service?: EnumServiceWithAggregatesFilter<"Schedule"> | $Enums.Service
    status?: EnumStatusWithAggregatesFilter<"Schedule"> | $Enums.Status
    serviceProviderId?: StringWithAggregatesFilter<"Schedule"> | string
    userId?: StringWithAggregatesFilter<"Schedule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type SlotWhereInput = {
    AND?: SlotWhereInput | SlotWhereInput[]
    OR?: SlotWhereInput[]
    NOT?: SlotWhereInput | SlotWhereInput[]
    id?: StringFilter<"Slot"> | string
    slotDate?: DateTimeNullableFilter<"Slot"> | Date | string | null
    startTime?: DateTimeFilter<"Slot"> | Date | string
    endTime?: DateTimeFilter<"Slot"> | Date | string
    isBooked?: BoolFilter<"Slot"> | boolean
    scheduleId?: StringFilter<"Slot"> | string
    bookedAt?: DateTimeNullableFilter<"Slot"> | Date | string | null
    updatedAt?: DateTimeFilter<"Slot"> | Date | string
    schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }

  export type SlotOrderByWithRelationInput = {
    id?: SortOrder
    slotDate?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isBooked?: SortOrder
    scheduleId?: SortOrder
    bookedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    schedule?: ScheduleOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type SlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SlotWhereInput | SlotWhereInput[]
    OR?: SlotWhereInput[]
    NOT?: SlotWhereInput | SlotWhereInput[]
    slotDate?: DateTimeNullableFilter<"Slot"> | Date | string | null
    startTime?: DateTimeFilter<"Slot"> | Date | string
    endTime?: DateTimeFilter<"Slot"> | Date | string
    isBooked?: BoolFilter<"Slot"> | boolean
    scheduleId?: StringFilter<"Slot"> | string
    bookedAt?: DateTimeNullableFilter<"Slot"> | Date | string | null
    updatedAt?: DateTimeFilter<"Slot"> | Date | string
    schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }, "id">

  export type SlotOrderByWithAggregationInput = {
    id?: SortOrder
    slotDate?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isBooked?: SortOrder
    scheduleId?: SortOrder
    bookedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SlotCountOrderByAggregateInput
    _max?: SlotMaxOrderByAggregateInput
    _min?: SlotMinOrderByAggregateInput
  }

  export type SlotScalarWhereWithAggregatesInput = {
    AND?: SlotScalarWhereWithAggregatesInput | SlotScalarWhereWithAggregatesInput[]
    OR?: SlotScalarWhereWithAggregatesInput[]
    NOT?: SlotScalarWhereWithAggregatesInput | SlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Slot"> | string
    slotDate?: DateTimeNullableWithAggregatesFilter<"Slot"> | Date | string | null
    startTime?: DateTimeWithAggregatesFilter<"Slot"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Slot"> | Date | string
    isBooked?: BoolWithAggregatesFilter<"Slot"> | boolean
    scheduleId?: StringWithAggregatesFilter<"Slot"> | string
    bookedAt?: DateTimeNullableWithAggregatesFilter<"Slot"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Slot"> | Date | string
  }

  export type ClinicInfoWhereInput = {
    AND?: ClinicInfoWhereInput | ClinicInfoWhereInput[]
    OR?: ClinicInfoWhereInput[]
    NOT?: ClinicInfoWhereInput | ClinicInfoWhereInput[]
    id?: StringFilter<"ClinicInfo"> | string
    clinicName?: StringFilter<"ClinicInfo"> | string
    addressId?: StringFilter<"ClinicInfo"> | string
    phone?: StringFilter<"ClinicInfo"> | string
    images?: StringNullableListFilter<"ClinicInfo">
    scheduleId?: StringNullableFilter<"ClinicInfo"> | string | null
    createdAt?: DateTimeFilter<"ClinicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicInfo"> | Date | string
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    serviceProviders?: ServiceProviderListRelationFilter
    schedule?: XOR<ScheduleNullableScalarRelationFilter, ScheduleWhereInput> | null
  }

  export type ClinicInfoOrderByWithRelationInput = {
    id?: SortOrder
    clinicName?: SortOrder
    addressId?: SortOrder
    phone?: SortOrder
    images?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: AddressOrderByWithRelationInput
    serviceProviders?: ServiceProviderOrderByRelationAggregateInput
    schedule?: ScheduleOrderByWithRelationInput
  }

  export type ClinicInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    addressId?: string
    AND?: ClinicInfoWhereInput | ClinicInfoWhereInput[]
    OR?: ClinicInfoWhereInput[]
    NOT?: ClinicInfoWhereInput | ClinicInfoWhereInput[]
    clinicName?: StringFilter<"ClinicInfo"> | string
    phone?: StringFilter<"ClinicInfo"> | string
    images?: StringNullableListFilter<"ClinicInfo">
    scheduleId?: StringNullableFilter<"ClinicInfo"> | string | null
    createdAt?: DateTimeFilter<"ClinicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicInfo"> | Date | string
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    serviceProviders?: ServiceProviderListRelationFilter
    schedule?: XOR<ScheduleNullableScalarRelationFilter, ScheduleWhereInput> | null
  }, "id" | "addressId">

  export type ClinicInfoOrderByWithAggregationInput = {
    id?: SortOrder
    clinicName?: SortOrder
    addressId?: SortOrder
    phone?: SortOrder
    images?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicInfoCountOrderByAggregateInput
    _max?: ClinicInfoMaxOrderByAggregateInput
    _min?: ClinicInfoMinOrderByAggregateInput
  }

  export type ClinicInfoScalarWhereWithAggregatesInput = {
    AND?: ClinicInfoScalarWhereWithAggregatesInput | ClinicInfoScalarWhereWithAggregatesInput[]
    OR?: ClinicInfoScalarWhereWithAggregatesInput[]
    NOT?: ClinicInfoScalarWhereWithAggregatesInput | ClinicInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicInfo"> | string
    clinicName?: StringWithAggregatesFilter<"ClinicInfo"> | string
    addressId?: StringWithAggregatesFilter<"ClinicInfo"> | string
    phone?: StringWithAggregatesFilter<"ClinicInfo"> | string
    images?: StringNullableListFilter<"ClinicInfo">
    scheduleId?: StringNullableWithAggregatesFilter<"ClinicInfo"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClinicInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicInfo"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    address?: StringNullableFilter<"Address"> | string | null
    city?: StringNullableFilter<"Address"> | string | null
    state?: StringNullableFilter<"Address"> | string | null
    country?: StringNullableFilter<"Address"> | string | null
    pincode?: StringNullableFilter<"Address"> | string | null
    userId?: StringNullableFilter<"Address"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clinicInfo?: XOR<ClinicInfoNullableScalarRelationFilter, ClinicInfoWhereInput> | null
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    clinicInfo?: ClinicInfoOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    address?: StringNullableFilter<"Address"> | string | null
    city?: StringNullableFilter<"Address"> | string | null
    state?: StringNullableFilter<"Address"> | string | null
    country?: StringNullableFilter<"Address"> | string | null
    pincode?: StringNullableFilter<"Address"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clinicInfo?: XOR<ClinicInfoNullableScalarRelationFilter, ClinicInfoWhereInput> | null
  }, "id" | "userId">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    address?: StringNullableWithAggregatesFilter<"Address"> | string | null
    city?: StringNullableWithAggregatesFilter<"Address"> | string | null
    state?: StringNullableWithAggregatesFilter<"Address"> | string | null
    country?: StringNullableWithAggregatesFilter<"Address"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"Address"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Address"> | string | null
  }

  export type EducationWhereInput = {
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    id?: StringFilter<"Education"> | string
    university?: StringFilter<"Education"> | string
    degree?: StringFilter<"Education"> | string
    duration?: StringFilter<"Education"> | string
    serviceProviderId?: StringFilter<"Education"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type EducationOrderByWithRelationInput = {
    id?: SortOrder
    university?: SortOrder
    degree?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type EducationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    university?: StringFilter<"Education"> | string
    degree?: StringFilter<"Education"> | string
    duration?: StringFilter<"Education"> | string
    serviceProviderId?: StringFilter<"Education"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "id">

  export type EducationOrderByWithAggregationInput = {
    id?: SortOrder
    university?: SortOrder
    degree?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
    _count?: EducationCountOrderByAggregateInput
    _max?: EducationMaxOrderByAggregateInput
    _min?: EducationMinOrderByAggregateInput
  }

  export type EducationScalarWhereWithAggregatesInput = {
    AND?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    OR?: EducationScalarWhereWithAggregatesInput[]
    NOT?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Education"> | string
    university?: StringWithAggregatesFilter<"Education"> | string
    degree?: StringWithAggregatesFilter<"Education"> | string
    duration?: StringWithAggregatesFilter<"Education"> | string
    serviceProviderId?: StringWithAggregatesFilter<"Education"> | string
  }

  export type WorkExperienceWhereInput = {
    AND?: WorkExperienceWhereInput | WorkExperienceWhereInput[]
    OR?: WorkExperienceWhereInput[]
    NOT?: WorkExperienceWhereInput | WorkExperienceWhereInput[]
    id?: StringFilter<"WorkExperience"> | string
    clinic?: StringFilter<"WorkExperience"> | string
    duration?: StringFilter<"WorkExperience"> | string
    serviceProviderId?: StringFilter<"WorkExperience"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type WorkExperienceOrderByWithRelationInput = {
    id?: SortOrder
    clinic?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type WorkExperienceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkExperienceWhereInput | WorkExperienceWhereInput[]
    OR?: WorkExperienceWhereInput[]
    NOT?: WorkExperienceWhereInput | WorkExperienceWhereInput[]
    clinic?: StringFilter<"WorkExperience"> | string
    duration?: StringFilter<"WorkExperience"> | string
    serviceProviderId?: StringFilter<"WorkExperience"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "id">

  export type WorkExperienceOrderByWithAggregationInput = {
    id?: SortOrder
    clinic?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
    _count?: WorkExperienceCountOrderByAggregateInput
    _max?: WorkExperienceMaxOrderByAggregateInput
    _min?: WorkExperienceMinOrderByAggregateInput
  }

  export type WorkExperienceScalarWhereWithAggregatesInput = {
    AND?: WorkExperienceScalarWhereWithAggregatesInput | WorkExperienceScalarWhereWithAggregatesInput[]
    OR?: WorkExperienceScalarWhereWithAggregatesInput[]
    NOT?: WorkExperienceScalarWhereWithAggregatesInput | WorkExperienceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkExperience"> | string
    clinic?: StringWithAggregatesFilter<"WorkExperience"> | string
    duration?: StringWithAggregatesFilter<"WorkExperience"> | string
    serviceProviderId?: StringWithAggregatesFilter<"WorkExperience"> | string
  }

  export type AwardWhereInput = {
    AND?: AwardWhereInput | AwardWhereInput[]
    OR?: AwardWhereInput[]
    NOT?: AwardWhereInput | AwardWhereInput[]
    id?: StringFilter<"Award"> | string
    date?: StringFilter<"Award"> | string
    title?: StringFilter<"Award"> | string
    description?: StringFilter<"Award"> | string
    serviceProviderId?: StringFilter<"Award"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type AwardOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    title?: SortOrder
    description?: SortOrder
    serviceProviderId?: SortOrder
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type AwardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AwardWhereInput | AwardWhereInput[]
    OR?: AwardWhereInput[]
    NOT?: AwardWhereInput | AwardWhereInput[]
    date?: StringFilter<"Award"> | string
    title?: StringFilter<"Award"> | string
    description?: StringFilter<"Award"> | string
    serviceProviderId?: StringFilter<"Award"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "id">

  export type AwardOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    title?: SortOrder
    description?: SortOrder
    serviceProviderId?: SortOrder
    _count?: AwardCountOrderByAggregateInput
    _max?: AwardMaxOrderByAggregateInput
    _min?: AwardMinOrderByAggregateInput
  }

  export type AwardScalarWhereWithAggregatesInput = {
    AND?: AwardScalarWhereWithAggregatesInput | AwardScalarWhereWithAggregatesInput[]
    OR?: AwardScalarWhereWithAggregatesInput[]
    NOT?: AwardScalarWhereWithAggregatesInput | AwardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Award"> | string
    date?: StringWithAggregatesFilter<"Award"> | string
    title?: StringWithAggregatesFilter<"Award"> | string
    description?: StringWithAggregatesFilter<"Award"> | string
    serviceProviderId?: StringWithAggregatesFilter<"Award"> | string
  }

  export type CurrentLocationWhereInput = {
    AND?: CurrentLocationWhereInput | CurrentLocationWhereInput[]
    OR?: CurrentLocationWhereInput[]
    NOT?: CurrentLocationWhereInput | CurrentLocationWhereInput[]
    id?: StringFilter<"CurrentLocation"> | string
    lat?: FloatFilter<"CurrentLocation"> | number
    long?: FloatFilter<"CurrentLocation"> | number
    appointmentId?: StringNullableFilter<"CurrentLocation"> | string | null
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }

  export type CurrentLocationOrderByWithRelationInput = {
    id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type CurrentLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    AND?: CurrentLocationWhereInput | CurrentLocationWhereInput[]
    OR?: CurrentLocationWhereInput[]
    NOT?: CurrentLocationWhereInput | CurrentLocationWhereInput[]
    lat?: FloatFilter<"CurrentLocation"> | number
    long?: FloatFilter<"CurrentLocation"> | number
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }, "id" | "appointmentId">

  export type CurrentLocationOrderByWithAggregationInput = {
    id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    _count?: CurrentLocationCountOrderByAggregateInput
    _avg?: CurrentLocationAvgOrderByAggregateInput
    _max?: CurrentLocationMaxOrderByAggregateInput
    _min?: CurrentLocationMinOrderByAggregateInput
    _sum?: CurrentLocationSumOrderByAggregateInput
  }

  export type CurrentLocationScalarWhereWithAggregatesInput = {
    AND?: CurrentLocationScalarWhereWithAggregatesInput | CurrentLocationScalarWhereWithAggregatesInput[]
    OR?: CurrentLocationScalarWhereWithAggregatesInput[]
    NOT?: CurrentLocationScalarWhereWithAggregatesInput | CurrentLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CurrentLocation"> | string
    lat?: FloatWithAggregatesFilter<"CurrentLocation"> | number
    long?: FloatWithAggregatesFilter<"CurrentLocation"> | number
    appointmentId?: StringNullableWithAggregatesFilter<"CurrentLocation"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    actionType?: EnumActionTypeFilter<"AuditLog"> | $Enums.ActionType
    status?: EnumStatusFilter<"AuditLog"> | $Enums.Status
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    device?: StringNullableFilter<"AuditLog"> | string | null
    performedBy?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: StringFilter<"AuditLog"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    actionType?: EnumActionTypeFilter<"AuditLog"> | $Enums.ActionType
    status?: EnumStatusFilter<"AuditLog"> | $Enums.Status
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    device?: StringNullableFilter<"AuditLog"> | string | null
    performedBy?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: StringFilter<"AuditLog"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    actionType?: EnumActionTypeWithAggregatesFilter<"AuditLog"> | $Enums.ActionType
    status?: EnumStatusWithAggregatesFilter<"AuditLog"> | $Enums.Status
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    device?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    performedBy?: StringWithAggregatesFilter<"AuditLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    isRecurring?: BoolFilter<"Notification"> | boolean
    groupId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntity?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    groupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    relatedEntity?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    isRecurring?: BoolFilter<"Notification"> | boolean
    groupId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntity?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    groupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    relatedEntity?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    priority?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    isRecurring?: BoolWithAggregatesFilter<"Notification"> | boolean
    groupId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    relatedEntityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedEntity?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    serviceProviders?: ServiceProviderListRelationFilter
    appointments?: AppointmentListRelationFilter
    patients?: PatientListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceProviders?: ServiceProviderOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    serviceProviders?: ServiceProviderListRelationFilter
    appointments?: AppointmentListRelationFilter
    patients?: PatientListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateInput = {
    id?: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestCreateInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationRequestUncheckedCreateInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestCreateManyInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    user: UserCreateNestedOneWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labResults?: LabResultCreateNestedManyWithoutPatientInput
    adminPanel: AdminPanelCreateNestedOneWithoutPatientInput
    tags?: TagCreateNestedManyWithoutPatientsInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutPatientInput
    tags?: TagUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUpdateManyWithoutPatientNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutPatientNestedInput
    tags?: TagUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutPatientNestedInput
    tags?: TagUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminPanelCreateInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: ServiceProviderCreateNestedManyWithoutAdminPanelInput
    patient?: PatientCreateNestedManyWithoutAdminPanelInput
    superAdminId?: SuperAdminCreateNestedManyWithoutAdminPanelInput
    adminId?: AdminCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelUncheckedCreateInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutAdminPanelInput
    patient?: PatientUncheckedCreateNestedManyWithoutAdminPanelInput
    superAdminId?: SuperAdminUncheckedCreateNestedManyWithoutAdminPanelInput
    adminId?: AdminUncheckedCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderUpdateManyWithoutAdminPanelNestedInput
    patient?: PatientUpdateManyWithoutAdminPanelNestedInput
    superAdminId?: SuperAdminUpdateManyWithoutAdminPanelNestedInput
    adminId?: AdminUpdateManyWithoutAdminPanelNestedInput
  }

  export type AdminPanelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutAdminPanelNestedInput
    patient?: PatientUncheckedUpdateManyWithoutAdminPanelNestedInput
    superAdminId?: SuperAdminUncheckedUpdateManyWithoutAdminPanelNestedInput
    adminId?: AdminUncheckedUpdateManyWithoutAdminPanelNestedInput
  }

  export type AdminPanelCreateManyInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
  }

  export type AdminPanelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminPanelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SuperAdminCreateInput = {
    id?: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    user: UserCreateNestedOneWithoutSuperAdminInput
    admin?: AdminCreateNestedManyWithoutSuperAdminInput
    adminPanel: AdminPanelCreateNestedOneWithoutSuperAdminIdInput
  }

  export type SuperAdminUncheckedCreateInput = {
    id?: string
    userId: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    adminPanelId: string
    admin?: AdminUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    user?: UserUpdateOneRequiredWithoutSuperAdminNestedInput
    admin?: AdminUpdateManyWithoutSuperAdminNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutSuperAdminIdNestedInput
  }

  export type SuperAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    adminPanelId?: StringFieldUpdateOperationsInput | string
    admin?: AdminUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminCreateManyInput = {
    id?: string
    userId: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    adminPanelId: string
  }

  export type SuperAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type SuperAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    adminPanelId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    user: UserCreateNestedOneWithoutAdminInput
    adminPanel: AdminPanelCreateNestedOneWithoutAdminIdInput
    superAdmin: SuperAdminCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId: string
    superAdminId: string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutAdminIdNestedInput
    superAdmin?: SuperAdminUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    adminPanelId?: StringFieldUpdateOperationsInput | string
    superAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId: string
    superAdminId: string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    adminPanelId?: StringFieldUpdateOperationsInput | string
    superAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceProviderCreateInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type ServiceProviderCreateManyInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ServiceProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    assistants?: DoctorsAssistantCreateNestedManyWithoutDoctorInput
    requests?: RequestCreateNestedManyWithoutDoctorInput
    serviceprovider: ServiceProviderCreateNestedOneWithoutDoctorInput
  }

  export type DoctorUncheckedCreateInput = {
    id?: string
    userId: string
    serviceproviderId: string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    assistants?: DoctorsAssistantUncheckedCreateNestedManyWithoutDoctorInput
    requests?: RequestUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUpdateManyWithoutDoctorNestedInput
    requests?: RequestUpdateManyWithoutDoctorNestedInput
    serviceprovider?: ServiceProviderUpdateOneRequiredWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceproviderId?: StringFieldUpdateOperationsInput | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUncheckedUpdateManyWithoutDoctorNestedInput
    requests?: RequestUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorCreateManyInput = {
    id?: string
    userId: string
    serviceproviderId: string
  }

  export type DoctorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceproviderId?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorsAssistantCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutDoctorsAssistantInput
    doctor: DoctorCreateNestedOneWithoutAssistantsInput
    requestPermissions?: RequestPermissionCreateNestedManyWithoutDoctorsAssistantInput
  }

  export type DoctorsAssistantUncheckedCreateInput = {
    id?: string
    userId: string
    assignedDoctorId: string
    requestPermissions?: RequestPermissionUncheckedCreateNestedManyWithoutDoctorsAssistantInput
  }

  export type DoctorsAssistantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDoctorsAssistantNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAssistantsNestedInput
    requestPermissions?: RequestPermissionUpdateManyWithoutDoctorsAssistantNestedInput
  }

  export type DoctorsAssistantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    requestPermissions?: RequestPermissionUncheckedUpdateManyWithoutDoctorsAssistantNestedInput
  }

  export type DoctorsAssistantCreateManyInput = {
    id?: string
    userId: string
    assignedDoctorId: string
  }

  export type DoctorsAssistantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorsAssistantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
  }

  export type LabCreateInput = {
    id?: string
    servicesOffered?: LabCreateservicesOfferedInput | string[]
    user: UserCreateNestedOneWithoutLabInput
  }

  export type LabUncheckedCreateInput = {
    id?: string
    userId: string
    servicesOffered?: LabCreateservicesOfferedInput | string[]
  }

  export type LabUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: LabUpdateservicesOfferedInput | string[]
    user?: UserUpdateOneRequiredWithoutLabNestedInput
  }

  export type LabUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    servicesOffered?: LabUpdateservicesOfferedInput | string[]
  }

  export type LabCreateManyInput = {
    id?: string
    userId: string
    servicesOffered?: LabCreateservicesOfferedInput | string[]
  }

  export type LabUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: LabUpdateservicesOfferedInput | string[]
  }

  export type LabUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    servicesOffered?: LabUpdateservicesOfferedInput | string[]
  }

  export type HospitalCreateInput = {
    id?: string
    servicesOffered?: HospitalCreateservicesOfferedInput | string[]
    user: UserCreateNestedOneWithoutHospitalInput
  }

  export type HospitalUncheckedCreateInput = {
    id?: string
    userId: string
    servicesOffered?: HospitalCreateservicesOfferedInput | string[]
  }

  export type HospitalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: HospitalUpdateservicesOfferedInput | string[]
    user?: UserUpdateOneRequiredWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    servicesOffered?: HospitalUpdateservicesOfferedInput | string[]
  }

  export type HospitalCreateManyInput = {
    id?: string
    userId: string
    servicesOffered?: HospitalCreateservicesOfferedInput | string[]
  }

  export type HospitalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: HospitalUpdateservicesOfferedInput | string[]
  }

  export type HospitalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    servicesOffered?: HospitalUpdateservicesOfferedInput | string[]
  }

  export type NursingCreateInput = {
    id?: string
    servicesOffered?: NursingCreateservicesOfferedInput | string[]
    user: UserCreateNestedOneWithoutNursingInput
  }

  export type NursingUncheckedCreateInput = {
    id?: string
    userId: string
    servicesOffered?: NursingCreateservicesOfferedInput | string[]
  }

  export type NursingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: NursingUpdateservicesOfferedInput | string[]
    user?: UserUpdateOneRequiredWithoutNursingNestedInput
  }

  export type NursingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    servicesOffered?: NursingUpdateservicesOfferedInput | string[]
  }

  export type NursingCreateManyInput = {
    id?: string
    userId: string
    servicesOffered?: NursingCreateservicesOfferedInput | string[]
  }

  export type NursingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: NursingUpdateservicesOfferedInput | string[]
  }

  export type NursingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    servicesOffered?: NursingUpdateservicesOfferedInput | string[]
  }

  export type AllergyCreateInput = {
    id?: string
    allergen: string
    type: string
    severity: string
    reaction: string
    patient: PatientCreateNestedOneWithoutAllergiesInput
  }

  export type AllergyUncheckedCreateInput = {
    id?: string
    allergen: string
    type: string
    severity: string
    reaction: string
    patientId: string
  }

  export type AllergyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutAllergiesNestedInput
  }

  export type AllergyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
  }

  export type AllergyCreateManyInput = {
    id?: string
    allergen: string
    type: string
    severity: string
    reaction: string
    patientId: string
  }

  export type AllergyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
  }

  export type AllergyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
  }

  export type MedicationCreateInput = {
    id?: string
    name: string
    dosage: string
    frequency: string
    duration: string
    status: string
    prescription?: PrescriptionCreateNestedOneWithoutMedicationsInput
  }

  export type MedicationUncheckedCreateInput = {
    id?: string
    name: string
    dosage: string
    frequency: string
    duration: string
    status: string
    prescriptionId?: string | null
  }

  export type MedicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUpdateOneWithoutMedicationsNestedInput
  }

  export type MedicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationCreateManyInput = {
    id?: string
    name: string
    dosage: string
    frequency: string
    duration: string
    status: string
    prescriptionId?: string | null
  }

  export type MedicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MedicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabResultCreateInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    patient: PatientCreateNestedOneWithoutLabResultsInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutLabResultsInput
  }

  export type LabResultUncheckedCreateInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    patientId: string
    serviceProvideId: string
  }

  export type LabResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutLabResultsNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutLabResultsNestedInput
  }

  export type LabResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    serviceProvideId?: StringFieldUpdateOperationsInput | string
  }

  export type LabResultCreateManyInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    patientId: string
    serviceProvideId: string
  }

  export type LabResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type LabResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    serviceProvideId?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalRecordCreateInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    description?: string | null
    recordId?: string | null
    attachment?: string | null
    user: UserCreateNestedOneWithoutMedicalRecordsInput
    serviceProvider?: ServiceProviderCreateNestedOneWithoutMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    userId: string
    description?: string | null
    recordId?: string | null
    attachment?: string | null
    serviceProviderId?: string | null
  }

  export type MedicalRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutMedicalRecordsNestedInput
    serviceProvider?: ServiceProviderUpdateOneWithoutMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalRecordCreateManyInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    userId: string
    description?: string | null
    recordId?: string | null
    attachment?: string | null
    serviceProviderId?: string | null
  }

  export type MedicalRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionCreateInput = {
    id?: string
    notes?: string | null
    dateIssued: Date | string
    medications?: MedicationCreateNestedManyWithoutPrescriptionInput
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: DoctorCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: string
    patientId: string
    doctorId: string
    notes?: string | null
    dateIssued: Date | string
    medications?: MedicationUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationUpdateManyWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: string
    patientId: string
    doctorId: string
    notes?: string | null
    dateIssued: Date | string
  }

  export type PrescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TherapyPlanCreateInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    patient: PatientCreateNestedOneWithoutTreatmentPlansInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutTherapyPlansInput
  }

  export type TherapyPlanUncheckedCreateInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    patientId: string
    serviceProvideId: string
  }

  export type TherapyPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutTherapyPlansNestedInput
  }

  export type TherapyPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    serviceProvideId?: StringFieldUpdateOperationsInput | string
  }

  export type TherapyPlanCreateManyInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    patientId: string
    serviceProvideId: string
  }

  export type TherapyPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type TherapyPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    serviceProvideId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    appointment: AppointmentCreateNestedOneWithoutPaymentInput
    transaction?: TransactionCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    userId: string
    appointmentId: string
    transaction?: TransactionUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    appointment?: AppointmentUpdateOneRequiredWithoutPaymentNestedInput
    transaction?: TransactionUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    transaction?: TransactionUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    userId: string
    appointmentId: string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    id?: string
    gatewayTransactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    refundDetails?: string | null
    payment: PaymentCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    gatewayTransactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    refundDetails?: string | null
    paymentId: string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gatewayTransactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gatewayTransactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    gatewayTransactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    refundDetails?: string | null
    paymentId: string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gatewayTransactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gatewayTransactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: StringFieldUpdateOperationsInput | string
  }

  export type RatingCreateInput = {
    id?: string
    serviceProviderType: $Enums.ProviderType
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProvider: ServiceProviderCreateNestedOneWithoutRatingInput
    user: UserCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    id?: string
    userId: string
    serviceProviderType: $Enums.ProviderType
    serviceProviderId: string
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutRatingNestedInput
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManyInput = {
    id?: string
    userId: string
    serviceProviderType: $Enums.ProviderType
    serviceProviderId: string
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestPermissionCreateInput = {
    id?: string
    name: string
    description?: string | null
    accessType: $Enums.PermissionType
    requests?: RequestCreateNestedManyWithoutRequestPermissionsInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutRequestPermissionsInput
  }

  export type RequestPermissionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    accessType: $Enums.PermissionType
    doctorsAssistantId?: string | null
    requests?: RequestUncheckedCreateNestedManyWithoutRequestPermissionsInput
  }

  export type RequestPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
    requests?: RequestUpdateManyWithoutRequestPermissionsNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutRequestPermissionsNestedInput
  }

  export type RequestPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
    doctorsAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    requests?: RequestUncheckedUpdateManyWithoutRequestPermissionsNestedInput
  }

  export type RequestPermissionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    accessType: $Enums.PermissionType
    doctorsAssistantId?: string | null
  }

  export type RequestPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
  }

  export type RequestPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
    doctorsAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequestCreateInput = {
    id?: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    requestPermissions?: RequestPermissionCreateNestedManyWithoutRequestsInput
    doctor?: DoctorCreateNestedOneWithoutRequestsInput
  }

  export type RequestUncheckedCreateInput = {
    id?: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    requestPermissions?: RequestPermissionUncheckedCreateNestedManyWithoutRequestsInput
  }

  export type RequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPermissions?: RequestPermissionUpdateManyWithoutRequestsNestedInput
    doctor?: DoctorUpdateOneWithoutRequestsNestedInput
  }

  export type RequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    requestPermissions?: RequestPermissionUncheckedUpdateManyWithoutRequestsNestedInput
  }

  export type RequestCreateManyInput = {
    id?: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
  }

  export type RequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationCreateNestedOneWithoutAppointmentInput
    slot: SlotCreateNestedOneWithoutAppointmentInput
    user: UserCreateNestedOneWithoutAppointmentsInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutAppointmentInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
    payment?: PaymentCreateNestedManyWithoutAppointmentInput
    tags?: TagCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput
    payment?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    tags?: TagUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUpdateOneWithoutAppointmentNestedInput
    slot?: SlotUpdateOneRequiredWithoutAppointmentNestedInput
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
    payment?: PaymentUpdateManyWithoutAppointmentNestedInput
    tags?: TagUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    tags?: TagUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OthersAppointmentCreateInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    relationship: string
    age: number
    gender: $Enums.Gender
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutOthersAppointmentInput
  }

  export type OthersAppointmentUncheckedCreateInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    relationship: string
    age: number
    gender: $Enums.Gender
    reason?: string | null
    appointmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OthersAppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutOthersAppointmentNestedInput
  }

  export type OthersAppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OthersAppointmentCreateManyInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    relationship: string
    age: number
    gender: $Enums.Gender
    reason?: string | null
    appointmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OthersAppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OthersAppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders: ServiceProviderCreateNestedOneWithoutScheduleInput
    slots?: SlotCreateNestedManyWithoutScheduleInput
    clinicInfo?: ClinicInfoCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    serviceProviderId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slots?: SlotUncheckedCreateNestedManyWithoutScheduleInput
    clinicInfo?: ClinicInfoUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUpdateOneRequiredWithoutScheduleNestedInput
    slots?: SlotUpdateManyWithoutScheduleNestedInput
    clinicInfo?: ClinicInfoUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slots?: SlotUncheckedUpdateManyWithoutScheduleNestedInput
    clinicInfo?: ClinicInfoUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleCreateManyInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    serviceProviderId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotCreateInput = {
    id?: string
    slotDate?: Date | string | null
    startTime: Date | string
    endTime: Date | string
    isBooked?: boolean
    bookedAt?: Date | string | null
    updatedAt?: Date | string
    schedule: ScheduleCreateNestedOneWithoutSlotsInput
    appointment?: AppointmentCreateNestedOneWithoutSlotInput
  }

  export type SlotUncheckedCreateInput = {
    id?: string
    slotDate?: Date | string | null
    startTime: Date | string
    endTime: Date | string
    isBooked?: boolean
    scheduleId: string
    bookedAt?: Date | string | null
    updatedAt?: Date | string
    appointment?: AppointmentUncheckedCreateNestedOneWithoutSlotInput
  }

  export type SlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateOneRequiredWithoutSlotsNestedInput
    appointment?: AppointmentUpdateOneWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    scheduleId?: StringFieldUpdateOperationsInput | string
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUncheckedUpdateOneWithoutSlotNestedInput
  }

  export type SlotCreateManyInput = {
    id?: string
    slotDate?: Date | string | null
    startTime: Date | string
    endTime: Date | string
    isBooked?: boolean
    scheduleId: string
    bookedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type SlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    scheduleId?: StringFieldUpdateOperationsInput | string
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicInfoCreateInput = {
    id?: string
    clinicName: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    address: AddressCreateNestedOneWithoutClinicInfoInput
    serviceProviders?: ServiceProviderCreateNestedManyWithoutClinicInfoInput
    schedule?: ScheduleCreateNestedOneWithoutClinicInfoInput
  }

  export type ClinicInfoUncheckedCreateInput = {
    id?: string
    clinicName: string
    addressId: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    scheduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderUncheckedCreateNestedManyWithoutClinicInfoInput
  }

  export type ClinicInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutClinicInfoNestedInput
    serviceProviders?: ServiceProviderUpdateManyWithoutClinicInfoNestedInput
    schedule?: ScheduleUpdateOneWithoutClinicInfoNestedInput
  }

  export type ClinicInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUncheckedUpdateManyWithoutClinicInfoNestedInput
  }

  export type ClinicInfoCreateManyInput = {
    id?: string
    clinicName: string
    addressId: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    scheduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    user?: UserCreateNestedOneWithoutAddressInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    userId?: string | null
    clinicInfo?: ClinicInfoUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAddressNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfo?: ClinicInfoUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    userId?: string | null
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationCreateInput = {
    id?: string
    university: string
    degree: string
    duration: string
    serviceProvider: ServiceProviderCreateNestedOneWithoutEducationInput
  }

  export type EducationUncheckedCreateInput = {
    id?: string
    university: string
    degree: string
    duration: string
    serviceProviderId: string
  }

  export type EducationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    university?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    university?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type EducationCreateManyInput = {
    id?: string
    university: string
    degree: string
    duration: string
    serviceProviderId: string
  }

  export type EducationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    university?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type EducationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    university?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkExperienceCreateInput = {
    id?: string
    clinic: string
    duration: string
    serviceProvider: ServiceProviderCreateNestedOneWithoutWorkExperienceInput
  }

  export type WorkExperienceUncheckedCreateInput = {
    id?: string
    clinic: string
    duration: string
    serviceProviderId: string
  }

  export type WorkExperienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinic?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinic?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkExperienceCreateManyInput = {
    id?: string
    clinic: string
    duration: string
    serviceProviderId: string
  }

  export type WorkExperienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinic?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type WorkExperienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinic?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type AwardCreateInput = {
    id?: string
    date: string
    title: string
    description: string
    serviceProvider: ServiceProviderCreateNestedOneWithoutAwardsInput
  }

  export type AwardUncheckedCreateInput = {
    id?: string
    date: string
    title: string
    description: string
    serviceProviderId: string
  }

  export type AwardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAwardsNestedInput
  }

  export type AwardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type AwardCreateManyInput = {
    id?: string
    date: string
    title: string
    description: string
    serviceProviderId: string
  }

  export type AwardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AwardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type CurrentLocationCreateInput = {
    id?: string
    lat: number
    long: number
    appointment?: AppointmentCreateNestedOneWithoutCurrentLocationInput
  }

  export type CurrentLocationUncheckedCreateInput = {
    id?: string
    lat: number
    long: number
    appointmentId?: string | null
  }

  export type CurrentLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    appointment?: AppointmentUpdateOneWithoutCurrentLocationNestedInput
  }

  export type CurrentLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CurrentLocationCreateManyInput = {
    id?: string
    lat: number
    long: number
    appointmentId?: string | null
  }

  export type CurrentLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
  }

  export type CurrentLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    entity: string
    entityId: string
    actionType: $Enums.ActionType
    status: $Enums.Status
    ipAddress?: string | null
    device?: string | null
    performedBy: string
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    entity: string
    entityId: string
    actionType: $Enums.ActionType
    status: $Enums.Status
    ipAddress?: string | null
    device?: string | null
    performedBy: string
    timestamp?: Date | string
    userId: string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    entity: string
    entityId: string
    actionType: $Enums.ActionType
    status: $Enums.Status
    ipAddress?: string | null
    device?: string | null
    performedBy: string
    timestamp?: Date | string
    userId: string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    message: string
    type: string
    priority?: string
    isRead?: boolean
    expiresAt?: Date | string | null
    isRecurring?: boolean
    groupId?: string | null
    createdAt?: Date | string
    relatedEntityId?: string | null
    relatedEntity?: string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    message: string
    type: string
    priority?: string
    isRead?: boolean
    expiresAt?: Date | string | null
    isRecurring?: boolean
    groupId?: string | null
    createdAt?: Date | string
    relatedEntityId?: string | null
    relatedEntity?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntity?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    message: string
    type: string
    priority?: string
    isRead?: boolean
    expiresAt?: Date | string | null
    isRecurring?: boolean
    groupId?: string | null
    createdAt?: Date | string
    relatedEntityId?: string | null
    relatedEntity?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderCreateNestedManyWithoutTagsInput
    appointments?: AppointmentCreateNestedManyWithoutTagsInput
    patients?: PatientCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderUncheckedCreateNestedManyWithoutTagsInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTagsInput
    patients?: PatientUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUpdateManyWithoutTagsNestedInput
    appointments?: AppointmentUpdateManyWithoutTagsNestedInput
    patients?: PatientUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUncheckedUpdateManyWithoutTagsNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTagsNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumBloodGroupNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodGroup | EnumBloodGroupFieldRefInput<$PrismaModel> | null
    in?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBloodGroupNullableFilter<$PrismaModel> | $Enums.BloodGroup | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type DoctorNullableScalarRelationFilter = {
    is?: DoctorWhereInput | null
    isNot?: DoctorWhereInput | null
  }

  export type SuperAdminNullableScalarRelationFilter = {
    is?: SuperAdminWhereInput | null
    isNot?: SuperAdminWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type LabNullableScalarRelationFilter = {
    is?: LabWhereInput | null
    isNot?: LabWhereInput | null
  }

  export type HospitalNullableScalarRelationFilter = {
    is?: HospitalWhereInput | null
    isNot?: HospitalWhereInput | null
  }

  export type NursingNullableScalarRelationFilter = {
    is?: NursingWhereInput | null
    isNot?: NursingWhereInput | null
  }

  export type DoctorsAssistantNullableScalarRelationFilter = {
    is?: DoctorsAssistantWhereInput | null
    isNot?: DoctorsAssistantWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type MedicalRecordListRelationFilter = {
    every?: MedicalRecordWhereInput
    some?: MedicalRecordWhereInput
    none?: MedicalRecordWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ServiceProviderListRelationFilter = {
    every?: ServiceProviderWhereInput
    some?: ServiceProviderWhereInput
    none?: ServiceProviderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    bloodGroup?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    profilePic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    bloodGroup?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    profilePic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    bloodGroup?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    profilePic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumBloodGroupNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodGroup | EnumBloodGroupFieldRefInput<$PrismaModel> | null
    in?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBloodGroupNullableWithAggregatesFilter<$PrismaModel> | $Enums.BloodGroup | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBloodGroupNullableFilter<$PrismaModel>
    _max?: NestedEnumBloodGroupNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderIdProviderAccountIdCompoundUniqueInput = {
    providerId: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationRequestIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumBloodGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodGroup | EnumBloodGroupFieldRefInput<$PrismaModel>
    in?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumBloodGroupFilter<$PrismaModel> | $Enums.BloodGroup
  }

  export type AllergyListRelationFilter = {
    every?: AllergyWhereInput
    some?: AllergyWhereInput
    none?: AllergyWhereInput
  }

  export type TherapyPlanListRelationFilter = {
    every?: TherapyPlanWhereInput
    some?: TherapyPlanWhereInput
    none?: TherapyPlanWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type LabResultListRelationFilter = {
    every?: LabResultWhereInput
    some?: LabResultWhereInput
    none?: LabResultWhereInput
  }

  export type AdminPanelScalarRelationFilter = {
    is?: AdminPanelWhereInput
    isNot?: AdminPanelWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type AllergyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TherapyPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    userId?: SortOrder
    conditions?: SortOrder
    bloodGroup?: SortOrder
    adminPanelId?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    userId?: SortOrder
    bloodGroup?: SortOrder
    adminPanelId?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    userId?: SortOrder
    bloodGroup?: SortOrder
    adminPanelId?: SortOrder
  }

  export type EnumBloodGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodGroup | EnumBloodGroupFieldRefInput<$PrismaModel>
    in?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumBloodGroupWithAggregatesFilter<$PrismaModel> | $Enums.BloodGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBloodGroupFilter<$PrismaModel>
    _max?: NestedEnumBloodGroupFilter<$PrismaModel>
  }

  export type EnumActionTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SuperAdminListRelationFilter = {
    every?: SuperAdminWhereInput
    some?: SuperAdminWhereInput
    none?: SuperAdminWhereInput
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type SuperAdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminPanelCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    canManageUsers?: SortOrder
    canManagePayments?: SortOrder
    canManageReports?: SortOrder
  }

  export type AdminPanelMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canManageUsers?: SortOrder
    canManagePayments?: SortOrder
    canManageReports?: SortOrder
  }

  export type AdminPanelMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canManageUsers?: SortOrder
    canManagePayments?: SortOrder
    canManageReports?: SortOrder
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type SuperAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    status?: SortOrder
    adminPanelId?: SortOrder
  }

  export type SuperAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminPanelId?: SortOrder
  }

  export type SuperAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminPanelId?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type SuperAdminScalarRelationFilter = {
    is?: SuperAdminWhereInput
    isNot?: SuperAdminWhereInput
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    canManageProviders?: SortOrder
    canViewAllTransactions?: SortOrder
    canViewAllAppointments?: SortOrder
    adminPanelId?: SortOrder
    superAdminId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canManageProviders?: SortOrder
    canViewAllTransactions?: SortOrder
    canViewAllAppointments?: SortOrder
    adminPanelId?: SortOrder
    superAdminId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canManageProviders?: SortOrder
    canViewAllTransactions?: SortOrder
    canViewAllAppointments?: SortOrder
    adminPanelId?: SortOrder
    superAdminId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumProviderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderType | EnumProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderTypeFilter<$PrismaModel> | $Enums.ProviderType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumServiceNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel> | null
    has?: $Enums.Service | EnumServiceFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type EducationListRelationFilter = {
    every?: EducationWhereInput
    some?: EducationWhereInput
    none?: EducationWhereInput
  }

  export type WorkExperienceListRelationFilter = {
    every?: WorkExperienceWhereInput
    some?: WorkExperienceWhereInput
    none?: WorkExperienceWhereInput
  }

  export type AwardListRelationFilter = {
    every?: AwardWhereInput
    some?: AwardWhereInput
    none?: AwardWhereInput
  }

  export type DoctorListRelationFilter = {
    every?: DoctorWhereInput
    some?: DoctorWhereInput
    none?: DoctorWhereInput
  }

  export type ClinicInfoNullableScalarRelationFilter = {
    is?: ClinicInfoWhereInput | null
    isNot?: ClinicInfoWhereInput | null
  }

  export type AdminPanelNullableScalarRelationFilter = {
    is?: AdminPanelWhereInput | null
    isNot?: AdminPanelWhereInput | null
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AwardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceProviderCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    age?: SortOrder
    dob?: SortOrder
    providerType?: SortOrder
    specialization?: SortOrder
    fee?: SortOrder
    experience?: SortOrder
    description?: SortOrder
    service?: SortOrder
    status?: SortOrder
    document?: SortOrder
    registrationNumber?: SortOrder
    clinicInfoId?: SortOrder
    adminPanelId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceProviderAvgOrderByAggregateInput = {
    age?: SortOrder
    fee?: SortOrder
    experience?: SortOrder
  }

  export type ServiceProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    age?: SortOrder
    dob?: SortOrder
    providerType?: SortOrder
    fee?: SortOrder
    experience?: SortOrder
    description?: SortOrder
    status?: SortOrder
    document?: SortOrder
    registrationNumber?: SortOrder
    clinicInfoId?: SortOrder
    adminPanelId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceProviderMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    age?: SortOrder
    dob?: SortOrder
    providerType?: SortOrder
    fee?: SortOrder
    experience?: SortOrder
    description?: SortOrder
    status?: SortOrder
    document?: SortOrder
    registrationNumber?: SortOrder
    clinicInfoId?: SortOrder
    adminPanelId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceProviderSumOrderByAggregateInput = {
    age?: SortOrder
    fee?: SortOrder
    experience?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProviderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderType | EnumProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProviderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderTypeFilter<$PrismaModel>
    _max?: NestedEnumProviderTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DoctorsAssistantListRelationFilter = {
    every?: DoctorsAssistantWhereInput
    some?: DoctorsAssistantWhereInput
    none?: DoctorsAssistantWhereInput
  }

  export type RequestListRelationFilter = {
    every?: RequestWhereInput
    some?: RequestWhereInput
    none?: RequestWhereInput
  }

  export type ServiceProviderScalarRelationFilter = {
    is?: ServiceProviderWhereInput
    isNot?: ServiceProviderWhereInput
  }

  export type DoctorsAssistantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceproviderId?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceproviderId?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceproviderId?: SortOrder
  }

  export type DoctorScalarRelationFilter = {
    is?: DoctorWhereInput
    isNot?: DoctorWhereInput
  }

  export type RequestPermissionListRelationFilter = {
    every?: RequestPermissionWhereInput
    some?: RequestPermissionWhereInput
    none?: RequestPermissionWhereInput
  }

  export type RequestPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorsAssistantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedDoctorId?: SortOrder
  }

  export type DoctorsAssistantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedDoctorId?: SortOrder
  }

  export type DoctorsAssistantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedDoctorId?: SortOrder
  }

  export type LabCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
  }

  export type LabMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LabMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HospitalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
  }

  export type HospitalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HospitalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NursingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    servicesOffered?: SortOrder
  }

  export type NursingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NursingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type AllergyCountOrderByAggregateInput = {
    id?: SortOrder
    allergen?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    reaction?: SortOrder
    patientId?: SortOrder
  }

  export type AllergyMaxOrderByAggregateInput = {
    id?: SortOrder
    allergen?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    reaction?: SortOrder
    patientId?: SortOrder
  }

  export type AllergyMinOrderByAggregateInput = {
    id?: SortOrder
    allergen?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    reaction?: SortOrder
    patientId?: SortOrder
  }

  export type PrescriptionNullableScalarRelationFilter = {
    is?: PrescriptionWhereInput | null
    isNot?: PrescriptionWhereInput | null
  }

  export type MedicationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    prescriptionId?: SortOrder
  }

  export type MedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    prescriptionId?: SortOrder
  }

  export type MedicationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    prescriptionId?: SortOrder
  }

  export type LabResultCountOrderByAggregateInput = {
    id?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    result?: SortOrder
    referenceRange?: SortOrder
    status?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
  }

  export type LabResultMaxOrderByAggregateInput = {
    id?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    result?: SortOrder
    referenceRange?: SortOrder
    status?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
  }

  export type LabResultMinOrderByAggregateInput = {
    id?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    result?: SortOrder
    referenceRange?: SortOrder
    status?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
  }

  export type ServiceProviderNullableScalarRelationFilter = {
    is?: ServiceProviderWhereInput | null
    isNot?: ServiceProviderWhereInput | null
  }

  export type MedicalRecordCountOrderByAggregateInput = {
    id?: SortOrder
    diagnosis?: SortOrder
    prescription?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    recordId?: SortOrder
    attachment?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type MedicalRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    diagnosis?: SortOrder
    prescription?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    recordId?: SortOrder
    attachment?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type MedicalRecordMinOrderByAggregateInput = {
    id?: SortOrder
    diagnosis?: SortOrder
    prescription?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    recordId?: SortOrder
    attachment?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type MedicationListRelationFilter = {
    every?: MedicationWhereInput
    some?: MedicationWhereInput
    none?: MedicationWhereInput
  }

  export type MedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    dateIssued?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    dateIssued?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    dateIssued?: SortOrder
  }

  export type TherapyPlanCountOrderByAggregateInput = {
    id?: SortOrder
    planName?: SortOrder
    date?: SortOrder
    type?: SortOrder
    status?: SortOrder
    details?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
  }

  export type TherapyPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    planName?: SortOrder
    date?: SortOrder
    type?: SortOrder
    status?: SortOrder
    details?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
  }

  export type TherapyPlanMinOrderByAggregateInput = {
    id?: SortOrder
    planName?: SortOrder
    date?: SortOrder
    type?: SortOrder
    status?: SortOrder
    details?: SortOrder
    patientId?: SortOrder
    serviceProvideId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type AppointmentScalarRelationFilter = {
    is?: AppointmentWhereInput
    isNot?: AppointmentWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    refundDetails?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    refundDetails?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    refundDetails?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    gatewayTransactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundDetails?: SortOrder
    paymentId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    gatewayTransactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundDetails?: SortOrder
    paymentId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    gatewayTransactionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundDetails?: SortOrder
    paymentId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceProviderType?: SortOrder
    serviceProviderId?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceProviderType?: SortOrder
    serviceProviderId?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceProviderType?: SortOrder
    serviceProviderId?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumPermissionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionType | EnumPermissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionType[] | ListEnumPermissionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionType[] | ListEnumPermissionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionTypeFilter<$PrismaModel> | $Enums.PermissionType
  }

  export type RequestPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    accessType?: SortOrder
    doctorsAssistantId?: SortOrder
  }

  export type RequestPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    accessType?: SortOrder
    doctorsAssistantId?: SortOrder
  }

  export type RequestPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    accessType?: SortOrder
    doctorsAssistantId?: SortOrder
  }

  export type EnumPermissionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionType | EnumPermissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionType[] | ListEnumPermissionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionType[] | ListEnumPermissionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PermissionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionTypeFilter<$PrismaModel>
    _max?: NestedEnumPermissionTypeFilter<$PrismaModel>
  }

  export type RequestCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrder
  }

  export type RequestMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrder
  }

  export type RequestMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrder
  }

  export type OthersAppointmentNullableScalarRelationFilter = {
    is?: OthersAppointmentWhereInput | null
    isNot?: OthersAppointmentWhereInput | null
  }

  export type CurrentLocationNullableScalarRelationFilter = {
    is?: CurrentLocationWhereInput | null
    isNot?: CurrentLocationWhereInput | null
  }

  export type SlotScalarRelationFilter = {
    is?: SlotWhereInput
    isNot?: SlotWhereInput
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    appointmentTime?: SortOrder
    bookedAt?: SortOrder
    reason?: SortOrder
    isForOthers?: SortOrder
    slotId?: SortOrder
    userId?: SortOrder
    serviceProviderId?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    appointmentTime?: SortOrder
    bookedAt?: SortOrder
    reason?: SortOrder
    isForOthers?: SortOrder
    slotId?: SortOrder
    userId?: SortOrder
    serviceProviderId?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    appointmentTime?: SortOrder
    bookedAt?: SortOrder
    reason?: SortOrder
    isForOthers?: SortOrder
    slotId?: SortOrder
    userId?: SortOrder
    serviceProviderId?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type OthersAppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    relationship?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    reason?: SortOrder
    appointmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OthersAppointmentAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type OthersAppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    relationship?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    reason?: SortOrder
    appointmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OthersAppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    relationship?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    reason?: SortOrder
    appointmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OthersAppointmentSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumWeekDayNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDay | EnumWeekDayFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWeekDayNullableFilter<$PrismaModel> | $Enums.WeekDay | null
  }

  export type EnumRecurrenceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceType | EnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrenceType[] | ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrenceType[] | ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceTypeNullableFilter<$PrismaModel> | $Enums.RecurrenceType | null
  }

  export type EnumServiceFilter<$PrismaModel = never> = {
    equals?: $Enums.Service | EnumServiceFieldRefInput<$PrismaModel>
    in?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceFilter<$PrismaModel> | $Enums.Service
  }

  export type SlotListRelationFilter = {
    every?: SlotWhereInput
    some?: SlotWhereInput
    none?: SlotWhereInput
  }

  export type ClinicInfoListRelationFilter = {
    every?: ClinicInfoWhereInput
    some?: ClinicInfoWhereInput
    none?: ClinicInfoWhereInput
  }

  export type SlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    isRecurring?: SortOrder
    recurrenceType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotDuration?: SortOrder
    location?: SortOrder
    isAvailable?: SortOrder
    service?: SortOrder
    status?: SortOrder
    serviceProviderId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    slotDuration?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    isRecurring?: SortOrder
    recurrenceType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotDuration?: SortOrder
    location?: SortOrder
    isAvailable?: SortOrder
    service?: SortOrder
    status?: SortOrder
    serviceProviderId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    isRecurring?: SortOrder
    recurrenceType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotDuration?: SortOrder
    location?: SortOrder
    isAvailable?: SortOrder
    service?: SortOrder
    status?: SortOrder
    serviceProviderId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    slotDuration?: SortOrder
  }

  export type EnumWeekDayNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDay | EnumWeekDayFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWeekDayNullableWithAggregatesFilter<$PrismaModel> | $Enums.WeekDay | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWeekDayNullableFilter<$PrismaModel>
    _max?: NestedEnumWeekDayNullableFilter<$PrismaModel>
  }

  export type EnumRecurrenceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceType | EnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrenceType[] | ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrenceType[] | ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurrenceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceTypeNullableFilter<$PrismaModel>
  }

  export type EnumServiceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Service | EnumServiceFieldRefInput<$PrismaModel>
    in?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceWithAggregatesFilter<$PrismaModel> | $Enums.Service
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceFilter<$PrismaModel>
    _max?: NestedEnumServiceFilter<$PrismaModel>
  }

  export type ScheduleScalarRelationFilter = {
    is?: ScheduleWhereInput
    isNot?: ScheduleWhereInput
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type SlotCountOrderByAggregateInput = {
    id?: SortOrder
    slotDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isBooked?: SortOrder
    scheduleId?: SortOrder
    bookedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotMaxOrderByAggregateInput = {
    id?: SortOrder
    slotDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isBooked?: SortOrder
    scheduleId?: SortOrder
    bookedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotMinOrderByAggregateInput = {
    id?: SortOrder
    slotDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isBooked?: SortOrder
    scheduleId?: SortOrder
    bookedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressScalarRelationFilter = {
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type ScheduleNullableScalarRelationFilter = {
    is?: ScheduleWhereInput | null
    isNot?: ScheduleWhereInput | null
  }

  export type ClinicInfoCountOrderByAggregateInput = {
    id?: SortOrder
    clinicName?: SortOrder
    addressId?: SortOrder
    phone?: SortOrder
    images?: SortOrder
    scheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicName?: SortOrder
    addressId?: SortOrder
    phone?: SortOrder
    scheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicInfoMinOrderByAggregateInput = {
    id?: SortOrder
    clinicName?: SortOrder
    addressId?: SortOrder
    phone?: SortOrder
    scheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    userId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    userId?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    userId?: SortOrder
  }

  export type EducationCountOrderByAggregateInput = {
    id?: SortOrder
    university?: SortOrder
    degree?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type EducationMaxOrderByAggregateInput = {
    id?: SortOrder
    university?: SortOrder
    degree?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type EducationMinOrderByAggregateInput = {
    id?: SortOrder
    university?: SortOrder
    degree?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type WorkExperienceCountOrderByAggregateInput = {
    id?: SortOrder
    clinic?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type WorkExperienceMaxOrderByAggregateInput = {
    id?: SortOrder
    clinic?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type WorkExperienceMinOrderByAggregateInput = {
    id?: SortOrder
    clinic?: SortOrder
    duration?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type AwardCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    title?: SortOrder
    description?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type AwardMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    title?: SortOrder
    description?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type AwardMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    title?: SortOrder
    description?: SortOrder
    serviceProviderId?: SortOrder
  }

  export type CurrentLocationCountOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    appointmentId?: SortOrder
  }

  export type CurrentLocationAvgOrderByAggregateInput = {
    lat?: SortOrder
    long?: SortOrder
  }

  export type CurrentLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    appointmentId?: SortOrder
  }

  export type CurrentLocationMinOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    appointmentId?: SortOrder
  }

  export type CurrentLocationSumOrderByAggregateInput = {
    lat?: SortOrder
    long?: SortOrder
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    performedBy?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    performedBy?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    performedBy?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    expiresAt?: SortOrder
    isRecurring?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntity?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    expiresAt?: SortOrder
    isRecurring?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntity?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    expiresAt?: SortOrder
    isRecurring?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntity?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    connect?: AddressWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput> | PatientCreateWithoutUserInput[] | PatientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput | PatientCreateOrConnectWithoutUserInput[]
    createMany?: PatientCreateManyUserInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type DoctorCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    connect?: DoctorWhereUniqueInput
  }

  export type SuperAdminCreateNestedOneWithoutUserInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type LabCreateNestedOneWithoutUserInput = {
    create?: XOR<LabCreateWithoutUserInput, LabUncheckedCreateWithoutUserInput>
    connectOrCreate?: LabCreateOrConnectWithoutUserInput
    connect?: LabWhereUniqueInput
  }

  export type HospitalCreateNestedOneWithoutUserInput = {
    create?: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutUserInput
    connect?: HospitalWhereUniqueInput
  }

  export type NursingCreateNestedOneWithoutUserInput = {
    create?: XOR<NursingCreateWithoutUserInput, NursingUncheckedCreateWithoutUserInput>
    connectOrCreate?: NursingCreateOrConnectWithoutUserInput
    connect?: NursingWhereUniqueInput
  }

  export type DoctorsAssistantCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorsAssistantCreateWithoutUserInput, DoctorsAssistantUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutUserInput
    connect?: DoctorsAssistantWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MedicalRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicalRecordCreateWithoutUserInput, MedicalRecordUncheckedCreateWithoutUserInput> | MedicalRecordCreateWithoutUserInput[] | MedicalRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutUserInput | MedicalRecordCreateOrConnectWithoutUserInput[]
    createMany?: MedicalRecordCreateManyUserInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ServiceProviderCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceProviderCreateWithoutUserInput, ServiceProviderUncheckedCreateWithoutUserInput> | ServiceProviderCreateWithoutUserInput[] | ServiceProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutUserInput | ServiceProviderCreateOrConnectWithoutUserInput[]
    createMany?: ServiceProviderCreateManyUserInputEnvelope
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    connect?: AddressWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput> | PatientCreateWithoutUserInput[] | PatientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput | PatientCreateOrConnectWithoutUserInput[]
    createMany?: PatientCreateManyUserInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type DoctorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    connect?: DoctorWhereUniqueInput
  }

  export type SuperAdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type LabUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LabCreateWithoutUserInput, LabUncheckedCreateWithoutUserInput>
    connectOrCreate?: LabCreateOrConnectWithoutUserInput
    connect?: LabWhereUniqueInput
  }

  export type HospitalUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutUserInput
    connect?: HospitalWhereUniqueInput
  }

  export type NursingUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NursingCreateWithoutUserInput, NursingUncheckedCreateWithoutUserInput>
    connectOrCreate?: NursingCreateOrConnectWithoutUserInput
    connect?: NursingWhereUniqueInput
  }

  export type DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorsAssistantCreateWithoutUserInput, DoctorsAssistantUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutUserInput
    connect?: DoctorsAssistantWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicalRecordCreateWithoutUserInput, MedicalRecordUncheckedCreateWithoutUserInput> | MedicalRecordCreateWithoutUserInput[] | MedicalRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutUserInput | MedicalRecordCreateOrConnectWithoutUserInput[]
    createMany?: MedicalRecordCreateManyUserInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ServiceProviderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceProviderCreateWithoutUserInput, ServiceProviderUncheckedCreateWithoutUserInput> | ServiceProviderCreateWithoutUserInput[] | ServiceProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutUserInput | ServiceProviderCreateOrConnectWithoutUserInput[]
    createMany?: ServiceProviderCreateManyUserInputEnvelope
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableEnumBloodGroupFieldUpdateOperationsInput = {
    set?: $Enums.BloodGroup | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AddressUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    upsert?: AddressUpsertWithoutUserInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutUserInput, AddressUpdateWithoutUserInput>, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput> | PatientCreateWithoutUserInput[] | PatientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput | PatientCreateOrConnectWithoutUserInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutUserInput | PatientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PatientCreateManyUserInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutUserInput | PatientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutUserInput | PatientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type DoctorUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    upsert?: DoctorUpsertWithoutUserInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutUserInput, DoctorUpdateWithoutUserInput>, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type SuperAdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    upsert?: SuperAdminUpsertWithoutUserInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutUserInput, SuperAdminUpdateWithoutUserInput>, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type LabUpdateOneWithoutUserNestedInput = {
    create?: XOR<LabCreateWithoutUserInput, LabUncheckedCreateWithoutUserInput>
    connectOrCreate?: LabCreateOrConnectWithoutUserInput
    upsert?: LabUpsertWithoutUserInput
    disconnect?: LabWhereInput | boolean
    delete?: LabWhereInput | boolean
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutUserInput, LabUpdateWithoutUserInput>, LabUncheckedUpdateWithoutUserInput>
  }

  export type HospitalUpdateOneWithoutUserNestedInput = {
    create?: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutUserInput
    upsert?: HospitalUpsertWithoutUserInput
    disconnect?: HospitalWhereInput | boolean
    delete?: HospitalWhereInput | boolean
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutUserInput, HospitalUpdateWithoutUserInput>, HospitalUncheckedUpdateWithoutUserInput>
  }

  export type NursingUpdateOneWithoutUserNestedInput = {
    create?: XOR<NursingCreateWithoutUserInput, NursingUncheckedCreateWithoutUserInput>
    connectOrCreate?: NursingCreateOrConnectWithoutUserInput
    upsert?: NursingUpsertWithoutUserInput
    disconnect?: NursingWhereInput | boolean
    delete?: NursingWhereInput | boolean
    connect?: NursingWhereUniqueInput
    update?: XOR<XOR<NursingUpdateToOneWithWhereWithoutUserInput, NursingUpdateWithoutUserInput>, NursingUncheckedUpdateWithoutUserInput>
  }

  export type DoctorsAssistantUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorsAssistantCreateWithoutUserInput, DoctorsAssistantUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutUserInput
    upsert?: DoctorsAssistantUpsertWithoutUserInput
    disconnect?: DoctorsAssistantWhereInput | boolean
    delete?: DoctorsAssistantWhereInput | boolean
    connect?: DoctorsAssistantWhereUniqueInput
    update?: XOR<XOR<DoctorsAssistantUpdateToOneWithWhereWithoutUserInput, DoctorsAssistantUpdateWithoutUserInput>, DoctorsAssistantUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MedicalRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutUserInput, MedicalRecordUncheckedCreateWithoutUserInput> | MedicalRecordCreateWithoutUserInput[] | MedicalRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutUserInput | MedicalRecordCreateOrConnectWithoutUserInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutUserInput | MedicalRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicalRecordCreateManyUserInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutUserInput | MedicalRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutUserInput | MedicalRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserInput | AppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserInput | AppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserInput | AppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ServiceProviderUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutUserInput, ServiceProviderUncheckedCreateWithoutUserInput> | ServiceProviderCreateWithoutUserInput[] | ServiceProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutUserInput | ServiceProviderCreateOrConnectWithoutUserInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutUserInput | ServiceProviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceProviderCreateManyUserInputEnvelope
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutUserInput | ServiceProviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutUserInput | ServiceProviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    upsert?: AddressUpsertWithoutUserInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutUserInput, AddressUpdateWithoutUserInput>, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput> | PatientCreateWithoutUserInput[] | PatientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput | PatientCreateOrConnectWithoutUserInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutUserInput | PatientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PatientCreateManyUserInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutUserInput | PatientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutUserInput | PatientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type DoctorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    upsert?: DoctorUpsertWithoutUserInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutUserInput, DoctorUpdateWithoutUserInput>, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type SuperAdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    upsert?: SuperAdminUpsertWithoutUserInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutUserInput, SuperAdminUpdateWithoutUserInput>, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type LabUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LabCreateWithoutUserInput, LabUncheckedCreateWithoutUserInput>
    connectOrCreate?: LabCreateOrConnectWithoutUserInput
    upsert?: LabUpsertWithoutUserInput
    disconnect?: LabWhereInput | boolean
    delete?: LabWhereInput | boolean
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutUserInput, LabUpdateWithoutUserInput>, LabUncheckedUpdateWithoutUserInput>
  }

  export type HospitalUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutUserInput
    upsert?: HospitalUpsertWithoutUserInput
    disconnect?: HospitalWhereInput | boolean
    delete?: HospitalWhereInput | boolean
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutUserInput, HospitalUpdateWithoutUserInput>, HospitalUncheckedUpdateWithoutUserInput>
  }

  export type NursingUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NursingCreateWithoutUserInput, NursingUncheckedCreateWithoutUserInput>
    connectOrCreate?: NursingCreateOrConnectWithoutUserInput
    upsert?: NursingUpsertWithoutUserInput
    disconnect?: NursingWhereInput | boolean
    delete?: NursingWhereInput | boolean
    connect?: NursingWhereUniqueInput
    update?: XOR<XOR<NursingUpdateToOneWithWhereWithoutUserInput, NursingUpdateWithoutUserInput>, NursingUncheckedUpdateWithoutUserInput>
  }

  export type DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorsAssistantCreateWithoutUserInput, DoctorsAssistantUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutUserInput
    upsert?: DoctorsAssistantUpsertWithoutUserInput
    disconnect?: DoctorsAssistantWhereInput | boolean
    delete?: DoctorsAssistantWhereInput | boolean
    connect?: DoctorsAssistantWhereUniqueInput
    update?: XOR<XOR<DoctorsAssistantUpdateToOneWithWhereWithoutUserInput, DoctorsAssistantUpdateWithoutUserInput>, DoctorsAssistantUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MedicalRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutUserInput, MedicalRecordUncheckedCreateWithoutUserInput> | MedicalRecordCreateWithoutUserInput[] | MedicalRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutUserInput | MedicalRecordCreateOrConnectWithoutUserInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutUserInput | MedicalRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicalRecordCreateManyUserInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutUserInput | MedicalRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutUserInput | MedicalRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserInput | AppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserInput | AppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserInput | AppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ServiceProviderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutUserInput, ServiceProviderUncheckedCreateWithoutUserInput> | ServiceProviderCreateWithoutUserInput[] | ServiceProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutUserInput | ServiceProviderCreateOrConnectWithoutUserInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutUserInput | ServiceProviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceProviderCreateManyUserInputEnvelope
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutUserInput | ServiceProviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutUserInput | ServiceProviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type PatientCreateconditionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutPatientInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    connect?: UserWhereUniqueInput
  }

  export type AllergyCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
  }

  export type TherapyPlanCreateNestedManyWithoutPatientInput = {
    create?: XOR<TherapyPlanCreateWithoutPatientInput, TherapyPlanUncheckedCreateWithoutPatientInput> | TherapyPlanCreateWithoutPatientInput[] | TherapyPlanUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TherapyPlanCreateOrConnectWithoutPatientInput | TherapyPlanCreateOrConnectWithoutPatientInput[]
    createMany?: TherapyPlanCreateManyPatientInputEnvelope
    connect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type LabResultCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabResultCreateWithoutPatientInput, LabResultUncheckedCreateWithoutPatientInput> | LabResultCreateWithoutPatientInput[] | LabResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutPatientInput | LabResultCreateOrConnectWithoutPatientInput[]
    createMany?: LabResultCreateManyPatientInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type AdminPanelCreateNestedOneWithoutPatientInput = {
    create?: XOR<AdminPanelCreateWithoutPatientInput, AdminPanelUncheckedCreateWithoutPatientInput>
    connectOrCreate?: AdminPanelCreateOrConnectWithoutPatientInput
    connect?: AdminPanelWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutPatientsInput = {
    create?: XOR<TagCreateWithoutPatientsInput, TagUncheckedCreateWithoutPatientsInput> | TagCreateWithoutPatientsInput[] | TagUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPatientsInput | TagCreateOrConnectWithoutPatientsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type AllergyUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
  }

  export type TherapyPlanUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TherapyPlanCreateWithoutPatientInput, TherapyPlanUncheckedCreateWithoutPatientInput> | TherapyPlanCreateWithoutPatientInput[] | TherapyPlanUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TherapyPlanCreateOrConnectWithoutPatientInput | TherapyPlanCreateOrConnectWithoutPatientInput[]
    createMany?: TherapyPlanCreateManyPatientInputEnvelope
    connect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type LabResultUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabResultCreateWithoutPatientInput, LabResultUncheckedCreateWithoutPatientInput> | LabResultCreateWithoutPatientInput[] | LabResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutPatientInput | LabResultCreateOrConnectWithoutPatientInput[]
    createMany?: LabResultCreateManyPatientInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<TagCreateWithoutPatientsInput, TagUncheckedCreateWithoutPatientsInput> | TagCreateWithoutPatientsInput[] | TagUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPatientsInput | TagCreateOrConnectWithoutPatientsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type PatientUpdateconditionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumBloodGroupFieldUpdateOperationsInput = {
    set?: $Enums.BloodGroup
  }

  export type UserUpdateOneRequiredWithoutPatientNestedInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    upsert?: UserUpsertWithoutPatientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatientInput, UserUpdateWithoutPatientInput>, UserUncheckedUpdateWithoutPatientInput>
  }

  export type AllergyUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    upsert?: AllergyUpsertWithWhereUniqueWithoutPatientInput | AllergyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    set?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    disconnect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    delete?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    update?: AllergyUpdateWithWhereUniqueWithoutPatientInput | AllergyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergyUpdateManyWithWhereWithoutPatientInput | AllergyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
  }

  export type TherapyPlanUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TherapyPlanCreateWithoutPatientInput, TherapyPlanUncheckedCreateWithoutPatientInput> | TherapyPlanCreateWithoutPatientInput[] | TherapyPlanUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TherapyPlanCreateOrConnectWithoutPatientInput | TherapyPlanCreateOrConnectWithoutPatientInput[]
    upsert?: TherapyPlanUpsertWithWhereUniqueWithoutPatientInput | TherapyPlanUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TherapyPlanCreateManyPatientInputEnvelope
    set?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    disconnect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    delete?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    connect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    update?: TherapyPlanUpdateWithWhereUniqueWithoutPatientInput | TherapyPlanUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TherapyPlanUpdateManyWithWhereWithoutPatientInput | TherapyPlanUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TherapyPlanScalarWhereInput | TherapyPlanScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type LabResultUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabResultCreateWithoutPatientInput, LabResultUncheckedCreateWithoutPatientInput> | LabResultCreateWithoutPatientInput[] | LabResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutPatientInput | LabResultCreateOrConnectWithoutPatientInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutPatientInput | LabResultUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabResultCreateManyPatientInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutPatientInput | LabResultUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutPatientInput | LabResultUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type AdminPanelUpdateOneRequiredWithoutPatientNestedInput = {
    create?: XOR<AdminPanelCreateWithoutPatientInput, AdminPanelUncheckedCreateWithoutPatientInput>
    connectOrCreate?: AdminPanelCreateOrConnectWithoutPatientInput
    upsert?: AdminPanelUpsertWithoutPatientInput
    connect?: AdminPanelWhereUniqueInput
    update?: XOR<XOR<AdminPanelUpdateToOneWithWhereWithoutPatientInput, AdminPanelUpdateWithoutPatientInput>, AdminPanelUncheckedUpdateWithoutPatientInput>
  }

  export type TagUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<TagCreateWithoutPatientsInput, TagUncheckedCreateWithoutPatientsInput> | TagCreateWithoutPatientsInput[] | TagUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPatientsInput | TagCreateOrConnectWithoutPatientsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPatientsInput | TagUpsertWithWhereUniqueWithoutPatientsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPatientsInput | TagUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPatientsInput | TagUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type AllergyUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    upsert?: AllergyUpsertWithWhereUniqueWithoutPatientInput | AllergyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    set?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    disconnect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    delete?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    update?: AllergyUpdateWithWhereUniqueWithoutPatientInput | AllergyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergyUpdateManyWithWhereWithoutPatientInput | AllergyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
  }

  export type TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TherapyPlanCreateWithoutPatientInput, TherapyPlanUncheckedCreateWithoutPatientInput> | TherapyPlanCreateWithoutPatientInput[] | TherapyPlanUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TherapyPlanCreateOrConnectWithoutPatientInput | TherapyPlanCreateOrConnectWithoutPatientInput[]
    upsert?: TherapyPlanUpsertWithWhereUniqueWithoutPatientInput | TherapyPlanUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TherapyPlanCreateManyPatientInputEnvelope
    set?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    disconnect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    delete?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    connect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    update?: TherapyPlanUpdateWithWhereUniqueWithoutPatientInput | TherapyPlanUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TherapyPlanUpdateManyWithWhereWithoutPatientInput | TherapyPlanUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TherapyPlanScalarWhereInput | TherapyPlanScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type LabResultUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabResultCreateWithoutPatientInput, LabResultUncheckedCreateWithoutPatientInput> | LabResultCreateWithoutPatientInput[] | LabResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutPatientInput | LabResultCreateOrConnectWithoutPatientInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutPatientInput | LabResultUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabResultCreateManyPatientInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutPatientInput | LabResultUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutPatientInput | LabResultUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<TagCreateWithoutPatientsInput, TagUncheckedCreateWithoutPatientsInput> | TagCreateWithoutPatientsInput[] | TagUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPatientsInput | TagCreateOrConnectWithoutPatientsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPatientsInput | TagUpsertWithWhereUniqueWithoutPatientsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPatientsInput | TagUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPatientsInput | TagUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type AdminPanelCreatepermissionsInput = {
    set: $Enums.ActionType[]
  }

  export type ServiceProviderCreateNestedManyWithoutAdminPanelInput = {
    create?: XOR<ServiceProviderCreateWithoutAdminPanelInput, ServiceProviderUncheckedCreateWithoutAdminPanelInput> | ServiceProviderCreateWithoutAdminPanelInput[] | ServiceProviderUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutAdminPanelInput | ServiceProviderCreateOrConnectWithoutAdminPanelInput[]
    createMany?: ServiceProviderCreateManyAdminPanelInputEnvelope
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutAdminPanelInput = {
    create?: XOR<PatientCreateWithoutAdminPanelInput, PatientUncheckedCreateWithoutAdminPanelInput> | PatientCreateWithoutAdminPanelInput[] | PatientUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutAdminPanelInput | PatientCreateOrConnectWithoutAdminPanelInput[]
    createMany?: PatientCreateManyAdminPanelInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type SuperAdminCreateNestedManyWithoutAdminPanelInput = {
    create?: XOR<SuperAdminCreateWithoutAdminPanelInput, SuperAdminUncheckedCreateWithoutAdminPanelInput> | SuperAdminCreateWithoutAdminPanelInput[] | SuperAdminUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: SuperAdminCreateOrConnectWithoutAdminPanelInput | SuperAdminCreateOrConnectWithoutAdminPanelInput[]
    createMany?: SuperAdminCreateManyAdminPanelInputEnvelope
    connect?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutAdminPanelInput = {
    create?: XOR<AdminCreateWithoutAdminPanelInput, AdminUncheckedCreateWithoutAdminPanelInput> | AdminCreateWithoutAdminPanelInput[] | AdminUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutAdminPanelInput | AdminCreateOrConnectWithoutAdminPanelInput[]
    createMany?: AdminCreateManyAdminPanelInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type ServiceProviderUncheckedCreateNestedManyWithoutAdminPanelInput = {
    create?: XOR<ServiceProviderCreateWithoutAdminPanelInput, ServiceProviderUncheckedCreateWithoutAdminPanelInput> | ServiceProviderCreateWithoutAdminPanelInput[] | ServiceProviderUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutAdminPanelInput | ServiceProviderCreateOrConnectWithoutAdminPanelInput[]
    createMany?: ServiceProviderCreateManyAdminPanelInputEnvelope
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutAdminPanelInput = {
    create?: XOR<PatientCreateWithoutAdminPanelInput, PatientUncheckedCreateWithoutAdminPanelInput> | PatientCreateWithoutAdminPanelInput[] | PatientUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutAdminPanelInput | PatientCreateOrConnectWithoutAdminPanelInput[]
    createMany?: PatientCreateManyAdminPanelInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type SuperAdminUncheckedCreateNestedManyWithoutAdminPanelInput = {
    create?: XOR<SuperAdminCreateWithoutAdminPanelInput, SuperAdminUncheckedCreateWithoutAdminPanelInput> | SuperAdminCreateWithoutAdminPanelInput[] | SuperAdminUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: SuperAdminCreateOrConnectWithoutAdminPanelInput | SuperAdminCreateOrConnectWithoutAdminPanelInput[]
    createMany?: SuperAdminCreateManyAdminPanelInputEnvelope
    connect?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutAdminPanelInput = {
    create?: XOR<AdminCreateWithoutAdminPanelInput, AdminUncheckedCreateWithoutAdminPanelInput> | AdminCreateWithoutAdminPanelInput[] | AdminUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutAdminPanelInput | AdminCreateOrConnectWithoutAdminPanelInput[]
    createMany?: AdminCreateManyAdminPanelInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminPanelUpdatepermissionsInput = {
    set?: $Enums.ActionType[]
    push?: $Enums.ActionType | $Enums.ActionType[]
  }

  export type ServiceProviderUpdateManyWithoutAdminPanelNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutAdminPanelInput, ServiceProviderUncheckedCreateWithoutAdminPanelInput> | ServiceProviderCreateWithoutAdminPanelInput[] | ServiceProviderUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutAdminPanelInput | ServiceProviderCreateOrConnectWithoutAdminPanelInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutAdminPanelInput | ServiceProviderUpsertWithWhereUniqueWithoutAdminPanelInput[]
    createMany?: ServiceProviderCreateManyAdminPanelInputEnvelope
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutAdminPanelInput | ServiceProviderUpdateWithWhereUniqueWithoutAdminPanelInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutAdminPanelInput | ServiceProviderUpdateManyWithWhereWithoutAdminPanelInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutAdminPanelNestedInput = {
    create?: XOR<PatientCreateWithoutAdminPanelInput, PatientUncheckedCreateWithoutAdminPanelInput> | PatientCreateWithoutAdminPanelInput[] | PatientUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutAdminPanelInput | PatientCreateOrConnectWithoutAdminPanelInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutAdminPanelInput | PatientUpsertWithWhereUniqueWithoutAdminPanelInput[]
    createMany?: PatientCreateManyAdminPanelInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutAdminPanelInput | PatientUpdateWithWhereUniqueWithoutAdminPanelInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutAdminPanelInput | PatientUpdateManyWithWhereWithoutAdminPanelInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type SuperAdminUpdateManyWithoutAdminPanelNestedInput = {
    create?: XOR<SuperAdminCreateWithoutAdminPanelInput, SuperAdminUncheckedCreateWithoutAdminPanelInput> | SuperAdminCreateWithoutAdminPanelInput[] | SuperAdminUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: SuperAdminCreateOrConnectWithoutAdminPanelInput | SuperAdminCreateOrConnectWithoutAdminPanelInput[]
    upsert?: SuperAdminUpsertWithWhereUniqueWithoutAdminPanelInput | SuperAdminUpsertWithWhereUniqueWithoutAdminPanelInput[]
    createMany?: SuperAdminCreateManyAdminPanelInputEnvelope
    set?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
    disconnect?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
    delete?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
    connect?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
    update?: SuperAdminUpdateWithWhereUniqueWithoutAdminPanelInput | SuperAdminUpdateWithWhereUniqueWithoutAdminPanelInput[]
    updateMany?: SuperAdminUpdateManyWithWhereWithoutAdminPanelInput | SuperAdminUpdateManyWithWhereWithoutAdminPanelInput[]
    deleteMany?: SuperAdminScalarWhereInput | SuperAdminScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutAdminPanelNestedInput = {
    create?: XOR<AdminCreateWithoutAdminPanelInput, AdminUncheckedCreateWithoutAdminPanelInput> | AdminCreateWithoutAdminPanelInput[] | AdminUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutAdminPanelInput | AdminCreateOrConnectWithoutAdminPanelInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutAdminPanelInput | AdminUpsertWithWhereUniqueWithoutAdminPanelInput[]
    createMany?: AdminCreateManyAdminPanelInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutAdminPanelInput | AdminUpdateWithWhereUniqueWithoutAdminPanelInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutAdminPanelInput | AdminUpdateManyWithWhereWithoutAdminPanelInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type ServiceProviderUncheckedUpdateManyWithoutAdminPanelNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutAdminPanelInput, ServiceProviderUncheckedCreateWithoutAdminPanelInput> | ServiceProviderCreateWithoutAdminPanelInput[] | ServiceProviderUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutAdminPanelInput | ServiceProviderCreateOrConnectWithoutAdminPanelInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutAdminPanelInput | ServiceProviderUpsertWithWhereUniqueWithoutAdminPanelInput[]
    createMany?: ServiceProviderCreateManyAdminPanelInputEnvelope
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutAdminPanelInput | ServiceProviderUpdateWithWhereUniqueWithoutAdminPanelInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutAdminPanelInput | ServiceProviderUpdateManyWithWhereWithoutAdminPanelInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutAdminPanelNestedInput = {
    create?: XOR<PatientCreateWithoutAdminPanelInput, PatientUncheckedCreateWithoutAdminPanelInput> | PatientCreateWithoutAdminPanelInput[] | PatientUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutAdminPanelInput | PatientCreateOrConnectWithoutAdminPanelInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutAdminPanelInput | PatientUpsertWithWhereUniqueWithoutAdminPanelInput[]
    createMany?: PatientCreateManyAdminPanelInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutAdminPanelInput | PatientUpdateWithWhereUniqueWithoutAdminPanelInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutAdminPanelInput | PatientUpdateManyWithWhereWithoutAdminPanelInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type SuperAdminUncheckedUpdateManyWithoutAdminPanelNestedInput = {
    create?: XOR<SuperAdminCreateWithoutAdminPanelInput, SuperAdminUncheckedCreateWithoutAdminPanelInput> | SuperAdminCreateWithoutAdminPanelInput[] | SuperAdminUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: SuperAdminCreateOrConnectWithoutAdminPanelInput | SuperAdminCreateOrConnectWithoutAdminPanelInput[]
    upsert?: SuperAdminUpsertWithWhereUniqueWithoutAdminPanelInput | SuperAdminUpsertWithWhereUniqueWithoutAdminPanelInput[]
    createMany?: SuperAdminCreateManyAdminPanelInputEnvelope
    set?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
    disconnect?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
    delete?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
    connect?: SuperAdminWhereUniqueInput | SuperAdminWhereUniqueInput[]
    update?: SuperAdminUpdateWithWhereUniqueWithoutAdminPanelInput | SuperAdminUpdateWithWhereUniqueWithoutAdminPanelInput[]
    updateMany?: SuperAdminUpdateManyWithWhereWithoutAdminPanelInput | SuperAdminUpdateManyWithWhereWithoutAdminPanelInput[]
    deleteMany?: SuperAdminScalarWhereInput | SuperAdminScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutAdminPanelNestedInput = {
    create?: XOR<AdminCreateWithoutAdminPanelInput, AdminUncheckedCreateWithoutAdminPanelInput> | AdminCreateWithoutAdminPanelInput[] | AdminUncheckedCreateWithoutAdminPanelInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutAdminPanelInput | AdminCreateOrConnectWithoutAdminPanelInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutAdminPanelInput | AdminUpsertWithWhereUniqueWithoutAdminPanelInput[]
    createMany?: AdminCreateManyAdminPanelInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutAdminPanelInput | AdminUpdateWithWhereUniqueWithoutAdminPanelInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutAdminPanelInput | AdminUpdateManyWithWhereWithoutAdminPanelInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type SuperAdminCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSuperAdminInput = {
    create?: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminInput
    connect?: UserWhereUniqueInput
  }

  export type AdminCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput> | AdminCreateWithoutSuperAdminInput[] | AdminUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSuperAdminInput | AdminCreateOrConnectWithoutSuperAdminInput[]
    createMany?: AdminCreateManySuperAdminInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminPanelCreateNestedOneWithoutSuperAdminIdInput = {
    create?: XOR<AdminPanelCreateWithoutSuperAdminIdInput, AdminPanelUncheckedCreateWithoutSuperAdminIdInput>
    connectOrCreate?: AdminPanelCreateOrConnectWithoutSuperAdminIdInput
    connect?: AdminPanelWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput> | AdminCreateWithoutSuperAdminInput[] | AdminUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSuperAdminInput | AdminCreateOrConnectWithoutSuperAdminInput[]
    createMany?: AdminCreateManySuperAdminInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type SuperAdminUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type UserUpdateOneRequiredWithoutSuperAdminNestedInput = {
    create?: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminInput
    upsert?: UserUpsertWithoutSuperAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuperAdminInput, UserUpdateWithoutSuperAdminInput>, UserUncheckedUpdateWithoutSuperAdminInput>
  }

  export type AdminUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput> | AdminCreateWithoutSuperAdminInput[] | AdminUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSuperAdminInput | AdminCreateOrConnectWithoutSuperAdminInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSuperAdminInput | AdminUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: AdminCreateManySuperAdminInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSuperAdminInput | AdminUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSuperAdminInput | AdminUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminPanelUpdateOneRequiredWithoutSuperAdminIdNestedInput = {
    create?: XOR<AdminPanelCreateWithoutSuperAdminIdInput, AdminPanelUncheckedCreateWithoutSuperAdminIdInput>
    connectOrCreate?: AdminPanelCreateOrConnectWithoutSuperAdminIdInput
    upsert?: AdminPanelUpsertWithoutSuperAdminIdInput
    connect?: AdminPanelWhereUniqueInput
    update?: XOR<XOR<AdminPanelUpdateToOneWithWhereWithoutSuperAdminIdInput, AdminPanelUpdateWithoutSuperAdminIdInput>, AdminPanelUncheckedUpdateWithoutSuperAdminIdInput>
  }

  export type AdminUncheckedUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput> | AdminCreateWithoutSuperAdminInput[] | AdminUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSuperAdminInput | AdminCreateOrConnectWithoutSuperAdminInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSuperAdminInput | AdminUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: AdminCreateManySuperAdminInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSuperAdminInput | AdminUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSuperAdminInput | AdminUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type AdminPanelCreateNestedOneWithoutAdminIdInput = {
    create?: XOR<AdminPanelCreateWithoutAdminIdInput, AdminPanelUncheckedCreateWithoutAdminIdInput>
    connectOrCreate?: AdminPanelCreateOrConnectWithoutAdminIdInput
    connect?: AdminPanelWhereUniqueInput
  }

  export type SuperAdminCreateNestedOneWithoutAdminInput = {
    create?: XOR<SuperAdminCreateWithoutAdminInput, SuperAdminUncheckedCreateWithoutAdminInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutAdminInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type AdminUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type AdminPanelUpdateOneRequiredWithoutAdminIdNestedInput = {
    create?: XOR<AdminPanelCreateWithoutAdminIdInput, AdminPanelUncheckedCreateWithoutAdminIdInput>
    connectOrCreate?: AdminPanelCreateOrConnectWithoutAdminIdInput
    upsert?: AdminPanelUpsertWithoutAdminIdInput
    connect?: AdminPanelWhereUniqueInput
    update?: XOR<XOR<AdminPanelUpdateToOneWithWhereWithoutAdminIdInput, AdminPanelUpdateWithoutAdminIdInput>, AdminPanelUncheckedUpdateWithoutAdminIdInput>
  }

  export type SuperAdminUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<SuperAdminCreateWithoutAdminInput, SuperAdminUncheckedCreateWithoutAdminInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutAdminInput
    upsert?: SuperAdminUpsertWithoutAdminInput
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutAdminInput, SuperAdminUpdateWithoutAdminInput>, SuperAdminUncheckedUpdateWithoutAdminInput>
  }

  export type ServiceProviderCreatespecializationInput = {
    set: string[]
  }

  export type ServiceProviderCreateserviceInput = {
    set: $Enums.Service[]
  }

  export type ScheduleCreateNestedManyWithoutServiceProvidersInput = {
    create?: XOR<ScheduleCreateWithoutServiceProvidersInput, ScheduleUncheckedCreateWithoutServiceProvidersInput> | ScheduleCreateWithoutServiceProvidersInput[] | ScheduleUncheckedCreateWithoutServiceProvidersInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutServiceProvidersInput | ScheduleCreateOrConnectWithoutServiceProvidersInput[]
    createMany?: ScheduleCreateManyServiceProvidersInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EducationCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<EducationCreateWithoutServiceProviderInput, EducationUncheckedCreateWithoutServiceProviderInput> | EducationCreateWithoutServiceProviderInput[] | EducationUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutServiceProviderInput | EducationCreateOrConnectWithoutServiceProviderInput[]
    createMany?: EducationCreateManyServiceProviderInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type WorkExperienceCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<WorkExperienceCreateWithoutServiceProviderInput, WorkExperienceUncheckedCreateWithoutServiceProviderInput> | WorkExperienceCreateWithoutServiceProviderInput[] | WorkExperienceUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutServiceProviderInput | WorkExperienceCreateOrConnectWithoutServiceProviderInput[]
    createMany?: WorkExperienceCreateManyServiceProviderInputEnvelope
    connect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
  }

  export type AwardCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AwardCreateWithoutServiceProviderInput, AwardUncheckedCreateWithoutServiceProviderInput> | AwardCreateWithoutServiceProviderInput[] | AwardUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AwardCreateOrConnectWithoutServiceProviderInput | AwardCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AwardCreateManyServiceProviderInputEnvelope
    connect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
  }

  export type LabResultCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<LabResultCreateWithoutServiceProviderInput, LabResultUncheckedCreateWithoutServiceProviderInput> | LabResultCreateWithoutServiceProviderInput[] | LabResultUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutServiceProviderInput | LabResultCreateOrConnectWithoutServiceProviderInput[]
    createMany?: LabResultCreateManyServiceProviderInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type TherapyPlanCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<TherapyPlanCreateWithoutServiceProviderInput, TherapyPlanUncheckedCreateWithoutServiceProviderInput> | TherapyPlanCreateWithoutServiceProviderInput[] | TherapyPlanUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: TherapyPlanCreateOrConnectWithoutServiceProviderInput | TherapyPlanCreateOrConnectWithoutServiceProviderInput[]
    createMany?: TherapyPlanCreateManyServiceProviderInputEnvelope
    connect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput> | RatingCreateWithoutServiceProviderInput[] | RatingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutServiceProviderInput | RatingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: RatingCreateManyServiceProviderInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type MedicalRecordCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<MedicalRecordCreateWithoutServiceProviderInput, MedicalRecordUncheckedCreateWithoutServiceProviderInput> | MedicalRecordCreateWithoutServiceProviderInput[] | MedicalRecordUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutServiceProviderInput | MedicalRecordCreateOrConnectWithoutServiceProviderInput[]
    createMany?: MedicalRecordCreateManyServiceProviderInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type DoctorCreateNestedManyWithoutServiceproviderInput = {
    create?: XOR<DoctorCreateWithoutServiceproviderInput, DoctorUncheckedCreateWithoutServiceproviderInput> | DoctorCreateWithoutServiceproviderInput[] | DoctorUncheckedCreateWithoutServiceproviderInput[]
    connectOrCreate?: DoctorCreateOrConnectWithoutServiceproviderInput | DoctorCreateOrConnectWithoutServiceproviderInput[]
    createMany?: DoctorCreateManyServiceproviderInputEnvelope
    connect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
  }

  export type ClinicInfoCreateNestedOneWithoutServiceProvidersInput = {
    create?: XOR<ClinicInfoCreateWithoutServiceProvidersInput, ClinicInfoUncheckedCreateWithoutServiceProvidersInput>
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutServiceProvidersInput
    connect?: ClinicInfoWhereUniqueInput
  }

  export type AdminPanelCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<AdminPanelCreateWithoutServiceProviderInput, AdminPanelUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: AdminPanelCreateOrConnectWithoutServiceProviderInput
    connect?: AdminPanelWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutServiceProvidersInput = {
    create?: XOR<TagCreateWithoutServiceProvidersInput, TagUncheckedCreateWithoutServiceProvidersInput> | TagCreateWithoutServiceProvidersInput[] | TagUncheckedCreateWithoutServiceProvidersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutServiceProvidersInput | TagCreateOrConnectWithoutServiceProvidersInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<UserCreateWithoutServiceProviderInput, UserUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceProviderInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput = {
    create?: XOR<ScheduleCreateWithoutServiceProvidersInput, ScheduleUncheckedCreateWithoutServiceProvidersInput> | ScheduleCreateWithoutServiceProvidersInput[] | ScheduleUncheckedCreateWithoutServiceProvidersInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutServiceProvidersInput | ScheduleCreateOrConnectWithoutServiceProvidersInput[]
    createMany?: ScheduleCreateManyServiceProvidersInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EducationUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<EducationCreateWithoutServiceProviderInput, EducationUncheckedCreateWithoutServiceProviderInput> | EducationCreateWithoutServiceProviderInput[] | EducationUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutServiceProviderInput | EducationCreateOrConnectWithoutServiceProviderInput[]
    createMany?: EducationCreateManyServiceProviderInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<WorkExperienceCreateWithoutServiceProviderInput, WorkExperienceUncheckedCreateWithoutServiceProviderInput> | WorkExperienceCreateWithoutServiceProviderInput[] | WorkExperienceUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutServiceProviderInput | WorkExperienceCreateOrConnectWithoutServiceProviderInput[]
    createMany?: WorkExperienceCreateManyServiceProviderInputEnvelope
    connect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
  }

  export type AwardUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AwardCreateWithoutServiceProviderInput, AwardUncheckedCreateWithoutServiceProviderInput> | AwardCreateWithoutServiceProviderInput[] | AwardUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AwardCreateOrConnectWithoutServiceProviderInput | AwardCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AwardCreateManyServiceProviderInputEnvelope
    connect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
  }

  export type LabResultUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<LabResultCreateWithoutServiceProviderInput, LabResultUncheckedCreateWithoutServiceProviderInput> | LabResultCreateWithoutServiceProviderInput[] | LabResultUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutServiceProviderInput | LabResultCreateOrConnectWithoutServiceProviderInput[]
    createMany?: LabResultCreateManyServiceProviderInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<TherapyPlanCreateWithoutServiceProviderInput, TherapyPlanUncheckedCreateWithoutServiceProviderInput> | TherapyPlanCreateWithoutServiceProviderInput[] | TherapyPlanUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: TherapyPlanCreateOrConnectWithoutServiceProviderInput | TherapyPlanCreateOrConnectWithoutServiceProviderInput[]
    createMany?: TherapyPlanCreateManyServiceProviderInputEnvelope
    connect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput> | RatingCreateWithoutServiceProviderInput[] | RatingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutServiceProviderInput | RatingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: RatingCreateManyServiceProviderInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<MedicalRecordCreateWithoutServiceProviderInput, MedicalRecordUncheckedCreateWithoutServiceProviderInput> | MedicalRecordCreateWithoutServiceProviderInput[] | MedicalRecordUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutServiceProviderInput | MedicalRecordCreateOrConnectWithoutServiceProviderInput[]
    createMany?: MedicalRecordCreateManyServiceProviderInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type DoctorUncheckedCreateNestedManyWithoutServiceproviderInput = {
    create?: XOR<DoctorCreateWithoutServiceproviderInput, DoctorUncheckedCreateWithoutServiceproviderInput> | DoctorCreateWithoutServiceproviderInput[] | DoctorUncheckedCreateWithoutServiceproviderInput[]
    connectOrCreate?: DoctorCreateOrConnectWithoutServiceproviderInput | DoctorCreateOrConnectWithoutServiceproviderInput[]
    createMany?: DoctorCreateManyServiceproviderInputEnvelope
    connect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutServiceProvidersInput = {
    create?: XOR<TagCreateWithoutServiceProvidersInput, TagUncheckedCreateWithoutServiceProvidersInput> | TagCreateWithoutServiceProvidersInput[] | TagUncheckedCreateWithoutServiceProvidersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutServiceProvidersInput | TagCreateOrConnectWithoutServiceProvidersInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumProviderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProviderType
  }

  export type ServiceProviderUpdatespecializationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceProviderUpdateserviceInput = {
    set?: $Enums.Service[]
    push?: $Enums.Service | $Enums.Service[]
  }

  export type ScheduleUpdateManyWithoutServiceProvidersNestedInput = {
    create?: XOR<ScheduleCreateWithoutServiceProvidersInput, ScheduleUncheckedCreateWithoutServiceProvidersInput> | ScheduleCreateWithoutServiceProvidersInput[] | ScheduleUncheckedCreateWithoutServiceProvidersInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutServiceProvidersInput | ScheduleCreateOrConnectWithoutServiceProvidersInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutServiceProvidersInput | ScheduleUpsertWithWhereUniqueWithoutServiceProvidersInput[]
    createMany?: ScheduleCreateManyServiceProvidersInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutServiceProvidersInput | ScheduleUpdateWithWhereUniqueWithoutServiceProvidersInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutServiceProvidersInput | ScheduleUpdateManyWithWhereWithoutServiceProvidersInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput | AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput | AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceProviderInput | AppointmentUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EducationUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<EducationCreateWithoutServiceProviderInput, EducationUncheckedCreateWithoutServiceProviderInput> | EducationCreateWithoutServiceProviderInput[] | EducationUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutServiceProviderInput | EducationCreateOrConnectWithoutServiceProviderInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutServiceProviderInput | EducationUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: EducationCreateManyServiceProviderInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutServiceProviderInput | EducationUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutServiceProviderInput | EducationUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type WorkExperienceUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<WorkExperienceCreateWithoutServiceProviderInput, WorkExperienceUncheckedCreateWithoutServiceProviderInput> | WorkExperienceCreateWithoutServiceProviderInput[] | WorkExperienceUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutServiceProviderInput | WorkExperienceCreateOrConnectWithoutServiceProviderInput[]
    upsert?: WorkExperienceUpsertWithWhereUniqueWithoutServiceProviderInput | WorkExperienceUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: WorkExperienceCreateManyServiceProviderInputEnvelope
    set?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    disconnect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    delete?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    connect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    update?: WorkExperienceUpdateWithWhereUniqueWithoutServiceProviderInput | WorkExperienceUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: WorkExperienceUpdateManyWithWhereWithoutServiceProviderInput | WorkExperienceUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: WorkExperienceScalarWhereInput | WorkExperienceScalarWhereInput[]
  }

  export type AwardUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AwardCreateWithoutServiceProviderInput, AwardUncheckedCreateWithoutServiceProviderInput> | AwardCreateWithoutServiceProviderInput[] | AwardUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AwardCreateOrConnectWithoutServiceProviderInput | AwardCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AwardUpsertWithWhereUniqueWithoutServiceProviderInput | AwardUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AwardCreateManyServiceProviderInputEnvelope
    set?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    disconnect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    delete?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    connect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    update?: AwardUpdateWithWhereUniqueWithoutServiceProviderInput | AwardUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AwardUpdateManyWithWhereWithoutServiceProviderInput | AwardUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AwardScalarWhereInput | AwardScalarWhereInput[]
  }

  export type LabResultUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<LabResultCreateWithoutServiceProviderInput, LabResultUncheckedCreateWithoutServiceProviderInput> | LabResultCreateWithoutServiceProviderInput[] | LabResultUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutServiceProviderInput | LabResultCreateOrConnectWithoutServiceProviderInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutServiceProviderInput | LabResultUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: LabResultCreateManyServiceProviderInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutServiceProviderInput | LabResultUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutServiceProviderInput | LabResultUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type TherapyPlanUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<TherapyPlanCreateWithoutServiceProviderInput, TherapyPlanUncheckedCreateWithoutServiceProviderInput> | TherapyPlanCreateWithoutServiceProviderInput[] | TherapyPlanUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: TherapyPlanCreateOrConnectWithoutServiceProviderInput | TherapyPlanCreateOrConnectWithoutServiceProviderInput[]
    upsert?: TherapyPlanUpsertWithWhereUniqueWithoutServiceProviderInput | TherapyPlanUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: TherapyPlanCreateManyServiceProviderInputEnvelope
    set?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    disconnect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    delete?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    connect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    update?: TherapyPlanUpdateWithWhereUniqueWithoutServiceProviderInput | TherapyPlanUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: TherapyPlanUpdateManyWithWhereWithoutServiceProviderInput | TherapyPlanUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: TherapyPlanScalarWhereInput | TherapyPlanScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput> | RatingCreateWithoutServiceProviderInput[] | RatingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutServiceProviderInput | RatingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutServiceProviderInput | RatingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: RatingCreateManyServiceProviderInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutServiceProviderInput | RatingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutServiceProviderInput | RatingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type MedicalRecordUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutServiceProviderInput, MedicalRecordUncheckedCreateWithoutServiceProviderInput> | MedicalRecordCreateWithoutServiceProviderInput[] | MedicalRecordUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutServiceProviderInput | MedicalRecordCreateOrConnectWithoutServiceProviderInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutServiceProviderInput | MedicalRecordUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: MedicalRecordCreateManyServiceProviderInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutServiceProviderInput | MedicalRecordUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutServiceProviderInput | MedicalRecordUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type DoctorUpdateManyWithoutServiceproviderNestedInput = {
    create?: XOR<DoctorCreateWithoutServiceproviderInput, DoctorUncheckedCreateWithoutServiceproviderInput> | DoctorCreateWithoutServiceproviderInput[] | DoctorUncheckedCreateWithoutServiceproviderInput[]
    connectOrCreate?: DoctorCreateOrConnectWithoutServiceproviderInput | DoctorCreateOrConnectWithoutServiceproviderInput[]
    upsert?: DoctorUpsertWithWhereUniqueWithoutServiceproviderInput | DoctorUpsertWithWhereUniqueWithoutServiceproviderInput[]
    createMany?: DoctorCreateManyServiceproviderInputEnvelope
    set?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    disconnect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    delete?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    connect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    update?: DoctorUpdateWithWhereUniqueWithoutServiceproviderInput | DoctorUpdateWithWhereUniqueWithoutServiceproviderInput[]
    updateMany?: DoctorUpdateManyWithWhereWithoutServiceproviderInput | DoctorUpdateManyWithWhereWithoutServiceproviderInput[]
    deleteMany?: DoctorScalarWhereInput | DoctorScalarWhereInput[]
  }

  export type ClinicInfoUpdateOneWithoutServiceProvidersNestedInput = {
    create?: XOR<ClinicInfoCreateWithoutServiceProvidersInput, ClinicInfoUncheckedCreateWithoutServiceProvidersInput>
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutServiceProvidersInput
    upsert?: ClinicInfoUpsertWithoutServiceProvidersInput
    disconnect?: ClinicInfoWhereInput | boolean
    delete?: ClinicInfoWhereInput | boolean
    connect?: ClinicInfoWhereUniqueInput
    update?: XOR<XOR<ClinicInfoUpdateToOneWithWhereWithoutServiceProvidersInput, ClinicInfoUpdateWithoutServiceProvidersInput>, ClinicInfoUncheckedUpdateWithoutServiceProvidersInput>
  }

  export type AdminPanelUpdateOneWithoutServiceProviderNestedInput = {
    create?: XOR<AdminPanelCreateWithoutServiceProviderInput, AdminPanelUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: AdminPanelCreateOrConnectWithoutServiceProviderInput
    upsert?: AdminPanelUpsertWithoutServiceProviderInput
    disconnect?: AdminPanelWhereInput | boolean
    delete?: AdminPanelWhereInput | boolean
    connect?: AdminPanelWhereUniqueInput
    update?: XOR<XOR<AdminPanelUpdateToOneWithWhereWithoutServiceProviderInput, AdminPanelUpdateWithoutServiceProviderInput>, AdminPanelUncheckedUpdateWithoutServiceProviderInput>
  }

  export type TagUpdateManyWithoutServiceProvidersNestedInput = {
    create?: XOR<TagCreateWithoutServiceProvidersInput, TagUncheckedCreateWithoutServiceProvidersInput> | TagCreateWithoutServiceProvidersInput[] | TagUncheckedCreateWithoutServiceProvidersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutServiceProvidersInput | TagCreateOrConnectWithoutServiceProvidersInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutServiceProvidersInput | TagUpsertWithWhereUniqueWithoutServiceProvidersInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutServiceProvidersInput | TagUpdateWithWhereUniqueWithoutServiceProvidersInput[]
    updateMany?: TagUpdateManyWithWhereWithoutServiceProvidersInput | TagUpdateManyWithWhereWithoutServiceProvidersInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutServiceProviderNestedInput = {
    create?: XOR<UserCreateWithoutServiceProviderInput, UserUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceProviderInput
    upsert?: UserUpsertWithoutServiceProviderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceProviderInput, UserUpdateWithoutServiceProviderInput>, UserUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput = {
    create?: XOR<ScheduleCreateWithoutServiceProvidersInput, ScheduleUncheckedCreateWithoutServiceProvidersInput> | ScheduleCreateWithoutServiceProvidersInput[] | ScheduleUncheckedCreateWithoutServiceProvidersInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutServiceProvidersInput | ScheduleCreateOrConnectWithoutServiceProvidersInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutServiceProvidersInput | ScheduleUpsertWithWhereUniqueWithoutServiceProvidersInput[]
    createMany?: ScheduleCreateManyServiceProvidersInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutServiceProvidersInput | ScheduleUpdateWithWhereUniqueWithoutServiceProvidersInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutServiceProvidersInput | ScheduleUpdateManyWithWhereWithoutServiceProvidersInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput | AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput | AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceProviderInput | AppointmentUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EducationUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<EducationCreateWithoutServiceProviderInput, EducationUncheckedCreateWithoutServiceProviderInput> | EducationCreateWithoutServiceProviderInput[] | EducationUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutServiceProviderInput | EducationCreateOrConnectWithoutServiceProviderInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutServiceProviderInput | EducationUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: EducationCreateManyServiceProviderInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutServiceProviderInput | EducationUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutServiceProviderInput | EducationUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<WorkExperienceCreateWithoutServiceProviderInput, WorkExperienceUncheckedCreateWithoutServiceProviderInput> | WorkExperienceCreateWithoutServiceProviderInput[] | WorkExperienceUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutServiceProviderInput | WorkExperienceCreateOrConnectWithoutServiceProviderInput[]
    upsert?: WorkExperienceUpsertWithWhereUniqueWithoutServiceProviderInput | WorkExperienceUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: WorkExperienceCreateManyServiceProviderInputEnvelope
    set?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    disconnect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    delete?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    connect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    update?: WorkExperienceUpdateWithWhereUniqueWithoutServiceProviderInput | WorkExperienceUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: WorkExperienceUpdateManyWithWhereWithoutServiceProviderInput | WorkExperienceUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: WorkExperienceScalarWhereInput | WorkExperienceScalarWhereInput[]
  }

  export type AwardUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AwardCreateWithoutServiceProviderInput, AwardUncheckedCreateWithoutServiceProviderInput> | AwardCreateWithoutServiceProviderInput[] | AwardUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AwardCreateOrConnectWithoutServiceProviderInput | AwardCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AwardUpsertWithWhereUniqueWithoutServiceProviderInput | AwardUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AwardCreateManyServiceProviderInputEnvelope
    set?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    disconnect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    delete?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    connect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    update?: AwardUpdateWithWhereUniqueWithoutServiceProviderInput | AwardUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AwardUpdateManyWithWhereWithoutServiceProviderInput | AwardUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AwardScalarWhereInput | AwardScalarWhereInput[]
  }

  export type LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<LabResultCreateWithoutServiceProviderInput, LabResultUncheckedCreateWithoutServiceProviderInput> | LabResultCreateWithoutServiceProviderInput[] | LabResultUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutServiceProviderInput | LabResultCreateOrConnectWithoutServiceProviderInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutServiceProviderInput | LabResultUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: LabResultCreateManyServiceProviderInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutServiceProviderInput | LabResultUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutServiceProviderInput | LabResultUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<TherapyPlanCreateWithoutServiceProviderInput, TherapyPlanUncheckedCreateWithoutServiceProviderInput> | TherapyPlanCreateWithoutServiceProviderInput[] | TherapyPlanUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: TherapyPlanCreateOrConnectWithoutServiceProviderInput | TherapyPlanCreateOrConnectWithoutServiceProviderInput[]
    upsert?: TherapyPlanUpsertWithWhereUniqueWithoutServiceProviderInput | TherapyPlanUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: TherapyPlanCreateManyServiceProviderInputEnvelope
    set?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    disconnect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    delete?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    connect?: TherapyPlanWhereUniqueInput | TherapyPlanWhereUniqueInput[]
    update?: TherapyPlanUpdateWithWhereUniqueWithoutServiceProviderInput | TherapyPlanUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: TherapyPlanUpdateManyWithWhereWithoutServiceProviderInput | TherapyPlanUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: TherapyPlanScalarWhereInput | TherapyPlanScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput> | RatingCreateWithoutServiceProviderInput[] | RatingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutServiceProviderInput | RatingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutServiceProviderInput | RatingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: RatingCreateManyServiceProviderInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutServiceProviderInput | RatingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutServiceProviderInput | RatingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutServiceProviderInput, MedicalRecordUncheckedCreateWithoutServiceProviderInput> | MedicalRecordCreateWithoutServiceProviderInput[] | MedicalRecordUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutServiceProviderInput | MedicalRecordCreateOrConnectWithoutServiceProviderInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutServiceProviderInput | MedicalRecordUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: MedicalRecordCreateManyServiceProviderInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutServiceProviderInput | MedicalRecordUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutServiceProviderInput | MedicalRecordUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput = {
    create?: XOR<DoctorCreateWithoutServiceproviderInput, DoctorUncheckedCreateWithoutServiceproviderInput> | DoctorCreateWithoutServiceproviderInput[] | DoctorUncheckedCreateWithoutServiceproviderInput[]
    connectOrCreate?: DoctorCreateOrConnectWithoutServiceproviderInput | DoctorCreateOrConnectWithoutServiceproviderInput[]
    upsert?: DoctorUpsertWithWhereUniqueWithoutServiceproviderInput | DoctorUpsertWithWhereUniqueWithoutServiceproviderInput[]
    createMany?: DoctorCreateManyServiceproviderInputEnvelope
    set?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    disconnect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    delete?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    connect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    update?: DoctorUpdateWithWhereUniqueWithoutServiceproviderInput | DoctorUpdateWithWhereUniqueWithoutServiceproviderInput[]
    updateMany?: DoctorUpdateManyWithWhereWithoutServiceproviderInput | DoctorUpdateManyWithWhereWithoutServiceproviderInput[]
    deleteMany?: DoctorScalarWhereInput | DoctorScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutServiceProvidersNestedInput = {
    create?: XOR<TagCreateWithoutServiceProvidersInput, TagUncheckedCreateWithoutServiceProvidersInput> | TagCreateWithoutServiceProvidersInput[] | TagUncheckedCreateWithoutServiceProvidersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutServiceProvidersInput | TagCreateOrConnectWithoutServiceProvidersInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutServiceProvidersInput | TagUpsertWithWhereUniqueWithoutServiceProvidersInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutServiceProvidersInput | TagUpdateWithWhereUniqueWithoutServiceProvidersInput[]
    updateMany?: TagUpdateManyWithWhereWithoutServiceProvidersInput | TagUpdateManyWithWhereWithoutServiceProvidersInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDoctorInput = {
    create?: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorInput
    connect?: UserWhereUniqueInput
  }

  export type PrescriptionCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type DoctorsAssistantCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorsAssistantCreateWithoutDoctorInput, DoctorsAssistantUncheckedCreateWithoutDoctorInput> | DoctorsAssistantCreateWithoutDoctorInput[] | DoctorsAssistantUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutDoctorInput | DoctorsAssistantCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorsAssistantCreateManyDoctorInputEnvelope
    connect?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
  }

  export type RequestCreateNestedManyWithoutDoctorInput = {
    create?: XOR<RequestCreateWithoutDoctorInput, RequestUncheckedCreateWithoutDoctorInput> | RequestCreateWithoutDoctorInput[] | RequestUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutDoctorInput | RequestCreateOrConnectWithoutDoctorInput[]
    createMany?: RequestCreateManyDoctorInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type ServiceProviderCreateNestedOneWithoutDoctorInput = {
    create?: XOR<ServiceProviderCreateWithoutDoctorInput, ServiceProviderUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutDoctorInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type DoctorsAssistantUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorsAssistantCreateWithoutDoctorInput, DoctorsAssistantUncheckedCreateWithoutDoctorInput> | DoctorsAssistantCreateWithoutDoctorInput[] | DoctorsAssistantUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutDoctorInput | DoctorsAssistantCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorsAssistantCreateManyDoctorInputEnvelope
    connect?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
  }

  export type RequestUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<RequestCreateWithoutDoctorInput, RequestUncheckedCreateWithoutDoctorInput> | RequestCreateWithoutDoctorInput[] | RequestUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutDoctorInput | RequestCreateOrConnectWithoutDoctorInput[]
    createMany?: RequestCreateManyDoctorInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDoctorNestedInput = {
    create?: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorInput
    upsert?: UserUpsertWithoutDoctorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorInput, UserUpdateWithoutDoctorInput>, UserUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type DoctorsAssistantUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorsAssistantCreateWithoutDoctorInput, DoctorsAssistantUncheckedCreateWithoutDoctorInput> | DoctorsAssistantCreateWithoutDoctorInput[] | DoctorsAssistantUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutDoctorInput | DoctorsAssistantCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorsAssistantUpsertWithWhereUniqueWithoutDoctorInput | DoctorsAssistantUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorsAssistantCreateManyDoctorInputEnvelope
    set?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
    disconnect?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
    delete?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
    connect?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
    update?: DoctorsAssistantUpdateWithWhereUniqueWithoutDoctorInput | DoctorsAssistantUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorsAssistantUpdateManyWithWhereWithoutDoctorInput | DoctorsAssistantUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorsAssistantScalarWhereInput | DoctorsAssistantScalarWhereInput[]
  }

  export type RequestUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<RequestCreateWithoutDoctorInput, RequestUncheckedCreateWithoutDoctorInput> | RequestCreateWithoutDoctorInput[] | RequestUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutDoctorInput | RequestCreateOrConnectWithoutDoctorInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutDoctorInput | RequestUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: RequestCreateManyDoctorInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutDoctorInput | RequestUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutDoctorInput | RequestUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type ServiceProviderUpdateOneRequiredWithoutDoctorNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutDoctorInput, ServiceProviderUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutDoctorInput
    upsert?: ServiceProviderUpsertWithoutDoctorInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutDoctorInput, ServiceProviderUpdateWithoutDoctorInput>, ServiceProviderUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type DoctorsAssistantUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorsAssistantCreateWithoutDoctorInput, DoctorsAssistantUncheckedCreateWithoutDoctorInput> | DoctorsAssistantCreateWithoutDoctorInput[] | DoctorsAssistantUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutDoctorInput | DoctorsAssistantCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorsAssistantUpsertWithWhereUniqueWithoutDoctorInput | DoctorsAssistantUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorsAssistantCreateManyDoctorInputEnvelope
    set?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
    disconnect?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
    delete?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
    connect?: DoctorsAssistantWhereUniqueInput | DoctorsAssistantWhereUniqueInput[]
    update?: DoctorsAssistantUpdateWithWhereUniqueWithoutDoctorInput | DoctorsAssistantUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorsAssistantUpdateManyWithWhereWithoutDoctorInput | DoctorsAssistantUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorsAssistantScalarWhereInput | DoctorsAssistantScalarWhereInput[]
  }

  export type RequestUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<RequestCreateWithoutDoctorInput, RequestUncheckedCreateWithoutDoctorInput> | RequestCreateWithoutDoctorInput[] | RequestUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutDoctorInput | RequestCreateOrConnectWithoutDoctorInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutDoctorInput | RequestUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: RequestCreateManyDoctorInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutDoctorInput | RequestUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutDoctorInput | RequestUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDoctorsAssistantInput = {
    create?: XOR<UserCreateWithoutDoctorsAssistantInput, UserUncheckedCreateWithoutDoctorsAssistantInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorsAssistantInput
    connect?: UserWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutAssistantsInput = {
    create?: XOR<DoctorCreateWithoutAssistantsInput, DoctorUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAssistantsInput
    connect?: DoctorWhereUniqueInput
  }

  export type RequestPermissionCreateNestedManyWithoutDoctorsAssistantInput = {
    create?: XOR<RequestPermissionCreateWithoutDoctorsAssistantInput, RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput> | RequestPermissionCreateWithoutDoctorsAssistantInput[] | RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput[]
    connectOrCreate?: RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput | RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput[]
    createMany?: RequestPermissionCreateManyDoctorsAssistantInputEnvelope
    connect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
  }

  export type RequestPermissionUncheckedCreateNestedManyWithoutDoctorsAssistantInput = {
    create?: XOR<RequestPermissionCreateWithoutDoctorsAssistantInput, RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput> | RequestPermissionCreateWithoutDoctorsAssistantInput[] | RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput[]
    connectOrCreate?: RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput | RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput[]
    createMany?: RequestPermissionCreateManyDoctorsAssistantInputEnvelope
    connect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDoctorsAssistantNestedInput = {
    create?: XOR<UserCreateWithoutDoctorsAssistantInput, UserUncheckedCreateWithoutDoctorsAssistantInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorsAssistantInput
    upsert?: UserUpsertWithoutDoctorsAssistantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorsAssistantInput, UserUpdateWithoutDoctorsAssistantInput>, UserUncheckedUpdateWithoutDoctorsAssistantInput>
  }

  export type DoctorUpdateOneRequiredWithoutAssistantsNestedInput = {
    create?: XOR<DoctorCreateWithoutAssistantsInput, DoctorUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAssistantsInput
    upsert?: DoctorUpsertWithoutAssistantsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutAssistantsInput, DoctorUpdateWithoutAssistantsInput>, DoctorUncheckedUpdateWithoutAssistantsInput>
  }

  export type RequestPermissionUpdateManyWithoutDoctorsAssistantNestedInput = {
    create?: XOR<RequestPermissionCreateWithoutDoctorsAssistantInput, RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput> | RequestPermissionCreateWithoutDoctorsAssistantInput[] | RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput[]
    connectOrCreate?: RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput | RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput[]
    upsert?: RequestPermissionUpsertWithWhereUniqueWithoutDoctorsAssistantInput | RequestPermissionUpsertWithWhereUniqueWithoutDoctorsAssistantInput[]
    createMany?: RequestPermissionCreateManyDoctorsAssistantInputEnvelope
    set?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    disconnect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    delete?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    connect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    update?: RequestPermissionUpdateWithWhereUniqueWithoutDoctorsAssistantInput | RequestPermissionUpdateWithWhereUniqueWithoutDoctorsAssistantInput[]
    updateMany?: RequestPermissionUpdateManyWithWhereWithoutDoctorsAssistantInput | RequestPermissionUpdateManyWithWhereWithoutDoctorsAssistantInput[]
    deleteMany?: RequestPermissionScalarWhereInput | RequestPermissionScalarWhereInput[]
  }

  export type RequestPermissionUncheckedUpdateManyWithoutDoctorsAssistantNestedInput = {
    create?: XOR<RequestPermissionCreateWithoutDoctorsAssistantInput, RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput> | RequestPermissionCreateWithoutDoctorsAssistantInput[] | RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput[]
    connectOrCreate?: RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput | RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput[]
    upsert?: RequestPermissionUpsertWithWhereUniqueWithoutDoctorsAssistantInput | RequestPermissionUpsertWithWhereUniqueWithoutDoctorsAssistantInput[]
    createMany?: RequestPermissionCreateManyDoctorsAssistantInputEnvelope
    set?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    disconnect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    delete?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    connect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    update?: RequestPermissionUpdateWithWhereUniqueWithoutDoctorsAssistantInput | RequestPermissionUpdateWithWhereUniqueWithoutDoctorsAssistantInput[]
    updateMany?: RequestPermissionUpdateManyWithWhereWithoutDoctorsAssistantInput | RequestPermissionUpdateManyWithWhereWithoutDoctorsAssistantInput[]
    deleteMany?: RequestPermissionScalarWhereInput | RequestPermissionScalarWhereInput[]
  }

  export type LabCreateservicesOfferedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutLabInput = {
    create?: XOR<UserCreateWithoutLabInput, UserUncheckedCreateWithoutLabInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabInput
    connect?: UserWhereUniqueInput
  }

  export type LabUpdateservicesOfferedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutLabNestedInput = {
    create?: XOR<UserCreateWithoutLabInput, UserUncheckedCreateWithoutLabInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabInput
    upsert?: UserUpsertWithoutLabInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLabInput, UserUpdateWithoutLabInput>, UserUncheckedUpdateWithoutLabInput>
  }

  export type HospitalCreateservicesOfferedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutHospitalInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput
    connect?: UserWhereUniqueInput
  }

  export type HospitalUpdateservicesOfferedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutHospitalNestedInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput
    upsert?: UserUpsertWithoutHospitalInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHospitalInput, UserUpdateWithoutHospitalInput>, UserUncheckedUpdateWithoutHospitalInput>
  }

  export type NursingCreateservicesOfferedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutNursingInput = {
    create?: XOR<UserCreateWithoutNursingInput, UserUncheckedCreateWithoutNursingInput>
    connectOrCreate?: UserCreateOrConnectWithoutNursingInput
    connect?: UserWhereUniqueInput
  }

  export type NursingUpdateservicesOfferedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutNursingNestedInput = {
    create?: XOR<UserCreateWithoutNursingInput, UserUncheckedCreateWithoutNursingInput>
    connectOrCreate?: UserCreateOrConnectWithoutNursingInput
    upsert?: UserUpsertWithoutNursingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNursingInput, UserUpdateWithoutNursingInput>, UserUncheckedUpdateWithoutNursingInput>
  }

  export type PatientCreateNestedOneWithoutAllergiesInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutAllergiesNestedInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    upsert?: PatientUpsertWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAllergiesInput, PatientUpdateWithoutAllergiesInput>, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PrescriptionCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<PrescriptionCreateWithoutMedicationsInput, PrescriptionUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutMedicationsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type PrescriptionUpdateOneWithoutMedicationsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutMedicationsInput, PrescriptionUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutMedicationsInput
    upsert?: PrescriptionUpsertWithoutMedicationsInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutMedicationsInput, PrescriptionUpdateWithoutMedicationsInput>, PrescriptionUncheckedUpdateWithoutMedicationsInput>
  }

  export type PatientCreateNestedOneWithoutLabResultsInput = {
    create?: XOR<PatientCreateWithoutLabResultsInput, PatientUncheckedCreateWithoutLabResultsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabResultsInput
    connect?: PatientWhereUniqueInput
  }

  export type ServiceProviderCreateNestedOneWithoutLabResultsInput = {
    create?: XOR<ServiceProviderCreateWithoutLabResultsInput, ServiceProviderUncheckedCreateWithoutLabResultsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutLabResultsInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutLabResultsNestedInput = {
    create?: XOR<PatientCreateWithoutLabResultsInput, PatientUncheckedCreateWithoutLabResultsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabResultsInput
    upsert?: PatientUpsertWithoutLabResultsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutLabResultsInput, PatientUpdateWithoutLabResultsInput>, PatientUncheckedUpdateWithoutLabResultsInput>
  }

  export type ServiceProviderUpdateOneRequiredWithoutLabResultsNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutLabResultsInput, ServiceProviderUncheckedCreateWithoutLabResultsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutLabResultsInput
    upsert?: ServiceProviderUpsertWithoutLabResultsInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutLabResultsInput, ServiceProviderUpdateWithoutLabResultsInput>, ServiceProviderUncheckedUpdateWithoutLabResultsInput>
  }

  export type UserCreateNestedOneWithoutMedicalRecordsInput = {
    create?: XOR<UserCreateWithoutMedicalRecordsInput, UserUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicalRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceProviderCreateNestedOneWithoutMedicalRecordsInput = {
    create?: XOR<ServiceProviderCreateWithoutMedicalRecordsInput, ServiceProviderUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutMedicalRecordsInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMedicalRecordsNestedInput = {
    create?: XOR<UserCreateWithoutMedicalRecordsInput, UserUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicalRecordsInput
    upsert?: UserUpsertWithoutMedicalRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMedicalRecordsInput, UserUpdateWithoutMedicalRecordsInput>, UserUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type ServiceProviderUpdateOneWithoutMedicalRecordsNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutMedicalRecordsInput, ServiceProviderUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutMedicalRecordsInput
    upsert?: ServiceProviderUpsertWithoutMedicalRecordsInput
    disconnect?: ServiceProviderWhereInput | boolean
    delete?: ServiceProviderWhereInput | boolean
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutMedicalRecordsInput, ServiceProviderUpdateWithoutMedicalRecordsInput>, ServiceProviderUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type MedicationCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<MedicationCreateWithoutPrescriptionInput, MedicationUncheckedCreateWithoutPrescriptionInput> | MedicationCreateWithoutPrescriptionInput[] | MedicationUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescriptionInput | MedicationCreateOrConnectWithoutPrescriptionInput[]
    createMany?: MedicationCreateManyPrescriptionInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type PatientCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutPrescriptionsInput
    connect?: DoctorWhereUniqueInput
  }

  export type MedicationUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<MedicationCreateWithoutPrescriptionInput, MedicationUncheckedCreateWithoutPrescriptionInput> | MedicationCreateWithoutPrescriptionInput[] | MedicationUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescriptionInput | MedicationCreateOrConnectWithoutPrescriptionInput[]
    createMany?: MedicationCreateManyPrescriptionInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type MedicationUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<MedicationCreateWithoutPrescriptionInput, MedicationUncheckedCreateWithoutPrescriptionInput> | MedicationCreateWithoutPrescriptionInput[] | MedicationUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescriptionInput | MedicationCreateOrConnectWithoutPrescriptionInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutPrescriptionInput | MedicationUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: MedicationCreateManyPrescriptionInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutPrescriptionInput | MedicationUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutPrescriptionInput | MedicationUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type PatientUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    upsert?: PatientUpsertWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionsInput, PatientUpdateWithoutPrescriptionsInput>, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutPrescriptionsInput
    upsert?: DoctorUpsertWithoutPrescriptionsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutPrescriptionsInput, DoctorUpdateWithoutPrescriptionsInput>, DoctorUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type MedicationUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<MedicationCreateWithoutPrescriptionInput, MedicationUncheckedCreateWithoutPrescriptionInput> | MedicationCreateWithoutPrescriptionInput[] | MedicationUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescriptionInput | MedicationCreateOrConnectWithoutPrescriptionInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutPrescriptionInput | MedicationUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: MedicationCreateManyPrescriptionInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutPrescriptionInput | MedicationUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutPrescriptionInput | MedicationUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutTreatmentPlansInput = {
    create?: XOR<PatientCreateWithoutTreatmentPlansInput, PatientUncheckedCreateWithoutTreatmentPlansInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTreatmentPlansInput
    connect?: PatientWhereUniqueInput
  }

  export type ServiceProviderCreateNestedOneWithoutTherapyPlansInput = {
    create?: XOR<ServiceProviderCreateWithoutTherapyPlansInput, ServiceProviderUncheckedCreateWithoutTherapyPlansInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutTherapyPlansInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput = {
    create?: XOR<PatientCreateWithoutTreatmentPlansInput, PatientUncheckedCreateWithoutTreatmentPlansInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTreatmentPlansInput
    upsert?: PatientUpsertWithoutTreatmentPlansInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutTreatmentPlansInput, PatientUpdateWithoutTreatmentPlansInput>, PatientUncheckedUpdateWithoutTreatmentPlansInput>
  }

  export type ServiceProviderUpdateOneRequiredWithoutTherapyPlansNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutTherapyPlansInput, ServiceProviderUncheckedCreateWithoutTherapyPlansInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutTherapyPlansInput
    upsert?: ServiceProviderUpsertWithoutTherapyPlansInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutTherapyPlansInput, ServiceProviderUpdateWithoutTherapyPlansInput>, ServiceProviderUncheckedUpdateWithoutTherapyPlansInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutPaymentInput = {
    create?: XOR<AppointmentCreateWithoutPaymentInput, AppointmentUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutPaymentInput
    connect?: AppointmentWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutPaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput> | TransactionCreateWithoutPaymentInput[] | TransactionUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput | TransactionCreateOrConnectWithoutPaymentInput[]
    createMany?: TransactionCreateManyPaymentInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput> | TransactionCreateWithoutPaymentInput[] | TransactionUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput | TransactionCreateOrConnectWithoutPaymentInput[]
    createMany?: TransactionCreateManyPaymentInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type AppointmentUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<AppointmentCreateWithoutPaymentInput, AppointmentUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutPaymentInput
    upsert?: AppointmentUpsertWithoutPaymentInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutPaymentInput, AppointmentUpdateWithoutPaymentInput>, AppointmentUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput> | TransactionCreateWithoutPaymentInput[] | TransactionUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput | TransactionCreateOrConnectWithoutPaymentInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPaymentInput | TransactionUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: TransactionCreateManyPaymentInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPaymentInput | TransactionUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPaymentInput | TransactionUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput> | TransactionCreateWithoutPaymentInput[] | TransactionUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput | TransactionCreateOrConnectWithoutPaymentInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPaymentInput | TransactionUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: TransactionCreateManyPaymentInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPaymentInput | TransactionUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPaymentInput | TransactionUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type ServiceProviderCreateNestedOneWithoutRatingInput = {
    create?: XOR<ServiceProviderCreateWithoutRatingInput, ServiceProviderUncheckedCreateWithoutRatingInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutRatingInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRatingsInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceProviderUpdateOneRequiredWithoutRatingNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutRatingInput, ServiceProviderUncheckedCreateWithoutRatingInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutRatingInput
    upsert?: ServiceProviderUpsertWithoutRatingInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutRatingInput, ServiceProviderUpdateWithoutRatingInput>, ServiceProviderUncheckedUpdateWithoutRatingInput>
  }

  export type UserUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    upsert?: UserUpsertWithoutRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRatingsInput, UserUpdateWithoutRatingsInput>, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type RequestCreateNestedManyWithoutRequestPermissionsInput = {
    create?: XOR<RequestCreateWithoutRequestPermissionsInput, RequestUncheckedCreateWithoutRequestPermissionsInput> | RequestCreateWithoutRequestPermissionsInput[] | RequestUncheckedCreateWithoutRequestPermissionsInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequestPermissionsInput | RequestCreateOrConnectWithoutRequestPermissionsInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type DoctorsAssistantCreateNestedOneWithoutRequestPermissionsInput = {
    create?: XOR<DoctorsAssistantCreateWithoutRequestPermissionsInput, DoctorsAssistantUncheckedCreateWithoutRequestPermissionsInput>
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutRequestPermissionsInput
    connect?: DoctorsAssistantWhereUniqueInput
  }

  export type RequestUncheckedCreateNestedManyWithoutRequestPermissionsInput = {
    create?: XOR<RequestCreateWithoutRequestPermissionsInput, RequestUncheckedCreateWithoutRequestPermissionsInput> | RequestCreateWithoutRequestPermissionsInput[] | RequestUncheckedCreateWithoutRequestPermissionsInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequestPermissionsInput | RequestCreateOrConnectWithoutRequestPermissionsInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type EnumPermissionTypeFieldUpdateOperationsInput = {
    set?: $Enums.PermissionType
  }

  export type RequestUpdateManyWithoutRequestPermissionsNestedInput = {
    create?: XOR<RequestCreateWithoutRequestPermissionsInput, RequestUncheckedCreateWithoutRequestPermissionsInput> | RequestCreateWithoutRequestPermissionsInput[] | RequestUncheckedCreateWithoutRequestPermissionsInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequestPermissionsInput | RequestCreateOrConnectWithoutRequestPermissionsInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutRequestPermissionsInput | RequestUpsertWithWhereUniqueWithoutRequestPermissionsInput[]
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutRequestPermissionsInput | RequestUpdateWithWhereUniqueWithoutRequestPermissionsInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutRequestPermissionsInput | RequestUpdateManyWithWhereWithoutRequestPermissionsInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type DoctorsAssistantUpdateOneWithoutRequestPermissionsNestedInput = {
    create?: XOR<DoctorsAssistantCreateWithoutRequestPermissionsInput, DoctorsAssistantUncheckedCreateWithoutRequestPermissionsInput>
    connectOrCreate?: DoctorsAssistantCreateOrConnectWithoutRequestPermissionsInput
    upsert?: DoctorsAssistantUpsertWithoutRequestPermissionsInput
    disconnect?: DoctorsAssistantWhereInput | boolean
    delete?: DoctorsAssistantWhereInput | boolean
    connect?: DoctorsAssistantWhereUniqueInput
    update?: XOR<XOR<DoctorsAssistantUpdateToOneWithWhereWithoutRequestPermissionsInput, DoctorsAssistantUpdateWithoutRequestPermissionsInput>, DoctorsAssistantUncheckedUpdateWithoutRequestPermissionsInput>
  }

  export type RequestUncheckedUpdateManyWithoutRequestPermissionsNestedInput = {
    create?: XOR<RequestCreateWithoutRequestPermissionsInput, RequestUncheckedCreateWithoutRequestPermissionsInput> | RequestCreateWithoutRequestPermissionsInput[] | RequestUncheckedCreateWithoutRequestPermissionsInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequestPermissionsInput | RequestCreateOrConnectWithoutRequestPermissionsInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutRequestPermissionsInput | RequestUpsertWithWhereUniqueWithoutRequestPermissionsInput[]
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutRequestPermissionsInput | RequestUpdateWithWhereUniqueWithoutRequestPermissionsInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutRequestPermissionsInput | RequestUpdateManyWithWhereWithoutRequestPermissionsInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type RequestPermissionCreateNestedManyWithoutRequestsInput = {
    create?: XOR<RequestPermissionCreateWithoutRequestsInput, RequestPermissionUncheckedCreateWithoutRequestsInput> | RequestPermissionCreateWithoutRequestsInput[] | RequestPermissionUncheckedCreateWithoutRequestsInput[]
    connectOrCreate?: RequestPermissionCreateOrConnectWithoutRequestsInput | RequestPermissionCreateOrConnectWithoutRequestsInput[]
    connect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
  }

  export type DoctorCreateNestedOneWithoutRequestsInput = {
    create?: XOR<DoctorCreateWithoutRequestsInput, DoctorUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutRequestsInput
    connect?: DoctorWhereUniqueInput
  }

  export type RequestPermissionUncheckedCreateNestedManyWithoutRequestsInput = {
    create?: XOR<RequestPermissionCreateWithoutRequestsInput, RequestPermissionUncheckedCreateWithoutRequestsInput> | RequestPermissionCreateWithoutRequestsInput[] | RequestPermissionUncheckedCreateWithoutRequestsInput[]
    connectOrCreate?: RequestPermissionCreateOrConnectWithoutRequestsInput | RequestPermissionCreateOrConnectWithoutRequestsInput[]
    connect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
  }

  export type RequestPermissionUpdateManyWithoutRequestsNestedInput = {
    create?: XOR<RequestPermissionCreateWithoutRequestsInput, RequestPermissionUncheckedCreateWithoutRequestsInput> | RequestPermissionCreateWithoutRequestsInput[] | RequestPermissionUncheckedCreateWithoutRequestsInput[]
    connectOrCreate?: RequestPermissionCreateOrConnectWithoutRequestsInput | RequestPermissionCreateOrConnectWithoutRequestsInput[]
    upsert?: RequestPermissionUpsertWithWhereUniqueWithoutRequestsInput | RequestPermissionUpsertWithWhereUniqueWithoutRequestsInput[]
    set?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    disconnect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    delete?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    connect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    update?: RequestPermissionUpdateWithWhereUniqueWithoutRequestsInput | RequestPermissionUpdateWithWhereUniqueWithoutRequestsInput[]
    updateMany?: RequestPermissionUpdateManyWithWhereWithoutRequestsInput | RequestPermissionUpdateManyWithWhereWithoutRequestsInput[]
    deleteMany?: RequestPermissionScalarWhereInput | RequestPermissionScalarWhereInput[]
  }

  export type DoctorUpdateOneWithoutRequestsNestedInput = {
    create?: XOR<DoctorCreateWithoutRequestsInput, DoctorUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutRequestsInput
    upsert?: DoctorUpsertWithoutRequestsInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutRequestsInput, DoctorUpdateWithoutRequestsInput>, DoctorUncheckedUpdateWithoutRequestsInput>
  }

  export type RequestPermissionUncheckedUpdateManyWithoutRequestsNestedInput = {
    create?: XOR<RequestPermissionCreateWithoutRequestsInput, RequestPermissionUncheckedCreateWithoutRequestsInput> | RequestPermissionCreateWithoutRequestsInput[] | RequestPermissionUncheckedCreateWithoutRequestsInput[]
    connectOrCreate?: RequestPermissionCreateOrConnectWithoutRequestsInput | RequestPermissionCreateOrConnectWithoutRequestsInput[]
    upsert?: RequestPermissionUpsertWithWhereUniqueWithoutRequestsInput | RequestPermissionUpsertWithWhereUniqueWithoutRequestsInput[]
    set?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    disconnect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    delete?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    connect?: RequestPermissionWhereUniqueInput | RequestPermissionWhereUniqueInput[]
    update?: RequestPermissionUpdateWithWhereUniqueWithoutRequestsInput | RequestPermissionUpdateWithWhereUniqueWithoutRequestsInput[]
    updateMany?: RequestPermissionUpdateManyWithWhereWithoutRequestsInput | RequestPermissionUpdateManyWithWhereWithoutRequestsInput[]
    deleteMany?: RequestPermissionScalarWhereInput | RequestPermissionScalarWhereInput[]
  }

  export type AppointmentCreateserviceInput = {
    set: $Enums.Service[]
  }

  export type OthersAppointmentCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<OthersAppointmentCreateWithoutAppointmentInput, OthersAppointmentUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: OthersAppointmentCreateOrConnectWithoutAppointmentInput
    connect?: OthersAppointmentWhereUniqueInput
  }

  export type CurrentLocationCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<CurrentLocationCreateWithoutAppointmentInput, CurrentLocationUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CurrentLocationCreateOrConnectWithoutAppointmentInput
    connect?: CurrentLocationWhereUniqueInput
  }

  export type SlotCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: SlotCreateOrConnectWithoutAppointmentInput
    connect?: SlotWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceProviderCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<ServiceProviderCreateWithoutAppointmentInput, ServiceProviderUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutAppointmentInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<PatientCreateWithoutAppointmentInput, PatientUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentInput
    connect?: PatientWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput> | PaymentCreateWithoutAppointmentInput[] | PaymentUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput | PaymentCreateOrConnectWithoutAppointmentInput[]
    createMany?: PaymentCreateManyAppointmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<TagCreateWithoutAppointmentsInput, TagUncheckedCreateWithoutAppointmentsInput> | TagCreateWithoutAppointmentsInput[] | TagUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutAppointmentsInput | TagCreateOrConnectWithoutAppointmentsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<OthersAppointmentCreateWithoutAppointmentInput, OthersAppointmentUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: OthersAppointmentCreateOrConnectWithoutAppointmentInput
    connect?: OthersAppointmentWhereUniqueInput
  }

  export type CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<CurrentLocationCreateWithoutAppointmentInput, CurrentLocationUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CurrentLocationCreateOrConnectWithoutAppointmentInput
    connect?: CurrentLocationWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput> | PaymentCreateWithoutAppointmentInput[] | PaymentUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput | PaymentCreateOrConnectWithoutAppointmentInput[]
    createMany?: PaymentCreateManyAppointmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<TagCreateWithoutAppointmentsInput, TagUncheckedCreateWithoutAppointmentsInput> | TagCreateWithoutAppointmentsInput[] | TagUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutAppointmentsInput | TagCreateOrConnectWithoutAppointmentsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type AppointmentUpdateserviceInput = {
    set?: $Enums.Service[]
    push?: $Enums.Service | $Enums.Service[]
  }

  export type OthersAppointmentUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<OthersAppointmentCreateWithoutAppointmentInput, OthersAppointmentUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: OthersAppointmentCreateOrConnectWithoutAppointmentInput
    upsert?: OthersAppointmentUpsertWithoutAppointmentInput
    disconnect?: OthersAppointmentWhereInput | boolean
    delete?: OthersAppointmentWhereInput | boolean
    connect?: OthersAppointmentWhereUniqueInput
    update?: XOR<XOR<OthersAppointmentUpdateToOneWithWhereWithoutAppointmentInput, OthersAppointmentUpdateWithoutAppointmentInput>, OthersAppointmentUncheckedUpdateWithoutAppointmentInput>
  }

  export type CurrentLocationUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<CurrentLocationCreateWithoutAppointmentInput, CurrentLocationUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CurrentLocationCreateOrConnectWithoutAppointmentInput
    upsert?: CurrentLocationUpsertWithoutAppointmentInput
    disconnect?: CurrentLocationWhereInput | boolean
    delete?: CurrentLocationWhereInput | boolean
    connect?: CurrentLocationWhereUniqueInput
    update?: XOR<XOR<CurrentLocationUpdateToOneWithWhereWithoutAppointmentInput, CurrentLocationUpdateWithoutAppointmentInput>, CurrentLocationUncheckedUpdateWithoutAppointmentInput>
  }

  export type SlotUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: SlotCreateOrConnectWithoutAppointmentInput
    upsert?: SlotUpsertWithoutAppointmentInput
    connect?: SlotWhereUniqueInput
    update?: XOR<XOR<SlotUpdateToOneWithWhereWithoutAppointmentInput, SlotUpdateWithoutAppointmentInput>, SlotUncheckedUpdateWithoutAppointmentInput>
  }

  export type UserUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    upsert?: UserUpsertWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsInput, UserUpdateWithoutAppointmentsInput>, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutAppointmentInput, ServiceProviderUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutAppointmentInput
    upsert?: ServiceProviderUpsertWithoutAppointmentInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutAppointmentInput, ServiceProviderUpdateWithoutAppointmentInput>, ServiceProviderUncheckedUpdateWithoutAppointmentInput>
  }

  export type PatientUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentInput, PatientUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentInput
    upsert?: PatientUpsertWithoutAppointmentInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentInput, PatientUpdateWithoutAppointmentInput>, PatientUncheckedUpdateWithoutAppointmentInput>
  }

  export type PaymentUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput> | PaymentCreateWithoutAppointmentInput[] | PaymentUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput | PaymentCreateOrConnectWithoutAppointmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutAppointmentInput | PaymentUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: PaymentCreateManyAppointmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutAppointmentInput | PaymentUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutAppointmentInput | PaymentUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TagUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<TagCreateWithoutAppointmentsInput, TagUncheckedCreateWithoutAppointmentsInput> | TagCreateWithoutAppointmentsInput[] | TagUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutAppointmentsInput | TagCreateOrConnectWithoutAppointmentsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutAppointmentsInput | TagUpsertWithWhereUniqueWithoutAppointmentsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutAppointmentsInput | TagUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutAppointmentsInput | TagUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<OthersAppointmentCreateWithoutAppointmentInput, OthersAppointmentUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: OthersAppointmentCreateOrConnectWithoutAppointmentInput
    upsert?: OthersAppointmentUpsertWithoutAppointmentInput
    disconnect?: OthersAppointmentWhereInput | boolean
    delete?: OthersAppointmentWhereInput | boolean
    connect?: OthersAppointmentWhereUniqueInput
    update?: XOR<XOR<OthersAppointmentUpdateToOneWithWhereWithoutAppointmentInput, OthersAppointmentUpdateWithoutAppointmentInput>, OthersAppointmentUncheckedUpdateWithoutAppointmentInput>
  }

  export type CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<CurrentLocationCreateWithoutAppointmentInput, CurrentLocationUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CurrentLocationCreateOrConnectWithoutAppointmentInput
    upsert?: CurrentLocationUpsertWithoutAppointmentInput
    disconnect?: CurrentLocationWhereInput | boolean
    delete?: CurrentLocationWhereInput | boolean
    connect?: CurrentLocationWhereUniqueInput
    update?: XOR<XOR<CurrentLocationUpdateToOneWithWhereWithoutAppointmentInput, CurrentLocationUpdateWithoutAppointmentInput>, CurrentLocationUncheckedUpdateWithoutAppointmentInput>
  }

  export type PaymentUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput> | PaymentCreateWithoutAppointmentInput[] | PaymentUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput | PaymentCreateOrConnectWithoutAppointmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutAppointmentInput | PaymentUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: PaymentCreateManyAppointmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutAppointmentInput | PaymentUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutAppointmentInput | PaymentUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<TagCreateWithoutAppointmentsInput, TagUncheckedCreateWithoutAppointmentsInput> | TagCreateWithoutAppointmentsInput[] | TagUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutAppointmentsInput | TagCreateOrConnectWithoutAppointmentsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutAppointmentsInput | TagUpsertWithWhereUniqueWithoutAppointmentsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutAppointmentsInput | TagUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutAppointmentsInput | TagUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type AppointmentCreateNestedOneWithoutOthersAppointmentInput = {
    create?: XOR<AppointmentCreateWithoutOthersAppointmentInput, AppointmentUncheckedCreateWithoutOthersAppointmentInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutOthersAppointmentInput
    connect?: AppointmentWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type AppointmentUpdateOneRequiredWithoutOthersAppointmentNestedInput = {
    create?: XOR<AppointmentCreateWithoutOthersAppointmentInput, AppointmentUncheckedCreateWithoutOthersAppointmentInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutOthersAppointmentInput
    upsert?: AppointmentUpsertWithoutOthersAppointmentInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutOthersAppointmentInput, AppointmentUpdateWithoutOthersAppointmentInput>, AppointmentUncheckedUpdateWithoutOthersAppointmentInput>
  }

  export type ServiceProviderCreateNestedOneWithoutScheduleInput = {
    create?: XOR<ServiceProviderCreateWithoutScheduleInput, ServiceProviderUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutScheduleInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type SlotCreateNestedManyWithoutScheduleInput = {
    create?: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput> | SlotCreateWithoutScheduleInput[] | SlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutScheduleInput | SlotCreateOrConnectWithoutScheduleInput[]
    createMany?: SlotCreateManyScheduleInputEnvelope
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
  }

  export type ClinicInfoCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ClinicInfoCreateWithoutScheduleInput, ClinicInfoUncheckedCreateWithoutScheduleInput> | ClinicInfoCreateWithoutScheduleInput[] | ClinicInfoUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutScheduleInput | ClinicInfoCreateOrConnectWithoutScheduleInput[]
    createMany?: ClinicInfoCreateManyScheduleInputEnvelope
    connect?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
  }

  export type SlotUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput> | SlotCreateWithoutScheduleInput[] | SlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutScheduleInput | SlotCreateOrConnectWithoutScheduleInput[]
    createMany?: SlotCreateManyScheduleInputEnvelope
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
  }

  export type ClinicInfoUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ClinicInfoCreateWithoutScheduleInput, ClinicInfoUncheckedCreateWithoutScheduleInput> | ClinicInfoCreateWithoutScheduleInput[] | ClinicInfoUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutScheduleInput | ClinicInfoCreateOrConnectWithoutScheduleInput[]
    createMany?: ClinicInfoCreateManyScheduleInputEnvelope
    connect?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
  }

  export type NullableEnumWeekDayFieldUpdateOperationsInput = {
    set?: $Enums.WeekDay | null
  }

  export type NullableEnumRecurrenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.RecurrenceType | null
  }

  export type EnumServiceFieldUpdateOperationsInput = {
    set?: $Enums.Service
  }

  export type ServiceProviderUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutScheduleInput, ServiceProviderUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutScheduleInput
    upsert?: ServiceProviderUpsertWithoutScheduleInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutScheduleInput, ServiceProviderUpdateWithoutScheduleInput>, ServiceProviderUncheckedUpdateWithoutScheduleInput>
  }

  export type SlotUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput> | SlotCreateWithoutScheduleInput[] | SlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutScheduleInput | SlotCreateOrConnectWithoutScheduleInput[]
    upsert?: SlotUpsertWithWhereUniqueWithoutScheduleInput | SlotUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: SlotCreateManyScheduleInputEnvelope
    set?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    disconnect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    delete?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    update?: SlotUpdateWithWhereUniqueWithoutScheduleInput | SlotUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: SlotUpdateManyWithWhereWithoutScheduleInput | SlotUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: SlotScalarWhereInput | SlotScalarWhereInput[]
  }

  export type ClinicInfoUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ClinicInfoCreateWithoutScheduleInput, ClinicInfoUncheckedCreateWithoutScheduleInput> | ClinicInfoCreateWithoutScheduleInput[] | ClinicInfoUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutScheduleInput | ClinicInfoCreateOrConnectWithoutScheduleInput[]
    upsert?: ClinicInfoUpsertWithWhereUniqueWithoutScheduleInput | ClinicInfoUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ClinicInfoCreateManyScheduleInputEnvelope
    set?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
    disconnect?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
    delete?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
    connect?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
    update?: ClinicInfoUpdateWithWhereUniqueWithoutScheduleInput | ClinicInfoUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ClinicInfoUpdateManyWithWhereWithoutScheduleInput | ClinicInfoUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ClinicInfoScalarWhereInput | ClinicInfoScalarWhereInput[]
  }

  export type SlotUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput> | SlotCreateWithoutScheduleInput[] | SlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutScheduleInput | SlotCreateOrConnectWithoutScheduleInput[]
    upsert?: SlotUpsertWithWhereUniqueWithoutScheduleInput | SlotUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: SlotCreateManyScheduleInputEnvelope
    set?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    disconnect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    delete?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    update?: SlotUpdateWithWhereUniqueWithoutScheduleInput | SlotUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: SlotUpdateManyWithWhereWithoutScheduleInput | SlotUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: SlotScalarWhereInput | SlotScalarWhereInput[]
  }

  export type ClinicInfoUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ClinicInfoCreateWithoutScheduleInput, ClinicInfoUncheckedCreateWithoutScheduleInput> | ClinicInfoCreateWithoutScheduleInput[] | ClinicInfoUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutScheduleInput | ClinicInfoCreateOrConnectWithoutScheduleInput[]
    upsert?: ClinicInfoUpsertWithWhereUniqueWithoutScheduleInput | ClinicInfoUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ClinicInfoCreateManyScheduleInputEnvelope
    set?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
    disconnect?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
    delete?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
    connect?: ClinicInfoWhereUniqueInput | ClinicInfoWhereUniqueInput[]
    update?: ClinicInfoUpdateWithWhereUniqueWithoutScheduleInput | ClinicInfoUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ClinicInfoUpdateManyWithWhereWithoutScheduleInput | ClinicInfoUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ClinicInfoScalarWhereInput | ClinicInfoScalarWhereInput[]
  }

  export type ScheduleCreateNestedOneWithoutSlotsInput = {
    create?: XOR<ScheduleCreateWithoutSlotsInput, ScheduleUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutSlotsInput
    connect?: ScheduleWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutSlotInput = {
    create?: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutSlotInput
    connect?: AppointmentWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedOneWithoutSlotInput = {
    create?: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutSlotInput
    connect?: AppointmentWhereUniqueInput
  }

  export type ScheduleUpdateOneRequiredWithoutSlotsNestedInput = {
    create?: XOR<ScheduleCreateWithoutSlotsInput, ScheduleUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutSlotsInput
    upsert?: ScheduleUpsertWithoutSlotsInput
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutSlotsInput, ScheduleUpdateWithoutSlotsInput>, ScheduleUncheckedUpdateWithoutSlotsInput>
  }

  export type AppointmentUpdateOneWithoutSlotNestedInput = {
    create?: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutSlotInput
    upsert?: AppointmentUpsertWithoutSlotInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutSlotInput, AppointmentUpdateWithoutSlotInput>, AppointmentUncheckedUpdateWithoutSlotInput>
  }

  export type AppointmentUncheckedUpdateOneWithoutSlotNestedInput = {
    create?: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutSlotInput
    upsert?: AppointmentUpsertWithoutSlotInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutSlotInput, AppointmentUpdateWithoutSlotInput>, AppointmentUncheckedUpdateWithoutSlotInput>
  }

  export type ClinicInfoCreateimagesInput = {
    set: string[]
  }

  export type AddressCreateNestedOneWithoutClinicInfoInput = {
    create?: XOR<AddressCreateWithoutClinicInfoInput, AddressUncheckedCreateWithoutClinicInfoInput>
    connectOrCreate?: AddressCreateOrConnectWithoutClinicInfoInput
    connect?: AddressWhereUniqueInput
  }

  export type ServiceProviderCreateNestedManyWithoutClinicInfoInput = {
    create?: XOR<ServiceProviderCreateWithoutClinicInfoInput, ServiceProviderUncheckedCreateWithoutClinicInfoInput> | ServiceProviderCreateWithoutClinicInfoInput[] | ServiceProviderUncheckedCreateWithoutClinicInfoInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutClinicInfoInput | ServiceProviderCreateOrConnectWithoutClinicInfoInput[]
    createMany?: ServiceProviderCreateManyClinicInfoInputEnvelope
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type ScheduleCreateNestedOneWithoutClinicInfoInput = {
    create?: XOR<ScheduleCreateWithoutClinicInfoInput, ScheduleUncheckedCreateWithoutClinicInfoInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutClinicInfoInput
    connect?: ScheduleWhereUniqueInput
  }

  export type ServiceProviderUncheckedCreateNestedManyWithoutClinicInfoInput = {
    create?: XOR<ServiceProviderCreateWithoutClinicInfoInput, ServiceProviderUncheckedCreateWithoutClinicInfoInput> | ServiceProviderCreateWithoutClinicInfoInput[] | ServiceProviderUncheckedCreateWithoutClinicInfoInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutClinicInfoInput | ServiceProviderCreateOrConnectWithoutClinicInfoInput[]
    createMany?: ServiceProviderCreateManyClinicInfoInputEnvelope
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type ClinicInfoUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AddressUpdateOneRequiredWithoutClinicInfoNestedInput = {
    create?: XOR<AddressCreateWithoutClinicInfoInput, AddressUncheckedCreateWithoutClinicInfoInput>
    connectOrCreate?: AddressCreateOrConnectWithoutClinicInfoInput
    upsert?: AddressUpsertWithoutClinicInfoInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutClinicInfoInput, AddressUpdateWithoutClinicInfoInput>, AddressUncheckedUpdateWithoutClinicInfoInput>
  }

  export type ServiceProviderUpdateManyWithoutClinicInfoNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutClinicInfoInput, ServiceProviderUncheckedCreateWithoutClinicInfoInput> | ServiceProviderCreateWithoutClinicInfoInput[] | ServiceProviderUncheckedCreateWithoutClinicInfoInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutClinicInfoInput | ServiceProviderCreateOrConnectWithoutClinicInfoInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutClinicInfoInput | ServiceProviderUpsertWithWhereUniqueWithoutClinicInfoInput[]
    createMany?: ServiceProviderCreateManyClinicInfoInputEnvelope
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutClinicInfoInput | ServiceProviderUpdateWithWhereUniqueWithoutClinicInfoInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutClinicInfoInput | ServiceProviderUpdateManyWithWhereWithoutClinicInfoInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type ScheduleUpdateOneWithoutClinicInfoNestedInput = {
    create?: XOR<ScheduleCreateWithoutClinicInfoInput, ScheduleUncheckedCreateWithoutClinicInfoInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutClinicInfoInput
    upsert?: ScheduleUpsertWithoutClinicInfoInput
    disconnect?: ScheduleWhereInput | boolean
    delete?: ScheduleWhereInput | boolean
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutClinicInfoInput, ScheduleUpdateWithoutClinicInfoInput>, ScheduleUncheckedUpdateWithoutClinicInfoInput>
  }

  export type ServiceProviderUncheckedUpdateManyWithoutClinicInfoNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutClinicInfoInput, ServiceProviderUncheckedCreateWithoutClinicInfoInput> | ServiceProviderCreateWithoutClinicInfoInput[] | ServiceProviderUncheckedCreateWithoutClinicInfoInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutClinicInfoInput | ServiceProviderCreateOrConnectWithoutClinicInfoInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutClinicInfoInput | ServiceProviderUpsertWithWhereUniqueWithoutClinicInfoInput[]
    createMany?: ServiceProviderCreateManyClinicInfoInputEnvelope
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutClinicInfoInput | ServiceProviderUpdateWithWhereUniqueWithoutClinicInfoInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutClinicInfoInput | ServiceProviderUpdateManyWithWhereWithoutClinicInfoInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    connect?: UserWhereUniqueInput
  }

  export type ClinicInfoCreateNestedOneWithoutAddressInput = {
    create?: XOR<ClinicInfoCreateWithoutAddressInput, ClinicInfoUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutAddressInput
    connect?: ClinicInfoWhereUniqueInput
  }

  export type ClinicInfoUncheckedCreateNestedOneWithoutAddressInput = {
    create?: XOR<ClinicInfoCreateWithoutAddressInput, ClinicInfoUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutAddressInput
    connect?: ClinicInfoWhereUniqueInput
  }

  export type UserUpdateOneWithoutAddressNestedInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    upsert?: UserUpsertWithoutAddressInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressInput, UserUpdateWithoutAddressInput>, UserUncheckedUpdateWithoutAddressInput>
  }

  export type ClinicInfoUpdateOneWithoutAddressNestedInput = {
    create?: XOR<ClinicInfoCreateWithoutAddressInput, ClinicInfoUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutAddressInput
    upsert?: ClinicInfoUpsertWithoutAddressInput
    disconnect?: ClinicInfoWhereInput | boolean
    delete?: ClinicInfoWhereInput | boolean
    connect?: ClinicInfoWhereUniqueInput
    update?: XOR<XOR<ClinicInfoUpdateToOneWithWhereWithoutAddressInput, ClinicInfoUpdateWithoutAddressInput>, ClinicInfoUncheckedUpdateWithoutAddressInput>
  }

  export type ClinicInfoUncheckedUpdateOneWithoutAddressNestedInput = {
    create?: XOR<ClinicInfoCreateWithoutAddressInput, ClinicInfoUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ClinicInfoCreateOrConnectWithoutAddressInput
    upsert?: ClinicInfoUpsertWithoutAddressInput
    disconnect?: ClinicInfoWhereInput | boolean
    delete?: ClinicInfoWhereInput | boolean
    connect?: ClinicInfoWhereUniqueInput
    update?: XOR<XOR<ClinicInfoUpdateToOneWithWhereWithoutAddressInput, ClinicInfoUpdateWithoutAddressInput>, ClinicInfoUncheckedUpdateWithoutAddressInput>
  }

  export type ServiceProviderCreateNestedOneWithoutEducationInput = {
    create?: XOR<ServiceProviderCreateWithoutEducationInput, ServiceProviderUncheckedCreateWithoutEducationInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutEducationInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type ServiceProviderUpdateOneRequiredWithoutEducationNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutEducationInput, ServiceProviderUncheckedCreateWithoutEducationInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutEducationInput
    upsert?: ServiceProviderUpsertWithoutEducationInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutEducationInput, ServiceProviderUpdateWithoutEducationInput>, ServiceProviderUncheckedUpdateWithoutEducationInput>
  }

  export type ServiceProviderCreateNestedOneWithoutWorkExperienceInput = {
    create?: XOR<ServiceProviderCreateWithoutWorkExperienceInput, ServiceProviderUncheckedCreateWithoutWorkExperienceInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutWorkExperienceInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type ServiceProviderUpdateOneRequiredWithoutWorkExperienceNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutWorkExperienceInput, ServiceProviderUncheckedCreateWithoutWorkExperienceInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutWorkExperienceInput
    upsert?: ServiceProviderUpsertWithoutWorkExperienceInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutWorkExperienceInput, ServiceProviderUpdateWithoutWorkExperienceInput>, ServiceProviderUncheckedUpdateWithoutWorkExperienceInput>
  }

  export type ServiceProviderCreateNestedOneWithoutAwardsInput = {
    create?: XOR<ServiceProviderCreateWithoutAwardsInput, ServiceProviderUncheckedCreateWithoutAwardsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutAwardsInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type ServiceProviderUpdateOneRequiredWithoutAwardsNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutAwardsInput, ServiceProviderUncheckedCreateWithoutAwardsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutAwardsInput
    upsert?: ServiceProviderUpsertWithoutAwardsInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutAwardsInput, ServiceProviderUpdateWithoutAwardsInput>, ServiceProviderUncheckedUpdateWithoutAwardsInput>
  }

  export type AppointmentCreateNestedOneWithoutCurrentLocationInput = {
    create?: XOR<AppointmentCreateWithoutCurrentLocationInput, AppointmentUncheckedCreateWithoutCurrentLocationInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutCurrentLocationInput
    connect?: AppointmentWhereUniqueInput
  }

  export type AppointmentUpdateOneWithoutCurrentLocationNestedInput = {
    create?: XOR<AppointmentCreateWithoutCurrentLocationInput, AppointmentUncheckedCreateWithoutCurrentLocationInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutCurrentLocationInput
    upsert?: AppointmentUpsertWithoutCurrentLocationInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutCurrentLocationInput, AppointmentUpdateWithoutCurrentLocationInput>, AppointmentUncheckedUpdateWithoutCurrentLocationInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ServiceProviderCreateNestedManyWithoutTagsInput = {
    create?: XOR<ServiceProviderCreateWithoutTagsInput, ServiceProviderUncheckedCreateWithoutTagsInput> | ServiceProviderCreateWithoutTagsInput[] | ServiceProviderUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutTagsInput | ServiceProviderCreateOrConnectWithoutTagsInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutTagsInput = {
    create?: XOR<AppointmentCreateWithoutTagsInput, AppointmentUncheckedCreateWithoutTagsInput> | AppointmentCreateWithoutTagsInput[] | AppointmentUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTagsInput | AppointmentCreateOrConnectWithoutTagsInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutTagsInput = {
    create?: XOR<PatientCreateWithoutTagsInput, PatientUncheckedCreateWithoutTagsInput> | PatientCreateWithoutTagsInput[] | PatientUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTagsInput | PatientCreateOrConnectWithoutTagsInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type ServiceProviderUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ServiceProviderCreateWithoutTagsInput, ServiceProviderUncheckedCreateWithoutTagsInput> | ServiceProviderCreateWithoutTagsInput[] | ServiceProviderUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutTagsInput | ServiceProviderCreateOrConnectWithoutTagsInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<AppointmentCreateWithoutTagsInput, AppointmentUncheckedCreateWithoutTagsInput> | AppointmentCreateWithoutTagsInput[] | AppointmentUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTagsInput | AppointmentCreateOrConnectWithoutTagsInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<PatientCreateWithoutTagsInput, PatientUncheckedCreateWithoutTagsInput> | PatientCreateWithoutTagsInput[] | PatientUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTagsInput | PatientCreateOrConnectWithoutTagsInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type ServiceProviderUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutTagsInput, ServiceProviderUncheckedCreateWithoutTagsInput> | ServiceProviderCreateWithoutTagsInput[] | ServiceProviderUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutTagsInput | ServiceProviderCreateOrConnectWithoutTagsInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutTagsInput | ServiceProviderUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutTagsInput | ServiceProviderUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutTagsInput | ServiceProviderUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutTagsNestedInput = {
    create?: XOR<AppointmentCreateWithoutTagsInput, AppointmentUncheckedCreateWithoutTagsInput> | AppointmentCreateWithoutTagsInput[] | AppointmentUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTagsInput | AppointmentCreateOrConnectWithoutTagsInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutTagsInput | AppointmentUpsertWithWhereUniqueWithoutTagsInput[]
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutTagsInput | AppointmentUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutTagsInput | AppointmentUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PatientCreateWithoutTagsInput, PatientUncheckedCreateWithoutTagsInput> | PatientCreateWithoutTagsInput[] | PatientUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTagsInput | PatientCreateOrConnectWithoutTagsInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutTagsInput | PatientUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutTagsInput | PatientUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutTagsInput | PatientUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type ServiceProviderUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutTagsInput, ServiceProviderUncheckedCreateWithoutTagsInput> | ServiceProviderCreateWithoutTagsInput[] | ServiceProviderUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutTagsInput | ServiceProviderCreateOrConnectWithoutTagsInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutTagsInput | ServiceProviderUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutTagsInput | ServiceProviderUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutTagsInput | ServiceProviderUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<AppointmentCreateWithoutTagsInput, AppointmentUncheckedCreateWithoutTagsInput> | AppointmentCreateWithoutTagsInput[] | AppointmentUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTagsInput | AppointmentCreateOrConnectWithoutTagsInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutTagsInput | AppointmentUpsertWithWhereUniqueWithoutTagsInput[]
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutTagsInput | AppointmentUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutTagsInput | AppointmentUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PatientCreateWithoutTagsInput, PatientUncheckedCreateWithoutTagsInput> | PatientCreateWithoutTagsInput[] | PatientUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTagsInput | PatientCreateOrConnectWithoutTagsInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutTagsInput | PatientUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutTagsInput | PatientUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutTagsInput | PatientUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumBloodGroupNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodGroup | EnumBloodGroupFieldRefInput<$PrismaModel> | null
    in?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBloodGroupNullableFilter<$PrismaModel> | $Enums.BloodGroup | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumBloodGroupNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodGroup | EnumBloodGroupFieldRefInput<$PrismaModel> | null
    in?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBloodGroupNullableWithAggregatesFilter<$PrismaModel> | $Enums.BloodGroup | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBloodGroupNullableFilter<$PrismaModel>
    _max?: NestedEnumBloodGroupNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumBloodGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodGroup | EnumBloodGroupFieldRefInput<$PrismaModel>
    in?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumBloodGroupFilter<$PrismaModel> | $Enums.BloodGroup
  }

  export type NestedEnumBloodGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodGroup | EnumBloodGroupFieldRefInput<$PrismaModel>
    in?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.BloodGroup[] | ListEnumBloodGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumBloodGroupWithAggregatesFilter<$PrismaModel> | $Enums.BloodGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBloodGroupFilter<$PrismaModel>
    _max?: NestedEnumBloodGroupFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumProviderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderType | EnumProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderTypeFilter<$PrismaModel> | $Enums.ProviderType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumProviderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderType | EnumProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProviderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderTypeFilter<$PrismaModel>
    _max?: NestedEnumProviderTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPermissionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionType | EnumPermissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionType[] | ListEnumPermissionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionType[] | ListEnumPermissionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionTypeFilter<$PrismaModel> | $Enums.PermissionType
  }

  export type NestedEnumPermissionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionType | EnumPermissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionType[] | ListEnumPermissionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionType[] | ListEnumPermissionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PermissionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionTypeFilter<$PrismaModel>
    _max?: NestedEnumPermissionTypeFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumWeekDayNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDay | EnumWeekDayFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWeekDayNullableFilter<$PrismaModel> | $Enums.WeekDay | null
  }

  export type NestedEnumRecurrenceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceType | EnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrenceType[] | ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrenceType[] | ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceTypeNullableFilter<$PrismaModel> | $Enums.RecurrenceType | null
  }

  export type NestedEnumServiceFilter<$PrismaModel = never> = {
    equals?: $Enums.Service | EnumServiceFieldRefInput<$PrismaModel>
    in?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceFilter<$PrismaModel> | $Enums.Service
  }

  export type NestedEnumWeekDayNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDay | EnumWeekDayFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWeekDayNullableWithAggregatesFilter<$PrismaModel> | $Enums.WeekDay | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWeekDayNullableFilter<$PrismaModel>
    _max?: NestedEnumWeekDayNullableFilter<$PrismaModel>
  }

  export type NestedEnumRecurrenceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceType | EnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrenceType[] | ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrenceType[] | ListEnumRecurrenceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurrenceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumServiceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Service | EnumServiceFieldRefInput<$PrismaModel>
    in?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Service[] | ListEnumServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceWithAggregatesFilter<$PrismaModel> | $Enums.Service
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceFilter<$PrismaModel>
    _max?: NestedEnumServiceFilter<$PrismaModel>
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type AddressCreateWithoutUserInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    clinicInfo?: ClinicInfoCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    clinicInfo?: ClinicInfoUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutUserInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labResults?: LabResultCreateNestedManyWithoutPatientInput
    adminPanel: AdminPanelCreateNestedOneWithoutPatientInput
    tags?: TagCreateNestedManyWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutUserInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutPatientInput
    tags?: TagUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type PatientCreateOrConnectWithoutUserInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type PatientCreateManyUserInputEnvelope = {
    data: PatientCreateManyUserInput | PatientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DoctorCreateWithoutUserInput = {
    id?: string
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    assistants?: DoctorsAssistantCreateNestedManyWithoutDoctorInput
    requests?: RequestCreateNestedManyWithoutDoctorInput
    serviceprovider: ServiceProviderCreateNestedOneWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutUserInput = {
    id?: string
    serviceproviderId: string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    assistants?: DoctorsAssistantUncheckedCreateNestedManyWithoutDoctorInput
    requests?: RequestUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutUserInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
  }

  export type SuperAdminCreateWithoutUserInput = {
    id?: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    admin?: AdminCreateNestedManyWithoutSuperAdminInput
    adminPanel: AdminPanelCreateNestedOneWithoutSuperAdminIdInput
  }

  export type SuperAdminUncheckedCreateWithoutUserInput = {
    id?: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    adminPanelId: string
    admin?: AdminUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminCreateOrConnectWithoutUserInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanel: AdminPanelCreateNestedOneWithoutAdminIdInput
    superAdmin: SuperAdminCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId: string
    superAdminId: string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type LabCreateWithoutUserInput = {
    id?: string
    servicesOffered?: LabCreateservicesOfferedInput | string[]
  }

  export type LabUncheckedCreateWithoutUserInput = {
    id?: string
    servicesOffered?: LabCreateservicesOfferedInput | string[]
  }

  export type LabCreateOrConnectWithoutUserInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutUserInput, LabUncheckedCreateWithoutUserInput>
  }

  export type HospitalCreateWithoutUserInput = {
    id?: string
    servicesOffered?: HospitalCreateservicesOfferedInput | string[]
  }

  export type HospitalUncheckedCreateWithoutUserInput = {
    id?: string
    servicesOffered?: HospitalCreateservicesOfferedInput | string[]
  }

  export type HospitalCreateOrConnectWithoutUserInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>
  }

  export type NursingCreateWithoutUserInput = {
    id?: string
    servicesOffered?: NursingCreateservicesOfferedInput | string[]
  }

  export type NursingUncheckedCreateWithoutUserInput = {
    id?: string
    servicesOffered?: NursingCreateservicesOfferedInput | string[]
  }

  export type NursingCreateOrConnectWithoutUserInput = {
    where: NursingWhereUniqueInput
    create: XOR<NursingCreateWithoutUserInput, NursingUncheckedCreateWithoutUserInput>
  }

  export type DoctorsAssistantCreateWithoutUserInput = {
    id?: string
    doctor: DoctorCreateNestedOneWithoutAssistantsInput
    requestPermissions?: RequestPermissionCreateNestedManyWithoutDoctorsAssistantInput
  }

  export type DoctorsAssistantUncheckedCreateWithoutUserInput = {
    id?: string
    assignedDoctorId: string
    requestPermissions?: RequestPermissionUncheckedCreateNestedManyWithoutDoctorsAssistantInput
  }

  export type DoctorsAssistantCreateOrConnectWithoutUserInput = {
    where: DoctorsAssistantWhereUniqueInput
    create: XOR<DoctorsAssistantCreateWithoutUserInput, DoctorsAssistantUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    appointment: AppointmentCreateNestedOneWithoutPaymentInput
    transaction?: TransactionCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    appointmentId: string
    transaction?: TransactionUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordCreateWithoutUserInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    description?: string | null
    recordId?: string | null
    attachment?: string | null
    serviceProvider?: ServiceProviderCreateNestedOneWithoutMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateWithoutUserInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    description?: string | null
    recordId?: string | null
    attachment?: string | null
    serviceProviderId?: string | null
  }

  export type MedicalRecordCreateOrConnectWithoutUserInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutUserInput, MedicalRecordUncheckedCreateWithoutUserInput>
  }

  export type MedicalRecordCreateManyUserInputEnvelope = {
    data: MedicalRecordCreateManyUserInput | MedicalRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutUserInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationCreateNestedOneWithoutAppointmentInput
    slot: SlotCreateNestedOneWithoutAppointmentInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutAppointmentInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
    payment?: PaymentCreateNestedManyWithoutAppointmentInput
    tags?: TagCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutUserInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput
    payment?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    tags?: TagUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentCreateOrConnectWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput>
  }

  export type AppointmentCreateManyUserInputEnvelope = {
    data: AppointmentCreateManyUserInput | AppointmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutUserInput = {
    id?: string
    serviceProviderType: $Enums.ProviderType
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProvider: ServiceProviderCreateNestedOneWithoutRatingInput
  }

  export type RatingUncheckedCreateWithoutUserInput = {
    id?: string
    serviceProviderType: $Enums.ProviderType
    serviceProviderId: string
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutUserInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingCreateManyUserInputEnvelope = {
    data: RatingCreateManyUserInput | RatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    message: string
    type: string
    priority?: string
    isRead?: boolean
    expiresAt?: Date | string | null
    isRecurring?: boolean
    groupId?: string | null
    createdAt?: Date | string
    relatedEntityId?: string | null
    relatedEntity?: string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    type: string
    priority?: string
    isRead?: boolean
    expiresAt?: Date | string | null
    isRecurring?: boolean
    groupId?: string | null
    createdAt?: Date | string
    relatedEntityId?: string | null
    relatedEntity?: string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    entity: string
    entityId: string
    actionType: $Enums.ActionType
    status: $Enums.Status
    ipAddress?: string | null
    device?: string | null
    performedBy: string
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    entity: string
    entityId: string
    actionType: $Enums.ActionType
    status: $Enums.Status
    ipAddress?: string | null
    device?: string | null
    performedBy: string
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceProviderCreateWithoutUserInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderUncheckedCreateWithoutUserInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutUserInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutUserInput, ServiceProviderUncheckedCreateWithoutUserInput>
  }

  export type ServiceProviderCreateManyUserInputEnvelope = {
    data: ServiceProviderCreateManyUserInput | ServiceProviderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutUserInput = {
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutUserInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfo?: ClinicInfoUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfo?: ClinicInfoUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    providerType?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpires?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    sessionToken?: StringFilter<"Session"> | string
    accessToken?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type PatientUpsertWithWhereUniqueWithoutUserInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutUserInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PatientUpdateManyWithWhereWithoutUserInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutUserInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    age?: StringFilter<"Patient"> | string
    userId?: StringFilter<"Patient"> | string
    conditions?: StringNullableListFilter<"Patient">
    bloodGroup?: EnumBloodGroupFilter<"Patient"> | $Enums.BloodGroup
    adminPanelId?: StringFilter<"Patient"> | string
  }

  export type DoctorUpsertWithoutUserInput = {
    update: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutUserInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUpdateManyWithoutDoctorNestedInput
    requests?: RequestUpdateManyWithoutDoctorNestedInput
    serviceprovider?: ServiceProviderUpdateOneRequiredWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceproviderId?: StringFieldUpdateOperationsInput | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUncheckedUpdateManyWithoutDoctorNestedInput
    requests?: RequestUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type SuperAdminUpsertWithoutUserInput = {
    update: XOR<SuperAdminUpdateWithoutUserInput, SuperAdminUncheckedUpdateWithoutUserInput>
    create: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutUserInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutUserInput, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type SuperAdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    admin?: AdminUpdateManyWithoutSuperAdminNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutSuperAdminIdNestedInput
  }

  export type SuperAdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    adminPanelId?: StringFieldUpdateOperationsInput | string
    admin?: AdminUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    adminPanel?: AdminPanelUpdateOneRequiredWithoutAdminIdNestedInput
    superAdmin?: SuperAdminUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    adminPanelId?: StringFieldUpdateOperationsInput | string
    superAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabUpsertWithoutUserInput = {
    update: XOR<LabUpdateWithoutUserInput, LabUncheckedUpdateWithoutUserInput>
    create: XOR<LabCreateWithoutUserInput, LabUncheckedCreateWithoutUserInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutUserInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutUserInput, LabUncheckedUpdateWithoutUserInput>
  }

  export type LabUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: LabUpdateservicesOfferedInput | string[]
  }

  export type LabUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: LabUpdateservicesOfferedInput | string[]
  }

  export type HospitalUpsertWithoutUserInput = {
    update: XOR<HospitalUpdateWithoutUserInput, HospitalUncheckedUpdateWithoutUserInput>
    create: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutUserInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutUserInput, HospitalUncheckedUpdateWithoutUserInput>
  }

  export type HospitalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: HospitalUpdateservicesOfferedInput | string[]
  }

  export type HospitalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: HospitalUpdateservicesOfferedInput | string[]
  }

  export type NursingUpsertWithoutUserInput = {
    update: XOR<NursingUpdateWithoutUserInput, NursingUncheckedUpdateWithoutUserInput>
    create: XOR<NursingCreateWithoutUserInput, NursingUncheckedCreateWithoutUserInput>
    where?: NursingWhereInput
  }

  export type NursingUpdateToOneWithWhereWithoutUserInput = {
    where?: NursingWhereInput
    data: XOR<NursingUpdateWithoutUserInput, NursingUncheckedUpdateWithoutUserInput>
  }

  export type NursingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: NursingUpdateservicesOfferedInput | string[]
  }

  export type NursingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    servicesOffered?: NursingUpdateservicesOfferedInput | string[]
  }

  export type DoctorsAssistantUpsertWithoutUserInput = {
    update: XOR<DoctorsAssistantUpdateWithoutUserInput, DoctorsAssistantUncheckedUpdateWithoutUserInput>
    create: XOR<DoctorsAssistantCreateWithoutUserInput, DoctorsAssistantUncheckedCreateWithoutUserInput>
    where?: DoctorsAssistantWhereInput
  }

  export type DoctorsAssistantUpdateToOneWithWhereWithoutUserInput = {
    where?: DoctorsAssistantWhereInput
    data: XOR<DoctorsAssistantUpdateWithoutUserInput, DoctorsAssistantUncheckedUpdateWithoutUserInput>
  }

  export type DoctorsAssistantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctor?: DoctorUpdateOneRequiredWithoutAssistantsNestedInput
    requestPermissions?: RequestPermissionUpdateManyWithoutDoctorsAssistantNestedInput
  }

  export type DoctorsAssistantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    requestPermissions?: RequestPermissionUncheckedUpdateManyWithoutDoctorsAssistantNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    transactionId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: EnumStatusFilter<"Payment"> | $Enums.Status
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    refundDetails?: StringNullableFilter<"Payment"> | string | null
    userId?: StringFilter<"Payment"> | string
    appointmentId?: StringFilter<"Payment"> | string
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutUserInput, MedicalRecordUncheckedUpdateWithoutUserInput>
    create: XOR<MedicalRecordCreateWithoutUserInput, MedicalRecordUncheckedCreateWithoutUserInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutUserInput, MedicalRecordUncheckedUpdateWithoutUserInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutUserInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type MedicalRecordScalarWhereInput = {
    AND?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
    OR?: MedicalRecordScalarWhereInput[]
    NOT?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
    id?: StringFilter<"MedicalRecord"> | string
    diagnosis?: StringFilter<"MedicalRecord"> | string
    prescription?: StringFilter<"MedicalRecord"> | string
    notes?: StringNullableFilter<"MedicalRecord"> | string | null
    userId?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    recordId?: StringNullableFilter<"MedicalRecord"> | string | null
    attachment?: StringNullableFilter<"MedicalRecord"> | string | null
    serviceProviderId?: StringNullableFilter<"MedicalRecord"> | string | null
  }

  export type AppointmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutUserInput, AppointmentUncheckedUpdateWithoutUserInput>
    create: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutUserInput, AppointmentUncheckedUpdateWithoutUserInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutUserInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    service?: EnumServiceNullableListFilter<"Appointment">
    status?: EnumStatusFilter<"Appointment"> | $Enums.Status
    appointmentTime?: DateTimeFilter<"Appointment"> | Date | string
    bookedAt?: DateTimeFilter<"Appointment"> | Date | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    isForOthers?: BoolFilter<"Appointment"> | boolean
    slotId?: StringFilter<"Appointment"> | string
    userId?: StringFilter<"Appointment"> | string
    serviceProviderId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type RatingUpsertWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
  }

  export type RatingUpdateManyWithWhereWithoutUserInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutUserInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    id?: StringFilter<"Rating"> | string
    userId?: StringFilter<"Rating"> | string
    serviceProviderType?: EnumProviderTypeFilter<"Rating"> | $Enums.ProviderType
    serviceProviderId?: StringFilter<"Rating"> | string
    score?: FloatFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    isRecurring?: BoolFilter<"Notification"> | boolean
    groupId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntity?: StringNullableFilter<"Notification"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    actionType?: EnumActionTypeFilter<"AuditLog"> | $Enums.ActionType
    status?: EnumStatusFilter<"AuditLog"> | $Enums.Status
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    device?: StringNullableFilter<"AuditLog"> | string | null
    performedBy?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: StringFilter<"AuditLog"> | string
  }

  export type ServiceProviderUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceProviderWhereUniqueInput
    update: XOR<ServiceProviderUpdateWithoutUserInput, ServiceProviderUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceProviderCreateWithoutUserInput, ServiceProviderUncheckedCreateWithoutUserInput>
  }

  export type ServiceProviderUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceProviderWhereUniqueInput
    data: XOR<ServiceProviderUpdateWithoutUserInput, ServiceProviderUncheckedUpdateWithoutUserInput>
  }

  export type ServiceProviderUpdateManyWithWhereWithoutUserInput = {
    where: ServiceProviderScalarWhereInput
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceProviderScalarWhereInput = {
    AND?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
    OR?: ServiceProviderScalarWhereInput[]
    NOT?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
    id?: StringFilter<"ServiceProvider"> | string
    providerId?: StringFilter<"ServiceProvider"> | string
    name?: StringFilter<"ServiceProvider"> | string
    age?: IntNullableFilter<"ServiceProvider"> | number | null
    dob?: DateTimeNullableFilter<"ServiceProvider"> | Date | string | null
    providerType?: EnumProviderTypeFilter<"ServiceProvider"> | $Enums.ProviderType
    specialization?: StringNullableListFilter<"ServiceProvider">
    fee?: FloatNullableFilter<"ServiceProvider"> | number | null
    experience?: IntNullableFilter<"ServiceProvider"> | number | null
    description?: StringNullableFilter<"ServiceProvider"> | string | null
    service?: EnumServiceNullableListFilter<"ServiceProvider">
    status?: EnumStatusFilter<"ServiceProvider"> | $Enums.Status
    document?: StringNullableFilter<"ServiceProvider"> | string | null
    registrationNumber?: StringNullableFilter<"ServiceProvider"> | string | null
    clinicInfoId?: StringNullableFilter<"ServiceProvider"> | string | null
    adminPanelId?: StringNullableFilter<"ServiceProvider"> | string | null
    userId?: StringFilter<"ServiceProvider"> | string
    createdAt?: DateTimeFilter<"ServiceProvider"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPatientInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPatientInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPatientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
  }

  export type AllergyCreateWithoutPatientInput = {
    id?: string
    allergen: string
    type: string
    severity: string
    reaction: string
  }

  export type AllergyUncheckedCreateWithoutPatientInput = {
    id?: string
    allergen: string
    type: string
    severity: string
    reaction: string
  }

  export type AllergyCreateOrConnectWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    create: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput>
  }

  export type AllergyCreateManyPatientInputEnvelope = {
    data: AllergyCreateManyPatientInput | AllergyCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TherapyPlanCreateWithoutPatientInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    serviceProvider: ServiceProviderCreateNestedOneWithoutTherapyPlansInput
  }

  export type TherapyPlanUncheckedCreateWithoutPatientInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    serviceProvideId: string
  }

  export type TherapyPlanCreateOrConnectWithoutPatientInput = {
    where: TherapyPlanWhereUniqueInput
    create: XOR<TherapyPlanCreateWithoutPatientInput, TherapyPlanUncheckedCreateWithoutPatientInput>
  }

  export type TherapyPlanCreateManyPatientInputEnvelope = {
    data: TherapyPlanCreateManyPatientInput | TherapyPlanCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationCreateNestedOneWithoutAppointmentInput
    slot: SlotCreateNestedOneWithoutAppointmentInput
    user: UserCreateNestedOneWithoutAppointmentsInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutAppointmentInput
    payment?: PaymentCreateNestedManyWithoutAppointmentInput
    tags?: TagCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput
    payment?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    tags?: TagUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutPatientInput = {
    id?: string
    notes?: string | null
    dateIssued: Date | string
    medications?: MedicationCreateNestedManyWithoutPrescriptionInput
    doctor: DoctorCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId: string
    notes?: string | null
    dateIssued: Date | string
    medications?: MedicationUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: PrescriptionCreateManyPatientInput | PrescriptionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LabResultCreateWithoutPatientInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    serviceProvider: ServiceProviderCreateNestedOneWithoutLabResultsInput
  }

  export type LabResultUncheckedCreateWithoutPatientInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    serviceProvideId: string
  }

  export type LabResultCreateOrConnectWithoutPatientInput = {
    where: LabResultWhereUniqueInput
    create: XOR<LabResultCreateWithoutPatientInput, LabResultUncheckedCreateWithoutPatientInput>
  }

  export type LabResultCreateManyPatientInputEnvelope = {
    data: LabResultCreateManyPatientInput | LabResultCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AdminPanelCreateWithoutPatientInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: ServiceProviderCreateNestedManyWithoutAdminPanelInput
    superAdminId?: SuperAdminCreateNestedManyWithoutAdminPanelInput
    adminId?: AdminCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelUncheckedCreateWithoutPatientInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutAdminPanelInput
    superAdminId?: SuperAdminUncheckedCreateNestedManyWithoutAdminPanelInput
    adminId?: AdminUncheckedCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelCreateOrConnectWithoutPatientInput = {
    where: AdminPanelWhereUniqueInput
    create: XOR<AdminPanelCreateWithoutPatientInput, AdminPanelUncheckedCreateWithoutPatientInput>
  }

  export type TagCreateWithoutPatientsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderCreateNestedManyWithoutTagsInput
    appointments?: AppointmentCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutPatientsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderUncheckedCreateNestedManyWithoutTagsInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutPatientsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPatientsInput, TagUncheckedCreateWithoutPatientsInput>
  }

  export type UserUpsertWithoutPatientInput = {
    update: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
  }

  export type UserUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AllergyUpsertWithWhereUniqueWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    update: XOR<AllergyUpdateWithoutPatientInput, AllergyUncheckedUpdateWithoutPatientInput>
    create: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput>
  }

  export type AllergyUpdateWithWhereUniqueWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    data: XOR<AllergyUpdateWithoutPatientInput, AllergyUncheckedUpdateWithoutPatientInput>
  }

  export type AllergyUpdateManyWithWhereWithoutPatientInput = {
    where: AllergyScalarWhereInput
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyWithoutPatientInput>
  }

  export type AllergyScalarWhereInput = {
    AND?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
    OR?: AllergyScalarWhereInput[]
    NOT?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
    id?: StringFilter<"Allergy"> | string
    allergen?: StringFilter<"Allergy"> | string
    type?: StringFilter<"Allergy"> | string
    severity?: StringFilter<"Allergy"> | string
    reaction?: StringFilter<"Allergy"> | string
    patientId?: StringFilter<"Allergy"> | string
  }

  export type TherapyPlanUpsertWithWhereUniqueWithoutPatientInput = {
    where: TherapyPlanWhereUniqueInput
    update: XOR<TherapyPlanUpdateWithoutPatientInput, TherapyPlanUncheckedUpdateWithoutPatientInput>
    create: XOR<TherapyPlanCreateWithoutPatientInput, TherapyPlanUncheckedCreateWithoutPatientInput>
  }

  export type TherapyPlanUpdateWithWhereUniqueWithoutPatientInput = {
    where: TherapyPlanWhereUniqueInput
    data: XOR<TherapyPlanUpdateWithoutPatientInput, TherapyPlanUncheckedUpdateWithoutPatientInput>
  }

  export type TherapyPlanUpdateManyWithWhereWithoutPatientInput = {
    where: TherapyPlanScalarWhereInput
    data: XOR<TherapyPlanUpdateManyMutationInput, TherapyPlanUncheckedUpdateManyWithoutPatientInput>
  }

  export type TherapyPlanScalarWhereInput = {
    AND?: TherapyPlanScalarWhereInput | TherapyPlanScalarWhereInput[]
    OR?: TherapyPlanScalarWhereInput[]
    NOT?: TherapyPlanScalarWhereInput | TherapyPlanScalarWhereInput[]
    id?: StringFilter<"TherapyPlan"> | string
    planName?: StringFilter<"TherapyPlan"> | string
    date?: DateTimeFilter<"TherapyPlan"> | Date | string
    type?: StringFilter<"TherapyPlan"> | string
    status?: StringFilter<"TherapyPlan"> | string
    details?: StringFilter<"TherapyPlan"> | string
    patientId?: StringFilter<"TherapyPlan"> | string
    serviceProvideId?: StringFilter<"TherapyPlan"> | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: StringFilter<"Prescription"> | string
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    notes?: StringNullableFilter<"Prescription"> | string | null
    dateIssued?: DateTimeFilter<"Prescription"> | Date | string
  }

  export type LabResultUpsertWithWhereUniqueWithoutPatientInput = {
    where: LabResultWhereUniqueInput
    update: XOR<LabResultUpdateWithoutPatientInput, LabResultUncheckedUpdateWithoutPatientInput>
    create: XOR<LabResultCreateWithoutPatientInput, LabResultUncheckedCreateWithoutPatientInput>
  }

  export type LabResultUpdateWithWhereUniqueWithoutPatientInput = {
    where: LabResultWhereUniqueInput
    data: XOR<LabResultUpdateWithoutPatientInput, LabResultUncheckedUpdateWithoutPatientInput>
  }

  export type LabResultUpdateManyWithWhereWithoutPatientInput = {
    where: LabResultScalarWhereInput
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyWithoutPatientInput>
  }

  export type LabResultScalarWhereInput = {
    AND?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
    OR?: LabResultScalarWhereInput[]
    NOT?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
    id?: StringFilter<"LabResult"> | string
    testName?: StringFilter<"LabResult"> | string
    testDate?: DateTimeFilter<"LabResult"> | Date | string
    result?: StringFilter<"LabResult"> | string
    referenceRange?: StringFilter<"LabResult"> | string
    status?: StringFilter<"LabResult"> | string
    patientId?: StringFilter<"LabResult"> | string
    serviceProvideId?: StringFilter<"LabResult"> | string
  }

  export type AdminPanelUpsertWithoutPatientInput = {
    update: XOR<AdminPanelUpdateWithoutPatientInput, AdminPanelUncheckedUpdateWithoutPatientInput>
    create: XOR<AdminPanelCreateWithoutPatientInput, AdminPanelUncheckedCreateWithoutPatientInput>
    where?: AdminPanelWhereInput
  }

  export type AdminPanelUpdateToOneWithWhereWithoutPatientInput = {
    where?: AdminPanelWhereInput
    data: XOR<AdminPanelUpdateWithoutPatientInput, AdminPanelUncheckedUpdateWithoutPatientInput>
  }

  export type AdminPanelUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderUpdateManyWithoutAdminPanelNestedInput
    superAdminId?: SuperAdminUpdateManyWithoutAdminPanelNestedInput
    adminId?: AdminUpdateManyWithoutAdminPanelNestedInput
  }

  export type AdminPanelUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutAdminPanelNestedInput
    superAdminId?: SuperAdminUncheckedUpdateManyWithoutAdminPanelNestedInput
    adminId?: AdminUncheckedUpdateManyWithoutAdminPanelNestedInput
  }

  export type TagUpsertWithWhereUniqueWithoutPatientsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutPatientsInput, TagUncheckedUpdateWithoutPatientsInput>
    create: XOR<TagCreateWithoutPatientsInput, TagUncheckedCreateWithoutPatientsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutPatientsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutPatientsInput, TagUncheckedUpdateWithoutPatientsInput>
  }

  export type TagUpdateManyWithWhereWithoutPatientsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutPatientsInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type ServiceProviderCreateWithoutAdminPanelInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutAdminPanelInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutAdminPanelInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutAdminPanelInput, ServiceProviderUncheckedCreateWithoutAdminPanelInput>
  }

  export type ServiceProviderCreateManyAdminPanelInputEnvelope = {
    data: ServiceProviderCreateManyAdminPanelInput | ServiceProviderCreateManyAdminPanelInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutAdminPanelInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    user: UserCreateNestedOneWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labResults?: LabResultCreateNestedManyWithoutPatientInput
    tags?: TagCreateNestedManyWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutAdminPanelInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutPatientInput
    tags?: TagUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type PatientCreateOrConnectWithoutAdminPanelInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAdminPanelInput, PatientUncheckedCreateWithoutAdminPanelInput>
  }

  export type PatientCreateManyAdminPanelInputEnvelope = {
    data: PatientCreateManyAdminPanelInput | PatientCreateManyAdminPanelInput[]
    skipDuplicates?: boolean
  }

  export type SuperAdminCreateWithoutAdminPanelInput = {
    id?: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    user: UserCreateNestedOneWithoutSuperAdminInput
    admin?: AdminCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminUncheckedCreateWithoutAdminPanelInput = {
    id?: string
    userId: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    admin?: AdminUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminCreateOrConnectWithoutAdminPanelInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutAdminPanelInput, SuperAdminUncheckedCreateWithoutAdminPanelInput>
  }

  export type SuperAdminCreateManyAdminPanelInputEnvelope = {
    data: SuperAdminCreateManyAdminPanelInput | SuperAdminCreateManyAdminPanelInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutAdminPanelInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    user: UserCreateNestedOneWithoutAdminInput
    superAdmin: SuperAdminCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutAdminPanelInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    superAdminId: string
  }

  export type AdminCreateOrConnectWithoutAdminPanelInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAdminPanelInput, AdminUncheckedCreateWithoutAdminPanelInput>
  }

  export type AdminCreateManyAdminPanelInputEnvelope = {
    data: AdminCreateManyAdminPanelInput | AdminCreateManyAdminPanelInput[]
    skipDuplicates?: boolean
  }

  export type ServiceProviderUpsertWithWhereUniqueWithoutAdminPanelInput = {
    where: ServiceProviderWhereUniqueInput
    update: XOR<ServiceProviderUpdateWithoutAdminPanelInput, ServiceProviderUncheckedUpdateWithoutAdminPanelInput>
    create: XOR<ServiceProviderCreateWithoutAdminPanelInput, ServiceProviderUncheckedCreateWithoutAdminPanelInput>
  }

  export type ServiceProviderUpdateWithWhereUniqueWithoutAdminPanelInput = {
    where: ServiceProviderWhereUniqueInput
    data: XOR<ServiceProviderUpdateWithoutAdminPanelInput, ServiceProviderUncheckedUpdateWithoutAdminPanelInput>
  }

  export type ServiceProviderUpdateManyWithWhereWithoutAdminPanelInput = {
    where: ServiceProviderScalarWhereInput
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyWithoutAdminPanelInput>
  }

  export type PatientUpsertWithWhereUniqueWithoutAdminPanelInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutAdminPanelInput, PatientUncheckedUpdateWithoutAdminPanelInput>
    create: XOR<PatientCreateWithoutAdminPanelInput, PatientUncheckedCreateWithoutAdminPanelInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutAdminPanelInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutAdminPanelInput, PatientUncheckedUpdateWithoutAdminPanelInput>
  }

  export type PatientUpdateManyWithWhereWithoutAdminPanelInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutAdminPanelInput>
  }

  export type SuperAdminUpsertWithWhereUniqueWithoutAdminPanelInput = {
    where: SuperAdminWhereUniqueInput
    update: XOR<SuperAdminUpdateWithoutAdminPanelInput, SuperAdminUncheckedUpdateWithoutAdminPanelInput>
    create: XOR<SuperAdminCreateWithoutAdminPanelInput, SuperAdminUncheckedCreateWithoutAdminPanelInput>
  }

  export type SuperAdminUpdateWithWhereUniqueWithoutAdminPanelInput = {
    where: SuperAdminWhereUniqueInput
    data: XOR<SuperAdminUpdateWithoutAdminPanelInput, SuperAdminUncheckedUpdateWithoutAdminPanelInput>
  }

  export type SuperAdminUpdateManyWithWhereWithoutAdminPanelInput = {
    where: SuperAdminScalarWhereInput
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyWithoutAdminPanelInput>
  }

  export type SuperAdminScalarWhereInput = {
    AND?: SuperAdminScalarWhereInput | SuperAdminScalarWhereInput[]
    OR?: SuperAdminScalarWhereInput[]
    NOT?: SuperAdminScalarWhereInput | SuperAdminScalarWhereInput[]
    id?: StringFilter<"SuperAdmin"> | string
    userId?: StringFilter<"SuperAdmin"> | string
    permissions?: StringNullableListFilter<"SuperAdmin">
    status?: EnumStatusFilter<"SuperAdmin"> | $Enums.Status
    adminPanelId?: StringFilter<"SuperAdmin"> | string
  }

  export type AdminUpsertWithWhereUniqueWithoutAdminPanelInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutAdminPanelInput, AdminUncheckedUpdateWithoutAdminPanelInput>
    create: XOR<AdminCreateWithoutAdminPanelInput, AdminUncheckedCreateWithoutAdminPanelInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutAdminPanelInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutAdminPanelInput, AdminUncheckedUpdateWithoutAdminPanelInput>
  }

  export type AdminUpdateManyWithWhereWithoutAdminPanelInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutAdminPanelInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    canManageProviders?: BoolFilter<"Admin"> | boolean
    canViewAllTransactions?: BoolFilter<"Admin"> | boolean
    canViewAllAppointments?: BoolFilter<"Admin"> | boolean
    adminPanelId?: StringFilter<"Admin"> | string
    superAdminId?: StringFilter<"Admin"> | string
  }

  export type UserCreateWithoutSuperAdminInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSuperAdminInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSuperAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
  }

  export type AdminCreateWithoutSuperAdminInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    user: UserCreateNestedOneWithoutAdminInput
    adminPanel: AdminPanelCreateNestedOneWithoutAdminIdInput
  }

  export type AdminUncheckedCreateWithoutSuperAdminInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId: string
  }

  export type AdminCreateOrConnectWithoutSuperAdminInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput>
  }

  export type AdminCreateManySuperAdminInputEnvelope = {
    data: AdminCreateManySuperAdminInput | AdminCreateManySuperAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminPanelCreateWithoutSuperAdminIdInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: ServiceProviderCreateNestedManyWithoutAdminPanelInput
    patient?: PatientCreateNestedManyWithoutAdminPanelInput
    adminId?: AdminCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelUncheckedCreateWithoutSuperAdminIdInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutAdminPanelInput
    patient?: PatientUncheckedCreateNestedManyWithoutAdminPanelInput
    adminId?: AdminUncheckedCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelCreateOrConnectWithoutSuperAdminIdInput = {
    where: AdminPanelWhereUniqueInput
    create: XOR<AdminPanelCreateWithoutSuperAdminIdInput, AdminPanelUncheckedCreateWithoutSuperAdminIdInput>
  }

  export type UserUpsertWithoutSuperAdminInput = {
    update: XOR<UserUpdateWithoutSuperAdminInput, UserUncheckedUpdateWithoutSuperAdminInput>
    create: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuperAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuperAdminInput, UserUncheckedUpdateWithoutSuperAdminInput>
  }

  export type UserUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminUpsertWithWhereUniqueWithoutSuperAdminInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutSuperAdminInput, AdminUncheckedUpdateWithoutSuperAdminInput>
    create: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutSuperAdminInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutSuperAdminInput, AdminUncheckedUpdateWithoutSuperAdminInput>
  }

  export type AdminUpdateManyWithWhereWithoutSuperAdminInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutSuperAdminInput>
  }

  export type AdminPanelUpsertWithoutSuperAdminIdInput = {
    update: XOR<AdminPanelUpdateWithoutSuperAdminIdInput, AdminPanelUncheckedUpdateWithoutSuperAdminIdInput>
    create: XOR<AdminPanelCreateWithoutSuperAdminIdInput, AdminPanelUncheckedCreateWithoutSuperAdminIdInput>
    where?: AdminPanelWhereInput
  }

  export type AdminPanelUpdateToOneWithWhereWithoutSuperAdminIdInput = {
    where?: AdminPanelWhereInput
    data: XOR<AdminPanelUpdateWithoutSuperAdminIdInput, AdminPanelUncheckedUpdateWithoutSuperAdminIdInput>
  }

  export type AdminPanelUpdateWithoutSuperAdminIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderUpdateManyWithoutAdminPanelNestedInput
    patient?: PatientUpdateManyWithoutAdminPanelNestedInput
    adminId?: AdminUpdateManyWithoutAdminPanelNestedInput
  }

  export type AdminPanelUncheckedUpdateWithoutSuperAdminIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutAdminPanelNestedInput
    patient?: PatientUncheckedUpdateManyWithoutAdminPanelNestedInput
    adminId?: AdminUncheckedUpdateManyWithoutAdminPanelNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type AdminPanelCreateWithoutAdminIdInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: ServiceProviderCreateNestedManyWithoutAdminPanelInput
    patient?: PatientCreateNestedManyWithoutAdminPanelInput
    superAdminId?: SuperAdminCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelUncheckedCreateWithoutAdminIdInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutAdminPanelInput
    patient?: PatientUncheckedCreateNestedManyWithoutAdminPanelInput
    superAdminId?: SuperAdminUncheckedCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelCreateOrConnectWithoutAdminIdInput = {
    where: AdminPanelWhereUniqueInput
    create: XOR<AdminPanelCreateWithoutAdminIdInput, AdminPanelUncheckedCreateWithoutAdminIdInput>
  }

  export type SuperAdminCreateWithoutAdminInput = {
    id?: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    user: UserCreateNestedOneWithoutSuperAdminInput
    adminPanel: AdminPanelCreateNestedOneWithoutSuperAdminIdInput
  }

  export type SuperAdminUncheckedCreateWithoutAdminInput = {
    id?: string
    userId: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
    adminPanelId: string
  }

  export type SuperAdminCreateOrConnectWithoutAdminInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutAdminInput, SuperAdminUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminPanelUpsertWithoutAdminIdInput = {
    update: XOR<AdminPanelUpdateWithoutAdminIdInput, AdminPanelUncheckedUpdateWithoutAdminIdInput>
    create: XOR<AdminPanelCreateWithoutAdminIdInput, AdminPanelUncheckedCreateWithoutAdminIdInput>
    where?: AdminPanelWhereInput
  }

  export type AdminPanelUpdateToOneWithWhereWithoutAdminIdInput = {
    where?: AdminPanelWhereInput
    data: XOR<AdminPanelUpdateWithoutAdminIdInput, AdminPanelUncheckedUpdateWithoutAdminIdInput>
  }

  export type AdminPanelUpdateWithoutAdminIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderUpdateManyWithoutAdminPanelNestedInput
    patient?: PatientUpdateManyWithoutAdminPanelNestedInput
    superAdminId?: SuperAdminUpdateManyWithoutAdminPanelNestedInput
  }

  export type AdminPanelUncheckedUpdateWithoutAdminIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutAdminPanelNestedInput
    patient?: PatientUncheckedUpdateManyWithoutAdminPanelNestedInput
    superAdminId?: SuperAdminUncheckedUpdateManyWithoutAdminPanelNestedInput
  }

  export type SuperAdminUpsertWithoutAdminInput = {
    update: XOR<SuperAdminUpdateWithoutAdminInput, SuperAdminUncheckedUpdateWithoutAdminInput>
    create: XOR<SuperAdminCreateWithoutAdminInput, SuperAdminUncheckedCreateWithoutAdminInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutAdminInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutAdminInput, SuperAdminUncheckedUpdateWithoutAdminInput>
  }

  export type SuperAdminUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    user?: UserUpdateOneRequiredWithoutSuperAdminNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutSuperAdminIdNestedInput
  }

  export type SuperAdminUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    adminPanelId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleCreateWithoutServiceProvidersInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slots?: SlotCreateNestedManyWithoutScheduleInput
    clinicInfo?: ClinicInfoCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutServiceProvidersInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slots?: SlotUncheckedCreateNestedManyWithoutScheduleInput
    clinicInfo?: ClinicInfoUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutServiceProvidersInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutServiceProvidersInput, ScheduleUncheckedCreateWithoutServiceProvidersInput>
  }

  export type ScheduleCreateManyServiceProvidersInputEnvelope = {
    data: ScheduleCreateManyServiceProvidersInput | ScheduleCreateManyServiceProvidersInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutServiceProviderInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationCreateNestedOneWithoutAppointmentInput
    slot: SlotCreateNestedOneWithoutAppointmentInput
    user: UserCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
    payment?: PaymentCreateNestedManyWithoutAppointmentInput
    tags?: TagCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput
    payment?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    tags?: TagUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentCreateOrConnectWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput>
  }

  export type AppointmentCreateManyServiceProviderInputEnvelope = {
    data: AppointmentCreateManyServiceProviderInput | AppointmentCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type EducationCreateWithoutServiceProviderInput = {
    id?: string
    university: string
    degree: string
    duration: string
  }

  export type EducationUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    university: string
    degree: string
    duration: string
  }

  export type EducationCreateOrConnectWithoutServiceProviderInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutServiceProviderInput, EducationUncheckedCreateWithoutServiceProviderInput>
  }

  export type EducationCreateManyServiceProviderInputEnvelope = {
    data: EducationCreateManyServiceProviderInput | EducationCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type WorkExperienceCreateWithoutServiceProviderInput = {
    id?: string
    clinic: string
    duration: string
  }

  export type WorkExperienceUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    clinic: string
    duration: string
  }

  export type WorkExperienceCreateOrConnectWithoutServiceProviderInput = {
    where: WorkExperienceWhereUniqueInput
    create: XOR<WorkExperienceCreateWithoutServiceProviderInput, WorkExperienceUncheckedCreateWithoutServiceProviderInput>
  }

  export type WorkExperienceCreateManyServiceProviderInputEnvelope = {
    data: WorkExperienceCreateManyServiceProviderInput | WorkExperienceCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type AwardCreateWithoutServiceProviderInput = {
    id?: string
    date: string
    title: string
    description: string
  }

  export type AwardUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    date: string
    title: string
    description: string
  }

  export type AwardCreateOrConnectWithoutServiceProviderInput = {
    where: AwardWhereUniqueInput
    create: XOR<AwardCreateWithoutServiceProviderInput, AwardUncheckedCreateWithoutServiceProviderInput>
  }

  export type AwardCreateManyServiceProviderInputEnvelope = {
    data: AwardCreateManyServiceProviderInput | AwardCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type LabResultCreateWithoutServiceProviderInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    patient: PatientCreateNestedOneWithoutLabResultsInput
  }

  export type LabResultUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    patientId: string
  }

  export type LabResultCreateOrConnectWithoutServiceProviderInput = {
    where: LabResultWhereUniqueInput
    create: XOR<LabResultCreateWithoutServiceProviderInput, LabResultUncheckedCreateWithoutServiceProviderInput>
  }

  export type LabResultCreateManyServiceProviderInputEnvelope = {
    data: LabResultCreateManyServiceProviderInput | LabResultCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type TherapyPlanCreateWithoutServiceProviderInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    patient: PatientCreateNestedOneWithoutTreatmentPlansInput
  }

  export type TherapyPlanUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    patientId: string
  }

  export type TherapyPlanCreateOrConnectWithoutServiceProviderInput = {
    where: TherapyPlanWhereUniqueInput
    create: XOR<TherapyPlanCreateWithoutServiceProviderInput, TherapyPlanUncheckedCreateWithoutServiceProviderInput>
  }

  export type TherapyPlanCreateManyServiceProviderInputEnvelope = {
    data: TherapyPlanCreateManyServiceProviderInput | TherapyPlanCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutServiceProviderInput = {
    id?: string
    serviceProviderType: $Enums.ProviderType
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    userId: string
    serviceProviderType: $Enums.ProviderType
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutServiceProviderInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput>
  }

  export type RatingCreateManyServiceProviderInputEnvelope = {
    data: RatingCreateManyServiceProviderInput | RatingCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordCreateWithoutServiceProviderInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    description?: string | null
    recordId?: string | null
    attachment?: string | null
    user: UserCreateNestedOneWithoutMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    userId: string
    description?: string | null
    recordId?: string | null
    attachment?: string | null
  }

  export type MedicalRecordCreateOrConnectWithoutServiceProviderInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutServiceProviderInput, MedicalRecordUncheckedCreateWithoutServiceProviderInput>
  }

  export type MedicalRecordCreateManyServiceProviderInputEnvelope = {
    data: MedicalRecordCreateManyServiceProviderInput | MedicalRecordCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type DoctorCreateWithoutServiceproviderInput = {
    id?: string
    user: UserCreateNestedOneWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    assistants?: DoctorsAssistantCreateNestedManyWithoutDoctorInput
    requests?: RequestCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutServiceproviderInput = {
    id?: string
    userId: string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    assistants?: DoctorsAssistantUncheckedCreateNestedManyWithoutDoctorInput
    requests?: RequestUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutServiceproviderInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutServiceproviderInput, DoctorUncheckedCreateWithoutServiceproviderInput>
  }

  export type DoctorCreateManyServiceproviderInputEnvelope = {
    data: DoctorCreateManyServiceproviderInput | DoctorCreateManyServiceproviderInput[]
    skipDuplicates?: boolean
  }

  export type ClinicInfoCreateWithoutServiceProvidersInput = {
    id?: string
    clinicName: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    address: AddressCreateNestedOneWithoutClinicInfoInput
    schedule?: ScheduleCreateNestedOneWithoutClinicInfoInput
  }

  export type ClinicInfoUncheckedCreateWithoutServiceProvidersInput = {
    id?: string
    clinicName: string
    addressId: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    scheduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicInfoCreateOrConnectWithoutServiceProvidersInput = {
    where: ClinicInfoWhereUniqueInput
    create: XOR<ClinicInfoCreateWithoutServiceProvidersInput, ClinicInfoUncheckedCreateWithoutServiceProvidersInput>
  }

  export type AdminPanelCreateWithoutServiceProviderInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    patient?: PatientCreateNestedManyWithoutAdminPanelInput
    superAdminId?: SuperAdminCreateNestedManyWithoutAdminPanelInput
    adminId?: AdminCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    userId: string
    permissions?: AdminPanelCreatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: boolean
    canManagePayments?: boolean
    canManageReports?: boolean
    patient?: PatientUncheckedCreateNestedManyWithoutAdminPanelInput
    superAdminId?: SuperAdminUncheckedCreateNestedManyWithoutAdminPanelInput
    adminId?: AdminUncheckedCreateNestedManyWithoutAdminPanelInput
  }

  export type AdminPanelCreateOrConnectWithoutServiceProviderInput = {
    where: AdminPanelWhereUniqueInput
    create: XOR<AdminPanelCreateWithoutServiceProviderInput, AdminPanelUncheckedCreateWithoutServiceProviderInput>
  }

  export type TagCreateWithoutServiceProvidersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTagsInput
    patients?: PatientCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutServiceProvidersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTagsInput
    patients?: PatientUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutServiceProvidersInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutServiceProvidersInput, TagUncheckedCreateWithoutServiceProvidersInput>
  }

  export type UserCreateWithoutServiceProviderInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceProviderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceProviderInput, UserUncheckedCreateWithoutServiceProviderInput>
  }

  export type ScheduleUpsertWithWhereUniqueWithoutServiceProvidersInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutServiceProvidersInput, ScheduleUncheckedUpdateWithoutServiceProvidersInput>
    create: XOR<ScheduleCreateWithoutServiceProvidersInput, ScheduleUncheckedCreateWithoutServiceProvidersInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutServiceProvidersInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutServiceProvidersInput, ScheduleUncheckedUpdateWithoutServiceProvidersInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutServiceProvidersInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutServiceProvidersInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    date?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    dayOfWeek?: EnumWeekDayNullableFilter<"Schedule"> | $Enums.WeekDay | null
    isRecurring?: BoolFilter<"Schedule"> | boolean
    recurrenceType?: EnumRecurrenceTypeNullableFilter<"Schedule"> | $Enums.RecurrenceType | null
    startTime?: DateTimeFilter<"Schedule"> | Date | string
    endTime?: DateTimeFilter<"Schedule"> | Date | string
    slotDuration?: IntFilter<"Schedule"> | number
    location?: StringFilter<"Schedule"> | string
    isAvailable?: BoolFilter<"Schedule"> | boolean
    service?: EnumServiceFilter<"Schedule"> | $Enums.Service
    status?: EnumStatusFilter<"Schedule"> | $Enums.Status
    serviceProviderId?: StringFilter<"Schedule"> | string
    userId?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutServiceProviderInput, AppointmentUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutServiceProviderInput, AppointmentUncheckedUpdateWithoutServiceProviderInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutServiceProviderInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type EducationUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: EducationWhereUniqueInput
    update: XOR<EducationUpdateWithoutServiceProviderInput, EducationUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<EducationCreateWithoutServiceProviderInput, EducationUncheckedCreateWithoutServiceProviderInput>
  }

  export type EducationUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: EducationWhereUniqueInput
    data: XOR<EducationUpdateWithoutServiceProviderInput, EducationUncheckedUpdateWithoutServiceProviderInput>
  }

  export type EducationUpdateManyWithWhereWithoutServiceProviderInput = {
    where: EducationScalarWhereInput
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type EducationScalarWhereInput = {
    AND?: EducationScalarWhereInput | EducationScalarWhereInput[]
    OR?: EducationScalarWhereInput[]
    NOT?: EducationScalarWhereInput | EducationScalarWhereInput[]
    id?: StringFilter<"Education"> | string
    university?: StringFilter<"Education"> | string
    degree?: StringFilter<"Education"> | string
    duration?: StringFilter<"Education"> | string
    serviceProviderId?: StringFilter<"Education"> | string
  }

  export type WorkExperienceUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: WorkExperienceWhereUniqueInput
    update: XOR<WorkExperienceUpdateWithoutServiceProviderInput, WorkExperienceUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<WorkExperienceCreateWithoutServiceProviderInput, WorkExperienceUncheckedCreateWithoutServiceProviderInput>
  }

  export type WorkExperienceUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: WorkExperienceWhereUniqueInput
    data: XOR<WorkExperienceUpdateWithoutServiceProviderInput, WorkExperienceUncheckedUpdateWithoutServiceProviderInput>
  }

  export type WorkExperienceUpdateManyWithWhereWithoutServiceProviderInput = {
    where: WorkExperienceScalarWhereInput
    data: XOR<WorkExperienceUpdateManyMutationInput, WorkExperienceUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type WorkExperienceScalarWhereInput = {
    AND?: WorkExperienceScalarWhereInput | WorkExperienceScalarWhereInput[]
    OR?: WorkExperienceScalarWhereInput[]
    NOT?: WorkExperienceScalarWhereInput | WorkExperienceScalarWhereInput[]
    id?: StringFilter<"WorkExperience"> | string
    clinic?: StringFilter<"WorkExperience"> | string
    duration?: StringFilter<"WorkExperience"> | string
    serviceProviderId?: StringFilter<"WorkExperience"> | string
  }

  export type AwardUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: AwardWhereUniqueInput
    update: XOR<AwardUpdateWithoutServiceProviderInput, AwardUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<AwardCreateWithoutServiceProviderInput, AwardUncheckedCreateWithoutServiceProviderInput>
  }

  export type AwardUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: AwardWhereUniqueInput
    data: XOR<AwardUpdateWithoutServiceProviderInput, AwardUncheckedUpdateWithoutServiceProviderInput>
  }

  export type AwardUpdateManyWithWhereWithoutServiceProviderInput = {
    where: AwardScalarWhereInput
    data: XOR<AwardUpdateManyMutationInput, AwardUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type AwardScalarWhereInput = {
    AND?: AwardScalarWhereInput | AwardScalarWhereInput[]
    OR?: AwardScalarWhereInput[]
    NOT?: AwardScalarWhereInput | AwardScalarWhereInput[]
    id?: StringFilter<"Award"> | string
    date?: StringFilter<"Award"> | string
    title?: StringFilter<"Award"> | string
    description?: StringFilter<"Award"> | string
    serviceProviderId?: StringFilter<"Award"> | string
  }

  export type LabResultUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: LabResultWhereUniqueInput
    update: XOR<LabResultUpdateWithoutServiceProviderInput, LabResultUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<LabResultCreateWithoutServiceProviderInput, LabResultUncheckedCreateWithoutServiceProviderInput>
  }

  export type LabResultUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: LabResultWhereUniqueInput
    data: XOR<LabResultUpdateWithoutServiceProviderInput, LabResultUncheckedUpdateWithoutServiceProviderInput>
  }

  export type LabResultUpdateManyWithWhereWithoutServiceProviderInput = {
    where: LabResultScalarWhereInput
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type TherapyPlanUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: TherapyPlanWhereUniqueInput
    update: XOR<TherapyPlanUpdateWithoutServiceProviderInput, TherapyPlanUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<TherapyPlanCreateWithoutServiceProviderInput, TherapyPlanUncheckedCreateWithoutServiceProviderInput>
  }

  export type TherapyPlanUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: TherapyPlanWhereUniqueInput
    data: XOR<TherapyPlanUpdateWithoutServiceProviderInput, TherapyPlanUncheckedUpdateWithoutServiceProviderInput>
  }

  export type TherapyPlanUpdateManyWithWhereWithoutServiceProviderInput = {
    where: TherapyPlanScalarWhereInput
    data: XOR<TherapyPlanUpdateManyMutationInput, TherapyPlanUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type RatingUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutServiceProviderInput, RatingUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutServiceProviderInput, RatingUncheckedUpdateWithoutServiceProviderInput>
  }

  export type RatingUpdateManyWithWhereWithoutServiceProviderInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutServiceProviderInput, MedicalRecordUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<MedicalRecordCreateWithoutServiceProviderInput, MedicalRecordUncheckedCreateWithoutServiceProviderInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutServiceProviderInput, MedicalRecordUncheckedUpdateWithoutServiceProviderInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutServiceProviderInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type DoctorUpsertWithWhereUniqueWithoutServiceproviderInput = {
    where: DoctorWhereUniqueInput
    update: XOR<DoctorUpdateWithoutServiceproviderInput, DoctorUncheckedUpdateWithoutServiceproviderInput>
    create: XOR<DoctorCreateWithoutServiceproviderInput, DoctorUncheckedCreateWithoutServiceproviderInput>
  }

  export type DoctorUpdateWithWhereUniqueWithoutServiceproviderInput = {
    where: DoctorWhereUniqueInput
    data: XOR<DoctorUpdateWithoutServiceproviderInput, DoctorUncheckedUpdateWithoutServiceproviderInput>
  }

  export type DoctorUpdateManyWithWhereWithoutServiceproviderInput = {
    where: DoctorScalarWhereInput
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyWithoutServiceproviderInput>
  }

  export type DoctorScalarWhereInput = {
    AND?: DoctorScalarWhereInput | DoctorScalarWhereInput[]
    OR?: DoctorScalarWhereInput[]
    NOT?: DoctorScalarWhereInput | DoctorScalarWhereInput[]
    id?: StringFilter<"Doctor"> | string
    userId?: StringFilter<"Doctor"> | string
    serviceproviderId?: StringFilter<"Doctor"> | string
  }

  export type ClinicInfoUpsertWithoutServiceProvidersInput = {
    update: XOR<ClinicInfoUpdateWithoutServiceProvidersInput, ClinicInfoUncheckedUpdateWithoutServiceProvidersInput>
    create: XOR<ClinicInfoCreateWithoutServiceProvidersInput, ClinicInfoUncheckedCreateWithoutServiceProvidersInput>
    where?: ClinicInfoWhereInput
  }

  export type ClinicInfoUpdateToOneWithWhereWithoutServiceProvidersInput = {
    where?: ClinicInfoWhereInput
    data: XOR<ClinicInfoUpdateWithoutServiceProvidersInput, ClinicInfoUncheckedUpdateWithoutServiceProvidersInput>
  }

  export type ClinicInfoUpdateWithoutServiceProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutClinicInfoNestedInput
    schedule?: ScheduleUpdateOneWithoutClinicInfoNestedInput
  }

  export type ClinicInfoUncheckedUpdateWithoutServiceProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPanelUpsertWithoutServiceProviderInput = {
    update: XOR<AdminPanelUpdateWithoutServiceProviderInput, AdminPanelUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<AdminPanelCreateWithoutServiceProviderInput, AdminPanelUncheckedCreateWithoutServiceProviderInput>
    where?: AdminPanelWhereInput
  }

  export type AdminPanelUpdateToOneWithWhereWithoutServiceProviderInput = {
    where?: AdminPanelWhereInput
    data: XOR<AdminPanelUpdateWithoutServiceProviderInput, AdminPanelUncheckedUpdateWithoutServiceProviderInput>
  }

  export type AdminPanelUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateManyWithoutAdminPanelNestedInput
    superAdminId?: SuperAdminUpdateManyWithoutAdminPanelNestedInput
    adminId?: AdminUpdateManyWithoutAdminPanelNestedInput
  }

  export type AdminPanelUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminPanelUpdatepermissionsInput | $Enums.ActionType[]
    canManageUsers?: BoolFieldUpdateOperationsInput | boolean
    canManagePayments?: BoolFieldUpdateOperationsInput | boolean
    canManageReports?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUncheckedUpdateManyWithoutAdminPanelNestedInput
    superAdminId?: SuperAdminUncheckedUpdateManyWithoutAdminPanelNestedInput
    adminId?: AdminUncheckedUpdateManyWithoutAdminPanelNestedInput
  }

  export type TagUpsertWithWhereUniqueWithoutServiceProvidersInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutServiceProvidersInput, TagUncheckedUpdateWithoutServiceProvidersInput>
    create: XOR<TagCreateWithoutServiceProvidersInput, TagUncheckedCreateWithoutServiceProvidersInput>
  }

  export type TagUpdateWithWhereUniqueWithoutServiceProvidersInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutServiceProvidersInput, TagUncheckedUpdateWithoutServiceProvidersInput>
  }

  export type TagUpdateManyWithWhereWithoutServiceProvidersInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutServiceProvidersInput>
  }

  export type UserUpsertWithoutServiceProviderInput = {
    update: XOR<UserUpdateWithoutServiceProviderInput, UserUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<UserCreateWithoutServiceProviderInput, UserUncheckedCreateWithoutServiceProviderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceProviderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceProviderInput, UserUncheckedUpdateWithoutServiceProviderInput>
  }

  export type UserUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDoctorInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoctorInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoctorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionCreateWithoutDoctorInput = {
    id?: string
    notes?: string | null
    dateIssued: Date | string
    medications?: MedicationCreateNestedManyWithoutPrescriptionInput
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    notes?: string | null
    dateIssued: Date | string
    medications?: MedicationUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionCreateManyDoctorInputEnvelope = {
    data: PrescriptionCreateManyDoctorInput | PrescriptionCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DoctorsAssistantCreateWithoutDoctorInput = {
    id?: string
    user: UserCreateNestedOneWithoutDoctorsAssistantInput
    requestPermissions?: RequestPermissionCreateNestedManyWithoutDoctorsAssistantInput
  }

  export type DoctorsAssistantUncheckedCreateWithoutDoctorInput = {
    id?: string
    userId: string
    requestPermissions?: RequestPermissionUncheckedCreateNestedManyWithoutDoctorsAssistantInput
  }

  export type DoctorsAssistantCreateOrConnectWithoutDoctorInput = {
    where: DoctorsAssistantWhereUniqueInput
    create: XOR<DoctorsAssistantCreateWithoutDoctorInput, DoctorsAssistantUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorsAssistantCreateManyDoctorInputEnvelope = {
    data: DoctorsAssistantCreateManyDoctorInput | DoctorsAssistantCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type RequestCreateWithoutDoctorInput = {
    id?: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    requestPermissions?: RequestPermissionCreateNestedManyWithoutRequestsInput
  }

  export type RequestUncheckedCreateWithoutDoctorInput = {
    id?: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    requestPermissions?: RequestPermissionUncheckedCreateNestedManyWithoutRequestsInput
  }

  export type RequestCreateOrConnectWithoutDoctorInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutDoctorInput, RequestUncheckedCreateWithoutDoctorInput>
  }

  export type RequestCreateManyDoctorInputEnvelope = {
    data: RequestCreateManyDoctorInput | RequestCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type ServiceProviderCreateWithoutDoctorInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutDoctorInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutDoctorInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutDoctorInput, ServiceProviderUncheckedCreateWithoutDoctorInput>
  }

  export type UserUpsertWithoutDoctorInput = {
    update: XOR<UserUpdateWithoutDoctorInput, UserUncheckedUpdateWithoutDoctorInput>
    create: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorInput, UserUncheckedUpdateWithoutDoctorInput>
  }

  export type UserUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutDoctorInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DoctorsAssistantUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorsAssistantWhereUniqueInput
    update: XOR<DoctorsAssistantUpdateWithoutDoctorInput, DoctorsAssistantUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorsAssistantCreateWithoutDoctorInput, DoctorsAssistantUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorsAssistantUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorsAssistantWhereUniqueInput
    data: XOR<DoctorsAssistantUpdateWithoutDoctorInput, DoctorsAssistantUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorsAssistantUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorsAssistantScalarWhereInput
    data: XOR<DoctorsAssistantUpdateManyMutationInput, DoctorsAssistantUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DoctorsAssistantScalarWhereInput = {
    AND?: DoctorsAssistantScalarWhereInput | DoctorsAssistantScalarWhereInput[]
    OR?: DoctorsAssistantScalarWhereInput[]
    NOT?: DoctorsAssistantScalarWhereInput | DoctorsAssistantScalarWhereInput[]
    id?: StringFilter<"DoctorsAssistant"> | string
    userId?: StringFilter<"DoctorsAssistant"> | string
    assignedDoctorId?: StringFilter<"DoctorsAssistant"> | string
  }

  export type RequestUpsertWithWhereUniqueWithoutDoctorInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutDoctorInput, RequestUncheckedUpdateWithoutDoctorInput>
    create: XOR<RequestCreateWithoutDoctorInput, RequestUncheckedCreateWithoutDoctorInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutDoctorInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutDoctorInput, RequestUncheckedUpdateWithoutDoctorInput>
  }

  export type RequestUpdateManyWithWhereWithoutDoctorInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutDoctorInput>
  }

  export type RequestScalarWhereInput = {
    AND?: RequestScalarWhereInput | RequestScalarWhereInput[]
    OR?: RequestScalarWhereInput[]
    NOT?: RequestScalarWhereInput | RequestScalarWhereInput[]
    id?: StringFilter<"Request"> | string
    status?: EnumStatusFilter<"Request"> | $Enums.Status
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    doctorId?: StringNullableFilter<"Request"> | string | null
  }

  export type ServiceProviderUpsertWithoutDoctorInput = {
    update: XOR<ServiceProviderUpdateWithoutDoctorInput, ServiceProviderUncheckedUpdateWithoutDoctorInput>
    create: XOR<ServiceProviderCreateWithoutDoctorInput, ServiceProviderUncheckedCreateWithoutDoctorInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutDoctorInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutDoctorInput, ServiceProviderUncheckedUpdateWithoutDoctorInput>
  }

  export type ServiceProviderUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type UserCreateWithoutDoctorsAssistantInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoctorsAssistantInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoctorsAssistantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorsAssistantInput, UserUncheckedCreateWithoutDoctorsAssistantInput>
  }

  export type DoctorCreateWithoutAssistantsInput = {
    id?: string
    user: UserCreateNestedOneWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    requests?: RequestCreateNestedManyWithoutDoctorInput
    serviceprovider: ServiceProviderCreateNestedOneWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutAssistantsInput = {
    id?: string
    userId: string
    serviceproviderId: string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    requests?: RequestUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutAssistantsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAssistantsInput, DoctorUncheckedCreateWithoutAssistantsInput>
  }

  export type RequestPermissionCreateWithoutDoctorsAssistantInput = {
    id?: string
    name: string
    description?: string | null
    accessType: $Enums.PermissionType
    requests?: RequestCreateNestedManyWithoutRequestPermissionsInput
  }

  export type RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput = {
    id?: string
    name: string
    description?: string | null
    accessType: $Enums.PermissionType
    requests?: RequestUncheckedCreateNestedManyWithoutRequestPermissionsInput
  }

  export type RequestPermissionCreateOrConnectWithoutDoctorsAssistantInput = {
    where: RequestPermissionWhereUniqueInput
    create: XOR<RequestPermissionCreateWithoutDoctorsAssistantInput, RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput>
  }

  export type RequestPermissionCreateManyDoctorsAssistantInputEnvelope = {
    data: RequestPermissionCreateManyDoctorsAssistantInput | RequestPermissionCreateManyDoctorsAssistantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDoctorsAssistantInput = {
    update: XOR<UserUpdateWithoutDoctorsAssistantInput, UserUncheckedUpdateWithoutDoctorsAssistantInput>
    create: XOR<UserCreateWithoutDoctorsAssistantInput, UserUncheckedCreateWithoutDoctorsAssistantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorsAssistantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorsAssistantInput, UserUncheckedUpdateWithoutDoctorsAssistantInput>
  }

  export type UserUpdateWithoutDoctorsAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorsAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DoctorUpsertWithoutAssistantsInput = {
    update: XOR<DoctorUpdateWithoutAssistantsInput, DoctorUncheckedUpdateWithoutAssistantsInput>
    create: XOR<DoctorCreateWithoutAssistantsInput, DoctorUncheckedCreateWithoutAssistantsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutAssistantsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutAssistantsInput, DoctorUncheckedUpdateWithoutAssistantsInput>
  }

  export type DoctorUpdateWithoutAssistantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    requests?: RequestUpdateManyWithoutDoctorNestedInput
    serviceprovider?: ServiceProviderUpdateOneRequiredWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAssistantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceproviderId?: StringFieldUpdateOperationsInput | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    requests?: RequestUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type RequestPermissionUpsertWithWhereUniqueWithoutDoctorsAssistantInput = {
    where: RequestPermissionWhereUniqueInput
    update: XOR<RequestPermissionUpdateWithoutDoctorsAssistantInput, RequestPermissionUncheckedUpdateWithoutDoctorsAssistantInput>
    create: XOR<RequestPermissionCreateWithoutDoctorsAssistantInput, RequestPermissionUncheckedCreateWithoutDoctorsAssistantInput>
  }

  export type RequestPermissionUpdateWithWhereUniqueWithoutDoctorsAssistantInput = {
    where: RequestPermissionWhereUniqueInput
    data: XOR<RequestPermissionUpdateWithoutDoctorsAssistantInput, RequestPermissionUncheckedUpdateWithoutDoctorsAssistantInput>
  }

  export type RequestPermissionUpdateManyWithWhereWithoutDoctorsAssistantInput = {
    where: RequestPermissionScalarWhereInput
    data: XOR<RequestPermissionUpdateManyMutationInput, RequestPermissionUncheckedUpdateManyWithoutDoctorsAssistantInput>
  }

  export type RequestPermissionScalarWhereInput = {
    AND?: RequestPermissionScalarWhereInput | RequestPermissionScalarWhereInput[]
    OR?: RequestPermissionScalarWhereInput[]
    NOT?: RequestPermissionScalarWhereInput | RequestPermissionScalarWhereInput[]
    id?: StringFilter<"RequestPermission"> | string
    name?: StringFilter<"RequestPermission"> | string
    description?: StringNullableFilter<"RequestPermission"> | string | null
    accessType?: EnumPermissionTypeFilter<"RequestPermission"> | $Enums.PermissionType
    doctorsAssistantId?: StringNullableFilter<"RequestPermission"> | string | null
  }

  export type UserCreateWithoutLabInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLabInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLabInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLabInput, UserUncheckedCreateWithoutLabInput>
  }

  export type UserUpsertWithoutLabInput = {
    update: XOR<UserUpdateWithoutLabInput, UserUncheckedUpdateWithoutLabInput>
    create: XOR<UserCreateWithoutLabInput, UserUncheckedCreateWithoutLabInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLabInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLabInput, UserUncheckedUpdateWithoutLabInput>
  }

  export type UserUpdateWithoutLabInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLabInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutHospitalInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHospitalInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHospitalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
  }

  export type UserUpsertWithoutHospitalInput = {
    update: XOR<UserUpdateWithoutHospitalInput, UserUncheckedUpdateWithoutHospitalInput>
    create: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHospitalInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHospitalInput, UserUncheckedUpdateWithoutHospitalInput>
  }

  export type UserUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNursingInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNursingInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNursingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNursingInput, UserUncheckedCreateWithoutNursingInput>
  }

  export type UserUpsertWithoutNursingInput = {
    update: XOR<UserUpdateWithoutNursingInput, UserUncheckedUpdateWithoutNursingInput>
    create: XOR<UserCreateWithoutNursingInput, UserUncheckedCreateWithoutNursingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNursingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNursingInput, UserUncheckedUpdateWithoutNursingInput>
  }

  export type UserUpdateWithoutNursingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNursingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PatientCreateWithoutAllergiesInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    user: UserCreateNestedOneWithoutPatientInput
    treatmentPlans?: TherapyPlanCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labResults?: LabResultCreateNestedManyWithoutPatientInput
    adminPanel: AdminPanelCreateNestedOneWithoutPatientInput
    tags?: TagCreateNestedManyWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutAllergiesInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    treatmentPlans?: TherapyPlanUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutPatientInput
    tags?: TagUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type PatientCreateOrConnectWithoutAllergiesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
  }

  export type PatientUpsertWithoutAllergiesInput = {
    update: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAllergiesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PatientUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUpdateManyWithoutPatientNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutPatientNestedInput
    tags?: TagUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
    treatmentPlans?: TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutPatientNestedInput
    tags?: TagUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type PrescriptionCreateWithoutMedicationsInput = {
    id?: string
    notes?: string | null
    dateIssued: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: DoctorCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateWithoutMedicationsInput = {
    id?: string
    patientId: string
    doctorId: string
    notes?: string | null
    dateIssued: Date | string
  }

  export type PrescriptionCreateOrConnectWithoutMedicationsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutMedicationsInput, PrescriptionUncheckedCreateWithoutMedicationsInput>
  }

  export type PrescriptionUpsertWithoutMedicationsInput = {
    update: XOR<PrescriptionUpdateWithoutMedicationsInput, PrescriptionUncheckedUpdateWithoutMedicationsInput>
    create: XOR<PrescriptionCreateWithoutMedicationsInput, PrescriptionUncheckedCreateWithoutMedicationsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutMedicationsInput, PrescriptionUncheckedUpdateWithoutMedicationsInput>
  }

  export type PrescriptionUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateWithoutLabResultsInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    user: UserCreateNestedOneWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    adminPanel: AdminPanelCreateNestedOneWithoutPatientInput
    tags?: TagCreateNestedManyWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutLabResultsInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tags?: TagUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type PatientCreateOrConnectWithoutLabResultsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutLabResultsInput, PatientUncheckedCreateWithoutLabResultsInput>
  }

  export type ServiceProviderCreateWithoutLabResultsInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutLabResultsInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutLabResultsInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutLabResultsInput, ServiceProviderUncheckedCreateWithoutLabResultsInput>
  }

  export type PatientUpsertWithoutLabResultsInput = {
    update: XOR<PatientUpdateWithoutLabResultsInput, PatientUncheckedUpdateWithoutLabResultsInput>
    create: XOR<PatientCreateWithoutLabResultsInput, PatientUncheckedCreateWithoutLabResultsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutLabResultsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutLabResultsInput, PatientUncheckedUpdateWithoutLabResultsInput>
  }

  export type PatientUpdateWithoutLabResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutPatientNestedInput
    tags?: TagUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutLabResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tags?: TagUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type ServiceProviderUpsertWithoutLabResultsInput = {
    update: XOR<ServiceProviderUpdateWithoutLabResultsInput, ServiceProviderUncheckedUpdateWithoutLabResultsInput>
    create: XOR<ServiceProviderCreateWithoutLabResultsInput, ServiceProviderUncheckedCreateWithoutLabResultsInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutLabResultsInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutLabResultsInput, ServiceProviderUncheckedUpdateWithoutLabResultsInput>
  }

  export type ServiceProviderUpdateWithoutLabResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutLabResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type UserCreateWithoutMedicalRecordsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMedicalRecordsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMedicalRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMedicalRecordsInput, UserUncheckedCreateWithoutMedicalRecordsInput>
  }

  export type ServiceProviderCreateWithoutMedicalRecordsInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutMedicalRecordsInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutMedicalRecordsInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutMedicalRecordsInput, ServiceProviderUncheckedCreateWithoutMedicalRecordsInput>
  }

  export type UserUpsertWithoutMedicalRecordsInput = {
    update: XOR<UserUpdateWithoutMedicalRecordsInput, UserUncheckedUpdateWithoutMedicalRecordsInput>
    create: XOR<UserCreateWithoutMedicalRecordsInput, UserUncheckedCreateWithoutMedicalRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMedicalRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMedicalRecordsInput, UserUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type UserUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceProviderUpsertWithoutMedicalRecordsInput = {
    update: XOR<ServiceProviderUpdateWithoutMedicalRecordsInput, ServiceProviderUncheckedUpdateWithoutMedicalRecordsInput>
    create: XOR<ServiceProviderCreateWithoutMedicalRecordsInput, ServiceProviderUncheckedCreateWithoutMedicalRecordsInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutMedicalRecordsInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutMedicalRecordsInput, ServiceProviderUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type ServiceProviderUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type MedicationCreateWithoutPrescriptionInput = {
    id?: string
    name: string
    dosage: string
    frequency: string
    duration: string
    status: string
  }

  export type MedicationUncheckedCreateWithoutPrescriptionInput = {
    id?: string
    name: string
    dosage: string
    frequency: string
    duration: string
    status: string
  }

  export type MedicationCreateOrConnectWithoutPrescriptionInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutPrescriptionInput, MedicationUncheckedCreateWithoutPrescriptionInput>
  }

  export type MedicationCreateManyPrescriptionInputEnvelope = {
    data: MedicationCreateManyPrescriptionInput | MedicationCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutPrescriptionsInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    user: UserCreateNestedOneWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
    labResults?: LabResultCreateNestedManyWithoutPatientInput
    adminPanel: AdminPanelCreateNestedOneWithoutPatientInput
    tags?: TagCreateNestedManyWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutPatientInput
    tags?: TagUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
  }

  export type DoctorCreateWithoutPrescriptionsInput = {
    id?: string
    user: UserCreateNestedOneWithoutDoctorInput
    assistants?: DoctorsAssistantCreateNestedManyWithoutDoctorInput
    requests?: RequestCreateNestedManyWithoutDoctorInput
    serviceprovider: ServiceProviderCreateNestedOneWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    userId: string
    serviceproviderId: string
    assistants?: DoctorsAssistantUncheckedCreateNestedManyWithoutDoctorInput
    requests?: RequestUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutPrescriptionsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
  }

  export type MedicationUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: MedicationWhereUniqueInput
    update: XOR<MedicationUpdateWithoutPrescriptionInput, MedicationUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<MedicationCreateWithoutPrescriptionInput, MedicationUncheckedCreateWithoutPrescriptionInput>
  }

  export type MedicationUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: MedicationWhereUniqueInput
    data: XOR<MedicationUpdateWithoutPrescriptionInput, MedicationUncheckedUpdateWithoutPrescriptionInput>
  }

  export type MedicationUpdateManyWithWhereWithoutPrescriptionInput = {
    where: MedicationScalarWhereInput
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type MedicationScalarWhereInput = {
    AND?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    OR?: MedicationScalarWhereInput[]
    NOT?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    id?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    dosage?: StringFilter<"Medication"> | string
    frequency?: StringFilter<"Medication"> | string
    duration?: StringFilter<"Medication"> | string
    status?: StringFilter<"Medication"> | string
    prescriptionId?: StringNullableFilter<"Medication"> | string | null
  }

  export type PatientUpsertWithoutPrescriptionsInput = {
    update: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUpdateManyWithoutPatientNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutPatientNestedInput
    tags?: TagUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutPatientNestedInput
    tags?: TagUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type DoctorUpsertWithoutPrescriptionsInput = {
    update: XOR<DoctorUpdateWithoutPrescriptionsInput, DoctorUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutPrescriptionsInput, DoctorUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type DoctorUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUpdateManyWithoutDoctorNestedInput
    requests?: RequestUpdateManyWithoutDoctorNestedInput
    serviceprovider?: ServiceProviderUpdateOneRequiredWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceproviderId?: StringFieldUpdateOperationsInput | string
    assistants?: DoctorsAssistantUncheckedUpdateManyWithoutDoctorNestedInput
    requests?: RequestUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientCreateWithoutTreatmentPlansInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    user: UserCreateNestedOneWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labResults?: LabResultCreateNestedManyWithoutPatientInput
    adminPanel: AdminPanelCreateNestedOneWithoutPatientInput
    tags?: TagCreateNestedManyWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutTreatmentPlansInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutPatientInput
    tags?: TagUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type PatientCreateOrConnectWithoutTreatmentPlansInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTreatmentPlansInput, PatientUncheckedCreateWithoutTreatmentPlansInput>
  }

  export type ServiceProviderCreateWithoutTherapyPlansInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutTherapyPlansInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutTherapyPlansInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutTherapyPlansInput, ServiceProviderUncheckedCreateWithoutTherapyPlansInput>
  }

  export type PatientUpsertWithoutTreatmentPlansInput = {
    update: XOR<PatientUpdateWithoutTreatmentPlansInput, PatientUncheckedUpdateWithoutTreatmentPlansInput>
    create: XOR<PatientCreateWithoutTreatmentPlansInput, PatientUncheckedCreateWithoutTreatmentPlansInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutTreatmentPlansInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutTreatmentPlansInput, PatientUncheckedUpdateWithoutTreatmentPlansInput>
  }

  export type PatientUpdateWithoutTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUpdateManyWithoutPatientNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutPatientNestedInput
    tags?: TagUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutPatientNestedInput
    tags?: TagUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type ServiceProviderUpsertWithoutTherapyPlansInput = {
    update: XOR<ServiceProviderUpdateWithoutTherapyPlansInput, ServiceProviderUncheckedUpdateWithoutTherapyPlansInput>
    create: XOR<ServiceProviderCreateWithoutTherapyPlansInput, ServiceProviderUncheckedCreateWithoutTherapyPlansInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutTherapyPlansInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutTherapyPlansInput, ServiceProviderUncheckedUpdateWithoutTherapyPlansInput>
  }

  export type ServiceProviderUpdateWithoutTherapyPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutTherapyPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type AppointmentCreateWithoutPaymentInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationCreateNestedOneWithoutAppointmentInput
    slot: SlotCreateNestedOneWithoutAppointmentInput
    user: UserCreateNestedOneWithoutAppointmentsInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutAppointmentInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
    tags?: TagCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutPaymentInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput
    tags?: TagUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentCreateOrConnectWithoutPaymentInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPaymentInput, AppointmentUncheckedCreateWithoutPaymentInput>
  }

  export type TransactionCreateWithoutPaymentInput = {
    id?: string
    gatewayTransactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    refundDetails?: string | null
  }

  export type TransactionUncheckedCreateWithoutPaymentInput = {
    id?: string
    gatewayTransactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    refundDetails?: string | null
  }

  export type TransactionCreateOrConnectWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
  }

  export type TransactionCreateManyPaymentInputEnvelope = {
    data: TransactionCreateManyPaymentInput | TransactionCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppointmentUpsertWithoutPaymentInput = {
    update: XOR<AppointmentUpdateWithoutPaymentInput, AppointmentUncheckedUpdateWithoutPaymentInput>
    create: XOR<AppointmentCreateWithoutPaymentInput, AppointmentUncheckedCreateWithoutPaymentInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutPaymentInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutPaymentInput, AppointmentUncheckedUpdateWithoutPaymentInput>
  }

  export type AppointmentUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUpdateOneWithoutAppointmentNestedInput
    slot?: SlotUpdateOneRequiredWithoutAppointmentNestedInput
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
    tags?: TagUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput
    tags?: TagUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPaymentInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPaymentInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    gatewayTransactionId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: EnumStatusFilter<"Transaction"> | $Enums.Status
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    refundDetails?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringFilter<"Transaction"> | string
  }

  export type PaymentCreateWithoutTransactionInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    appointment: AppointmentCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutTransactionInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    userId: string
    appointmentId: string
  }

  export type PaymentCreateOrConnectWithoutTransactionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentUpsertWithoutTransactionInput = {
    update: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutTransactionInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    appointment?: AppointmentUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceProviderCreateWithoutRatingInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutRatingInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutRatingInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutRatingInput, ServiceProviderUncheckedCreateWithoutRatingInput>
  }

  export type UserCreateWithoutRatingsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRatingsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
  }

  export type ServiceProviderUpsertWithoutRatingInput = {
    update: XOR<ServiceProviderUpdateWithoutRatingInput, ServiceProviderUncheckedUpdateWithoutRatingInput>
    create: XOR<ServiceProviderCreateWithoutRatingInput, ServiceProviderUncheckedCreateWithoutRatingInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutRatingInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutRatingInput, ServiceProviderUncheckedUpdateWithoutRatingInput>
  }

  export type ServiceProviderUpdateWithoutRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type UserUpsertWithoutRatingsInput = {
    update: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RequestCreateWithoutRequestPermissionsInput = {
    id?: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: DoctorCreateNestedOneWithoutRequestsInput
  }

  export type RequestUncheckedCreateWithoutRequestPermissionsInput = {
    id?: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
  }

  export type RequestCreateOrConnectWithoutRequestPermissionsInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutRequestPermissionsInput, RequestUncheckedCreateWithoutRequestPermissionsInput>
  }

  export type DoctorsAssistantCreateWithoutRequestPermissionsInput = {
    id?: string
    user: UserCreateNestedOneWithoutDoctorsAssistantInput
    doctor: DoctorCreateNestedOneWithoutAssistantsInput
  }

  export type DoctorsAssistantUncheckedCreateWithoutRequestPermissionsInput = {
    id?: string
    userId: string
    assignedDoctorId: string
  }

  export type DoctorsAssistantCreateOrConnectWithoutRequestPermissionsInput = {
    where: DoctorsAssistantWhereUniqueInput
    create: XOR<DoctorsAssistantCreateWithoutRequestPermissionsInput, DoctorsAssistantUncheckedCreateWithoutRequestPermissionsInput>
  }

  export type RequestUpsertWithWhereUniqueWithoutRequestPermissionsInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutRequestPermissionsInput, RequestUncheckedUpdateWithoutRequestPermissionsInput>
    create: XOR<RequestCreateWithoutRequestPermissionsInput, RequestUncheckedCreateWithoutRequestPermissionsInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutRequestPermissionsInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutRequestPermissionsInput, RequestUncheckedUpdateWithoutRequestPermissionsInput>
  }

  export type RequestUpdateManyWithWhereWithoutRequestPermissionsInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutRequestPermissionsInput>
  }

  export type DoctorsAssistantUpsertWithoutRequestPermissionsInput = {
    update: XOR<DoctorsAssistantUpdateWithoutRequestPermissionsInput, DoctorsAssistantUncheckedUpdateWithoutRequestPermissionsInput>
    create: XOR<DoctorsAssistantCreateWithoutRequestPermissionsInput, DoctorsAssistantUncheckedCreateWithoutRequestPermissionsInput>
    where?: DoctorsAssistantWhereInput
  }

  export type DoctorsAssistantUpdateToOneWithWhereWithoutRequestPermissionsInput = {
    where?: DoctorsAssistantWhereInput
    data: XOR<DoctorsAssistantUpdateWithoutRequestPermissionsInput, DoctorsAssistantUncheckedUpdateWithoutRequestPermissionsInput>
  }

  export type DoctorsAssistantUpdateWithoutRequestPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDoctorsAssistantNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAssistantsNestedInput
  }

  export type DoctorsAssistantUncheckedUpdateWithoutRequestPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
  }

  export type RequestPermissionCreateWithoutRequestsInput = {
    id?: string
    name: string
    description?: string | null
    accessType: $Enums.PermissionType
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutRequestPermissionsInput
  }

  export type RequestPermissionUncheckedCreateWithoutRequestsInput = {
    id?: string
    name: string
    description?: string | null
    accessType: $Enums.PermissionType
    doctorsAssistantId?: string | null
  }

  export type RequestPermissionCreateOrConnectWithoutRequestsInput = {
    where: RequestPermissionWhereUniqueInput
    create: XOR<RequestPermissionCreateWithoutRequestsInput, RequestPermissionUncheckedCreateWithoutRequestsInput>
  }

  export type DoctorCreateWithoutRequestsInput = {
    id?: string
    user: UserCreateNestedOneWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    assistants?: DoctorsAssistantCreateNestedManyWithoutDoctorInput
    serviceprovider: ServiceProviderCreateNestedOneWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutRequestsInput = {
    id?: string
    userId: string
    serviceproviderId: string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    assistants?: DoctorsAssistantUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutRequestsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutRequestsInput, DoctorUncheckedCreateWithoutRequestsInput>
  }

  export type RequestPermissionUpsertWithWhereUniqueWithoutRequestsInput = {
    where: RequestPermissionWhereUniqueInput
    update: XOR<RequestPermissionUpdateWithoutRequestsInput, RequestPermissionUncheckedUpdateWithoutRequestsInput>
    create: XOR<RequestPermissionCreateWithoutRequestsInput, RequestPermissionUncheckedCreateWithoutRequestsInput>
  }

  export type RequestPermissionUpdateWithWhereUniqueWithoutRequestsInput = {
    where: RequestPermissionWhereUniqueInput
    data: XOR<RequestPermissionUpdateWithoutRequestsInput, RequestPermissionUncheckedUpdateWithoutRequestsInput>
  }

  export type RequestPermissionUpdateManyWithWhereWithoutRequestsInput = {
    where: RequestPermissionScalarWhereInput
    data: XOR<RequestPermissionUpdateManyMutationInput, RequestPermissionUncheckedUpdateManyWithoutRequestsInput>
  }

  export type DoctorUpsertWithoutRequestsInput = {
    update: XOR<DoctorUpdateWithoutRequestsInput, DoctorUncheckedUpdateWithoutRequestsInput>
    create: XOR<DoctorCreateWithoutRequestsInput, DoctorUncheckedCreateWithoutRequestsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutRequestsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutRequestsInput, DoctorUncheckedUpdateWithoutRequestsInput>
  }

  export type DoctorUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUpdateManyWithoutDoctorNestedInput
    serviceprovider?: ServiceProviderUpdateOneRequiredWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceproviderId?: StringFieldUpdateOperationsInput | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type OthersAppointmentCreateWithoutAppointmentInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    relationship: string
    age: number
    gender: $Enums.Gender
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OthersAppointmentUncheckedCreateWithoutAppointmentInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    relationship: string
    age: number
    gender: $Enums.Gender
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OthersAppointmentCreateOrConnectWithoutAppointmentInput = {
    where: OthersAppointmentWhereUniqueInput
    create: XOR<OthersAppointmentCreateWithoutAppointmentInput, OthersAppointmentUncheckedCreateWithoutAppointmentInput>
  }

  export type CurrentLocationCreateWithoutAppointmentInput = {
    id?: string
    lat: number
    long: number
  }

  export type CurrentLocationUncheckedCreateWithoutAppointmentInput = {
    id?: string
    lat: number
    long: number
  }

  export type CurrentLocationCreateOrConnectWithoutAppointmentInput = {
    where: CurrentLocationWhereUniqueInput
    create: XOR<CurrentLocationCreateWithoutAppointmentInput, CurrentLocationUncheckedCreateWithoutAppointmentInput>
  }

  export type SlotCreateWithoutAppointmentInput = {
    id?: string
    slotDate?: Date | string | null
    startTime: Date | string
    endTime: Date | string
    isBooked?: boolean
    bookedAt?: Date | string | null
    updatedAt?: Date | string
    schedule: ScheduleCreateNestedOneWithoutSlotsInput
  }

  export type SlotUncheckedCreateWithoutAppointmentInput = {
    id?: string
    slotDate?: Date | string | null
    startTime: Date | string
    endTime: Date | string
    isBooked?: boolean
    scheduleId: string
    bookedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type SlotCreateOrConnectWithoutAppointmentInput = {
    where: SlotWhereUniqueInput
    create: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>
  }

  export type UserCreateWithoutAppointmentsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
  }

  export type ServiceProviderCreateWithoutAppointmentInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutAppointmentInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutAppointmentInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutAppointmentInput, ServiceProviderUncheckedCreateWithoutAppointmentInput>
  }

  export type PatientCreateWithoutAppointmentInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    user: UserCreateNestedOneWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labResults?: LabResultCreateNestedManyWithoutPatientInput
    adminPanel: AdminPanelCreateNestedOneWithoutPatientInput
    tags?: TagCreateNestedManyWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutAppointmentInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutPatientInput
    tags?: TagUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type PatientCreateOrConnectWithoutAppointmentInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentInput, PatientUncheckedCreateWithoutAppointmentInput>
  }

  export type PaymentCreateWithoutAppointmentInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    transaction?: TransactionCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutAppointmentInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    userId: string
    transaction?: TransactionUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutAppointmentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>
  }

  export type PaymentCreateManyAppointmentInputEnvelope = {
    data: PaymentCreateManyAppointmentInput | PaymentCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderCreateNestedManyWithoutTagsInput
    patients?: PatientCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderUncheckedCreateNestedManyWithoutTagsInput
    patients?: PatientUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutAppointmentsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutAppointmentsInput, TagUncheckedCreateWithoutAppointmentsInput>
  }

  export type OthersAppointmentUpsertWithoutAppointmentInput = {
    update: XOR<OthersAppointmentUpdateWithoutAppointmentInput, OthersAppointmentUncheckedUpdateWithoutAppointmentInput>
    create: XOR<OthersAppointmentCreateWithoutAppointmentInput, OthersAppointmentUncheckedCreateWithoutAppointmentInput>
    where?: OthersAppointmentWhereInput
  }

  export type OthersAppointmentUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: OthersAppointmentWhereInput
    data: XOR<OthersAppointmentUpdateWithoutAppointmentInput, OthersAppointmentUncheckedUpdateWithoutAppointmentInput>
  }

  export type OthersAppointmentUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OthersAppointmentUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrentLocationUpsertWithoutAppointmentInput = {
    update: XOR<CurrentLocationUpdateWithoutAppointmentInput, CurrentLocationUncheckedUpdateWithoutAppointmentInput>
    create: XOR<CurrentLocationCreateWithoutAppointmentInput, CurrentLocationUncheckedCreateWithoutAppointmentInput>
    where?: CurrentLocationWhereInput
  }

  export type CurrentLocationUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: CurrentLocationWhereInput
    data: XOR<CurrentLocationUpdateWithoutAppointmentInput, CurrentLocationUncheckedUpdateWithoutAppointmentInput>
  }

  export type CurrentLocationUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
  }

  export type CurrentLocationUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
  }

  export type SlotUpsertWithoutAppointmentInput = {
    update: XOR<SlotUpdateWithoutAppointmentInput, SlotUncheckedUpdateWithoutAppointmentInput>
    create: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>
    where?: SlotWhereInput
  }

  export type SlotUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: SlotWhereInput
    data: XOR<SlotUpdateWithoutAppointmentInput, SlotUncheckedUpdateWithoutAppointmentInput>
  }

  export type SlotUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateOneRequiredWithoutSlotsNestedInput
  }

  export type SlotUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    scheduleId?: StringFieldUpdateOperationsInput | string
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAppointmentsInput = {
    update: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceProviderUpsertWithoutAppointmentInput = {
    update: XOR<ServiceProviderUpdateWithoutAppointmentInput, ServiceProviderUncheckedUpdateWithoutAppointmentInput>
    create: XOR<ServiceProviderCreateWithoutAppointmentInput, ServiceProviderUncheckedCreateWithoutAppointmentInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutAppointmentInput, ServiceProviderUncheckedUpdateWithoutAppointmentInput>
  }

  export type ServiceProviderUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type PatientUpsertWithoutAppointmentInput = {
    update: XOR<PatientUpdateWithoutAppointmentInput, PatientUncheckedUpdateWithoutAppointmentInput>
    create: XOR<PatientCreateWithoutAppointmentInput, PatientUncheckedCreateWithoutAppointmentInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentInput, PatientUncheckedUpdateWithoutAppointmentInput>
  }

  export type PatientUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUpdateManyWithoutPatientNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutPatientNestedInput
    tags?: TagUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutPatientNestedInput
    tags?: TagUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutAppointmentInput, PaymentUncheckedUpdateWithoutAppointmentInput>
    create: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutAppointmentInput, PaymentUncheckedUpdateWithoutAppointmentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutAppointmentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type TagUpsertWithWhereUniqueWithoutAppointmentsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutAppointmentsInput, TagUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<TagCreateWithoutAppointmentsInput, TagUncheckedCreateWithoutAppointmentsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutAppointmentsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutAppointmentsInput, TagUncheckedUpdateWithoutAppointmentsInput>
  }

  export type TagUpdateManyWithWhereWithoutAppointmentsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type AppointmentCreateWithoutOthersAppointmentInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentLocation?: CurrentLocationCreateNestedOneWithoutAppointmentInput
    slot: SlotCreateNestedOneWithoutAppointmentInput
    user: UserCreateNestedOneWithoutAppointmentsInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutAppointmentInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
    payment?: PaymentCreateNestedManyWithoutAppointmentInput
    tags?: TagCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutOthersAppointmentInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentLocation?: CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput
    payment?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    tags?: TagUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentCreateOrConnectWithoutOthersAppointmentInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutOthersAppointmentInput, AppointmentUncheckedCreateWithoutOthersAppointmentInput>
  }

  export type AppointmentUpsertWithoutOthersAppointmentInput = {
    update: XOR<AppointmentUpdateWithoutOthersAppointmentInput, AppointmentUncheckedUpdateWithoutOthersAppointmentInput>
    create: XOR<AppointmentCreateWithoutOthersAppointmentInput, AppointmentUncheckedCreateWithoutOthersAppointmentInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutOthersAppointmentInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutOthersAppointmentInput, AppointmentUncheckedUpdateWithoutOthersAppointmentInput>
  }

  export type AppointmentUpdateWithoutOthersAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentLocation?: CurrentLocationUpdateOneWithoutAppointmentNestedInput
    slot?: SlotUpdateOneRequiredWithoutAppointmentNestedInput
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
    payment?: PaymentUpdateManyWithoutAppointmentNestedInput
    tags?: TagUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutOthersAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentLocation?: CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    tags?: TagUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type ServiceProviderCreateWithoutScheduleInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutScheduleInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutScheduleInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutScheduleInput, ServiceProviderUncheckedCreateWithoutScheduleInput>
  }

  export type SlotCreateWithoutScheduleInput = {
    id?: string
    slotDate?: Date | string | null
    startTime: Date | string
    endTime: Date | string
    isBooked?: boolean
    bookedAt?: Date | string | null
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutSlotInput
  }

  export type SlotUncheckedCreateWithoutScheduleInput = {
    id?: string
    slotDate?: Date | string | null
    startTime: Date | string
    endTime: Date | string
    isBooked?: boolean
    bookedAt?: Date | string | null
    updatedAt?: Date | string
    appointment?: AppointmentUncheckedCreateNestedOneWithoutSlotInput
  }

  export type SlotCreateOrConnectWithoutScheduleInput = {
    where: SlotWhereUniqueInput
    create: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput>
  }

  export type SlotCreateManyScheduleInputEnvelope = {
    data: SlotCreateManyScheduleInput | SlotCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ClinicInfoCreateWithoutScheduleInput = {
    id?: string
    clinicName: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    address: AddressCreateNestedOneWithoutClinicInfoInput
    serviceProviders?: ServiceProviderCreateNestedManyWithoutClinicInfoInput
  }

  export type ClinicInfoUncheckedCreateWithoutScheduleInput = {
    id?: string
    clinicName: string
    addressId: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderUncheckedCreateNestedManyWithoutClinicInfoInput
  }

  export type ClinicInfoCreateOrConnectWithoutScheduleInput = {
    where: ClinicInfoWhereUniqueInput
    create: XOR<ClinicInfoCreateWithoutScheduleInput, ClinicInfoUncheckedCreateWithoutScheduleInput>
  }

  export type ClinicInfoCreateManyScheduleInputEnvelope = {
    data: ClinicInfoCreateManyScheduleInput | ClinicInfoCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ServiceProviderUpsertWithoutScheduleInput = {
    update: XOR<ServiceProviderUpdateWithoutScheduleInput, ServiceProviderUncheckedUpdateWithoutScheduleInput>
    create: XOR<ServiceProviderCreateWithoutScheduleInput, ServiceProviderUncheckedCreateWithoutScheduleInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutScheduleInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutScheduleInput, ServiceProviderUncheckedUpdateWithoutScheduleInput>
  }

  export type ServiceProviderUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type SlotUpsertWithWhereUniqueWithoutScheduleInput = {
    where: SlotWhereUniqueInput
    update: XOR<SlotUpdateWithoutScheduleInput, SlotUncheckedUpdateWithoutScheduleInput>
    create: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput>
  }

  export type SlotUpdateWithWhereUniqueWithoutScheduleInput = {
    where: SlotWhereUniqueInput
    data: XOR<SlotUpdateWithoutScheduleInput, SlotUncheckedUpdateWithoutScheduleInput>
  }

  export type SlotUpdateManyWithWhereWithoutScheduleInput = {
    where: SlotScalarWhereInput
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyWithoutScheduleInput>
  }

  export type SlotScalarWhereInput = {
    AND?: SlotScalarWhereInput | SlotScalarWhereInput[]
    OR?: SlotScalarWhereInput[]
    NOT?: SlotScalarWhereInput | SlotScalarWhereInput[]
    id?: StringFilter<"Slot"> | string
    slotDate?: DateTimeNullableFilter<"Slot"> | Date | string | null
    startTime?: DateTimeFilter<"Slot"> | Date | string
    endTime?: DateTimeFilter<"Slot"> | Date | string
    isBooked?: BoolFilter<"Slot"> | boolean
    scheduleId?: StringFilter<"Slot"> | string
    bookedAt?: DateTimeNullableFilter<"Slot"> | Date | string | null
    updatedAt?: DateTimeFilter<"Slot"> | Date | string
  }

  export type ClinicInfoUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ClinicInfoWhereUniqueInput
    update: XOR<ClinicInfoUpdateWithoutScheduleInput, ClinicInfoUncheckedUpdateWithoutScheduleInput>
    create: XOR<ClinicInfoCreateWithoutScheduleInput, ClinicInfoUncheckedCreateWithoutScheduleInput>
  }

  export type ClinicInfoUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ClinicInfoWhereUniqueInput
    data: XOR<ClinicInfoUpdateWithoutScheduleInput, ClinicInfoUncheckedUpdateWithoutScheduleInput>
  }

  export type ClinicInfoUpdateManyWithWhereWithoutScheduleInput = {
    where: ClinicInfoScalarWhereInput
    data: XOR<ClinicInfoUpdateManyMutationInput, ClinicInfoUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ClinicInfoScalarWhereInput = {
    AND?: ClinicInfoScalarWhereInput | ClinicInfoScalarWhereInput[]
    OR?: ClinicInfoScalarWhereInput[]
    NOT?: ClinicInfoScalarWhereInput | ClinicInfoScalarWhereInput[]
    id?: StringFilter<"ClinicInfo"> | string
    clinicName?: StringFilter<"ClinicInfo"> | string
    addressId?: StringFilter<"ClinicInfo"> | string
    phone?: StringFilter<"ClinicInfo"> | string
    images?: StringNullableListFilter<"ClinicInfo">
    scheduleId?: StringNullableFilter<"ClinicInfo"> | string | null
    createdAt?: DateTimeFilter<"ClinicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicInfo"> | Date | string
  }

  export type ScheduleCreateWithoutSlotsInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders: ServiceProviderCreateNestedOneWithoutScheduleInput
    clinicInfo?: ClinicInfoCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutSlotsInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    serviceProviderId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicInfo?: ClinicInfoUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutSlotsInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutSlotsInput, ScheduleUncheckedCreateWithoutSlotsInput>
  }

  export type AppointmentCreateWithoutSlotInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationCreateNestedOneWithoutAppointmentInput
    user: UserCreateNestedOneWithoutAppointmentsInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutAppointmentInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
    payment?: PaymentCreateNestedManyWithoutAppointmentInput
    tags?: TagCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutSlotInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    userId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput
    payment?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    tags?: TagUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentCreateOrConnectWithoutSlotInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>
  }

  export type ScheduleUpsertWithoutSlotsInput = {
    update: XOR<ScheduleUpdateWithoutSlotsInput, ScheduleUncheckedUpdateWithoutSlotsInput>
    create: XOR<ScheduleCreateWithoutSlotsInput, ScheduleUncheckedCreateWithoutSlotsInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutSlotsInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutSlotsInput, ScheduleUncheckedUpdateWithoutSlotsInput>
  }

  export type ScheduleUpdateWithoutSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUpdateOneRequiredWithoutScheduleNestedInput
    clinicInfo?: ClinicInfoUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicInfo?: ClinicInfoUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type AppointmentUpsertWithoutSlotInput = {
    update: XOR<AppointmentUpdateWithoutSlotInput, AppointmentUncheckedUpdateWithoutSlotInput>
    create: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutSlotInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutSlotInput, AppointmentUncheckedUpdateWithoutSlotInput>
  }

  export type AppointmentUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUpdateOneWithoutAppointmentNestedInput
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
    payment?: PaymentUpdateManyWithoutAppointmentNestedInput
    tags?: TagUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    tags?: TagUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type AddressCreateWithoutClinicInfoInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    user?: UserCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutClinicInfoInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    userId?: string | null
  }

  export type AddressCreateOrConnectWithoutClinicInfoInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutClinicInfoInput, AddressUncheckedCreateWithoutClinicInfoInput>
  }

  export type ServiceProviderCreateWithoutClinicInfoInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutClinicInfoInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutClinicInfoInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutClinicInfoInput, ServiceProviderUncheckedCreateWithoutClinicInfoInput>
  }

  export type ServiceProviderCreateManyClinicInfoInputEnvelope = {
    data: ServiceProviderCreateManyClinicInfoInput | ServiceProviderCreateManyClinicInfoInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutClinicInfoInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders: ServiceProviderCreateNestedOneWithoutScheduleInput
    slots?: SlotCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutClinicInfoInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    serviceProviderId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slots?: SlotUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutClinicInfoInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutClinicInfoInput, ScheduleUncheckedCreateWithoutClinicInfoInput>
  }

  export type AddressUpsertWithoutClinicInfoInput = {
    update: XOR<AddressUpdateWithoutClinicInfoInput, AddressUncheckedUpdateWithoutClinicInfoInput>
    create: XOR<AddressCreateWithoutClinicInfoInput, AddressUncheckedCreateWithoutClinicInfoInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutClinicInfoInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutClinicInfoInput, AddressUncheckedUpdateWithoutClinicInfoInput>
  }

  export type AddressUpdateWithoutClinicInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutClinicInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceProviderUpsertWithWhereUniqueWithoutClinicInfoInput = {
    where: ServiceProviderWhereUniqueInput
    update: XOR<ServiceProviderUpdateWithoutClinicInfoInput, ServiceProviderUncheckedUpdateWithoutClinicInfoInput>
    create: XOR<ServiceProviderCreateWithoutClinicInfoInput, ServiceProviderUncheckedCreateWithoutClinicInfoInput>
  }

  export type ServiceProviderUpdateWithWhereUniqueWithoutClinicInfoInput = {
    where: ServiceProviderWhereUniqueInput
    data: XOR<ServiceProviderUpdateWithoutClinicInfoInput, ServiceProviderUncheckedUpdateWithoutClinicInfoInput>
  }

  export type ServiceProviderUpdateManyWithWhereWithoutClinicInfoInput = {
    where: ServiceProviderScalarWhereInput
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyWithoutClinicInfoInput>
  }

  export type ScheduleUpsertWithoutClinicInfoInput = {
    update: XOR<ScheduleUpdateWithoutClinicInfoInput, ScheduleUncheckedUpdateWithoutClinicInfoInput>
    create: XOR<ScheduleCreateWithoutClinicInfoInput, ScheduleUncheckedCreateWithoutClinicInfoInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutClinicInfoInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutClinicInfoInput, ScheduleUncheckedUpdateWithoutClinicInfoInput>
  }

  export type ScheduleUpdateWithoutClinicInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUpdateOneRequiredWithoutScheduleNestedInput
    slots?: SlotUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutClinicInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slots?: SlotUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type UserCreateWithoutAddressInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type ClinicInfoCreateWithoutAddressInput = {
    id?: string
    clinicName: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderCreateNestedManyWithoutClinicInfoInput
    schedule?: ScheduleCreateNestedOneWithoutClinicInfoInput
  }

  export type ClinicInfoUncheckedCreateWithoutAddressInput = {
    id?: string
    clinicName: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    scheduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceProviders?: ServiceProviderUncheckedCreateNestedManyWithoutClinicInfoInput
  }

  export type ClinicInfoCreateOrConnectWithoutAddressInput = {
    where: ClinicInfoWhereUniqueInput
    create: XOR<ClinicInfoCreateWithoutAddressInput, ClinicInfoUncheckedCreateWithoutAddressInput>
  }

  export type UserUpsertWithoutAddressInput = {
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClinicInfoUpsertWithoutAddressInput = {
    update: XOR<ClinicInfoUpdateWithoutAddressInput, ClinicInfoUncheckedUpdateWithoutAddressInput>
    create: XOR<ClinicInfoCreateWithoutAddressInput, ClinicInfoUncheckedCreateWithoutAddressInput>
    where?: ClinicInfoWhereInput
  }

  export type ClinicInfoUpdateToOneWithWhereWithoutAddressInput = {
    where?: ClinicInfoWhereInput
    data: XOR<ClinicInfoUpdateWithoutAddressInput, ClinicInfoUncheckedUpdateWithoutAddressInput>
  }

  export type ClinicInfoUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUpdateManyWithoutClinicInfoNestedInput
    schedule?: ScheduleUpdateOneWithoutClinicInfoNestedInput
  }

  export type ClinicInfoUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUncheckedUpdateManyWithoutClinicInfoNestedInput
  }

  export type ServiceProviderCreateWithoutEducationInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutEducationInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutEducationInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutEducationInput, ServiceProviderUncheckedCreateWithoutEducationInput>
  }

  export type ServiceProviderUpsertWithoutEducationInput = {
    update: XOR<ServiceProviderUpdateWithoutEducationInput, ServiceProviderUncheckedUpdateWithoutEducationInput>
    create: XOR<ServiceProviderCreateWithoutEducationInput, ServiceProviderUncheckedCreateWithoutEducationInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutEducationInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutEducationInput, ServiceProviderUncheckedUpdateWithoutEducationInput>
  }

  export type ServiceProviderUpdateWithoutEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type ServiceProviderCreateWithoutWorkExperienceInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutWorkExperienceInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutWorkExperienceInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutWorkExperienceInput, ServiceProviderUncheckedCreateWithoutWorkExperienceInput>
  }

  export type ServiceProviderUpsertWithoutWorkExperienceInput = {
    update: XOR<ServiceProviderUpdateWithoutWorkExperienceInput, ServiceProviderUncheckedUpdateWithoutWorkExperienceInput>
    create: XOR<ServiceProviderCreateWithoutWorkExperienceInput, ServiceProviderUncheckedCreateWithoutWorkExperienceInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutWorkExperienceInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutWorkExperienceInput, ServiceProviderUncheckedUpdateWithoutWorkExperienceInput>
  }

  export type ServiceProviderUpdateWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type ServiceProviderCreateWithoutAwardsInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    tags?: TagCreateNestedManyWithoutServiceProvidersInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutAwardsInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
    tags?: TagUncheckedCreateNestedManyWithoutServiceProvidersInput
  }

  export type ServiceProviderCreateOrConnectWithoutAwardsInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutAwardsInput, ServiceProviderUncheckedCreateWithoutAwardsInput>
  }

  export type ServiceProviderUpsertWithoutAwardsInput = {
    update: XOR<ServiceProviderUpdateWithoutAwardsInput, ServiceProviderUncheckedUpdateWithoutAwardsInput>
    create: XOR<ServiceProviderCreateWithoutAwardsInput, ServiceProviderUncheckedCreateWithoutAwardsInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutAwardsInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutAwardsInput, ServiceProviderUncheckedUpdateWithoutAwardsInput>
  }

  export type ServiceProviderUpdateWithoutAwardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutAwardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type AppointmentCreateWithoutCurrentLocationInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentCreateNestedOneWithoutAppointmentInput
    slot: SlotCreateNestedOneWithoutAppointmentInput
    user: UserCreateNestedOneWithoutAppointmentsInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutAppointmentInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
    payment?: PaymentCreateNestedManyWithoutAppointmentInput
    tags?: TagCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutCurrentLocationInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput
    payment?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    tags?: TagUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type AppointmentCreateOrConnectWithoutCurrentLocationInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutCurrentLocationInput, AppointmentUncheckedCreateWithoutCurrentLocationInput>
  }

  export type AppointmentUpsertWithoutCurrentLocationInput = {
    update: XOR<AppointmentUpdateWithoutCurrentLocationInput, AppointmentUncheckedUpdateWithoutCurrentLocationInput>
    create: XOR<AppointmentCreateWithoutCurrentLocationInput, AppointmentUncheckedCreateWithoutCurrentLocationInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutCurrentLocationInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutCurrentLocationInput, AppointmentUncheckedUpdateWithoutCurrentLocationInput>
  }

  export type AppointmentUpdateWithoutCurrentLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUpdateOneWithoutAppointmentNestedInput
    slot?: SlotUpdateOneRequiredWithoutAppointmentNestedInput
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
    payment?: PaymentUpdateManyWithoutAppointmentNestedInput
    tags?: TagUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutCurrentLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    tags?: TagUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    patient?: PatientCreateNestedManyWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    lab?: LabCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedOneWithoutUserInput
    nursing?: NursingCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    username?: string | null
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    phone?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    bloodGroup?: $Enums.BloodGroup | null
    isActive?: boolean
    isVerified?: boolean
    profilePic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    patient?: PatientUncheckedCreateNestedManyWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    lab?: LabUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput
    nursing?: NursingUncheckedCreateNestedOneWithoutUserInput
    doctorsAssistant?: DoctorsAssistantUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    patient?: PatientUpdateManyWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    lab?: LabUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateOneWithoutUserNestedInput
    nursing?: NursingUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableEnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    lab?: LabUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput
    nursing?: NursingUncheckedUpdateOneWithoutUserNestedInput
    doctorsAssistant?: DoctorsAssistantUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceProviderCreateWithoutTagsInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    createdAt?: Date | string
    schedule?: ScheduleCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentCreateNestedManyWithoutServiceProviderInput
    education?: EducationCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceCreateNestedManyWithoutServiceProviderInput
    awards?: AwardCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanCreateNestedManyWithoutServiceProviderInput
    rating?: RatingCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorCreateNestedManyWithoutServiceproviderInput
    clinicInfo?: ClinicInfoCreateNestedOneWithoutServiceProvidersInput
    adminPanel?: AdminPanelCreateNestedOneWithoutServiceProviderInput
    user: UserCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutTagsInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
    schedule?: ScheduleUncheckedCreateNestedManyWithoutServiceProvidersInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    education?: EducationUncheckedCreateNestedManyWithoutServiceProviderInput
    workExperience?: WorkExperienceUncheckedCreateNestedManyWithoutServiceProviderInput
    awards?: AwardUncheckedCreateNestedManyWithoutServiceProviderInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceProviderInput
    therapyPlans?: TherapyPlanUncheckedCreateNestedManyWithoutServiceProviderInput
    rating?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutServiceProviderInput
    doctor?: DoctorUncheckedCreateNestedManyWithoutServiceproviderInput
  }

  export type ServiceProviderCreateOrConnectWithoutTagsInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutTagsInput, ServiceProviderUncheckedCreateWithoutTagsInput>
  }

  export type AppointmentCreateWithoutTagsInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationCreateNestedOneWithoutAppointmentInput
    slot: SlotCreateNestedOneWithoutAppointmentInput
    user: UserCreateNestedOneWithoutAppointmentsInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutAppointmentInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
    payment?: PaymentCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutTagsInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    othersAppointment?: OthersAppointmentUncheckedCreateNestedOneWithoutAppointmentInput
    currentLocation?: CurrentLocationUncheckedCreateNestedOneWithoutAppointmentInput
    payment?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutTagsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutTagsInput, AppointmentUncheckedCreateWithoutTagsInput>
  }

  export type PatientCreateWithoutTagsInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    user: UserCreateNestedOneWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labResults?: LabResultCreateNestedManyWithoutPatientInput
    adminPanel: AdminPanelCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTagsInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TherapyPlanUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTagsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTagsInput, PatientUncheckedCreateWithoutTagsInput>
  }

  export type ServiceProviderUpsertWithWhereUniqueWithoutTagsInput = {
    where: ServiceProviderWhereUniqueInput
    update: XOR<ServiceProviderUpdateWithoutTagsInput, ServiceProviderUncheckedUpdateWithoutTagsInput>
    create: XOR<ServiceProviderCreateWithoutTagsInput, ServiceProviderUncheckedCreateWithoutTagsInput>
  }

  export type ServiceProviderUpdateWithWhereUniqueWithoutTagsInput = {
    where: ServiceProviderWhereUniqueInput
    data: XOR<ServiceProviderUpdateWithoutTagsInput, ServiceProviderUncheckedUpdateWithoutTagsInput>
  }

  export type ServiceProviderUpdateManyWithWhereWithoutTagsInput = {
    where: ServiceProviderScalarWhereInput
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyWithoutTagsInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutTagsInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutTagsInput, AppointmentUncheckedUpdateWithoutTagsInput>
    create: XOR<AppointmentCreateWithoutTagsInput, AppointmentUncheckedCreateWithoutTagsInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutTagsInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutTagsInput, AppointmentUncheckedUpdateWithoutTagsInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutTagsInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutTagsInput>
  }

  export type PatientUpsertWithWhereUniqueWithoutTagsInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutTagsInput, PatientUncheckedUpdateWithoutTagsInput>
    create: XOR<PatientCreateWithoutTagsInput, PatientUncheckedCreateWithoutTagsInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutTagsInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutTagsInput, PatientUncheckedUpdateWithoutTagsInput>
  }

  export type PatientUpdateManyWithWhereWithoutTagsInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutTagsInput>
  }

  export type AccountCreateManyUserInput = {
    id?: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyUserInput = {
    id?: string
    age: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
    adminPanelId: string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    appointmentId: string
  }

  export type MedicalRecordCreateManyUserInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    description?: string | null
    recordId?: string | null
    attachment?: string | null
    serviceProviderId?: string | null
  }

  export type AppointmentCreateManyUserInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    serviceProviderId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateManyUserInput = {
    id?: string
    serviceProviderType: $Enums.ProviderType
    serviceProviderId: string
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    message: string
    type: string
    priority?: string
    isRead?: boolean
    expiresAt?: Date | string | null
    isRecurring?: boolean
    groupId?: string | null
    createdAt?: Date | string
    relatedEntityId?: string | null
    relatedEntity?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    entity: string
    entityId: string
    actionType: $Enums.ActionType
    status: $Enums.Status
    ipAddress?: string | null
    device?: string | null
    performedBy: string
    timestamp?: Date | string
  }

  export type ServiceProviderCreateManyUserInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    adminPanelId?: string | null
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUpdateManyWithoutPatientNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutPatientNestedInput
    tags?: TagUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutPatientNestedInput
    tags?: TagUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    appointment?: AppointmentUpdateOneRequiredWithoutPaymentNestedInput
    transaction?: TransactionUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: StringFieldUpdateOperationsInput | string
    transaction?: TransactionUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvider?: ServiceProviderUpdateOneWithoutMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUpdateOneWithoutAppointmentNestedInput
    slot?: SlotUpdateOneRequiredWithoutAppointmentNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
    payment?: PaymentUpdateManyWithoutAppointmentNestedInput
    tags?: TagUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    tags?: TagUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutRatingNestedInput
  }

  export type RatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type ServiceProviderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergyCreateManyPatientInput = {
    id?: string
    allergen: string
    type: string
    severity: string
    reaction: string
  }

  export type TherapyPlanCreateManyPatientInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    serviceProvideId: string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    serviceProviderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: string
    doctorId: string
    notes?: string | null
    dateIssued: Date | string
  }

  export type LabResultCreateManyPatientInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    serviceProvideId: string
  }

  export type AllergyUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
  }

  export type AllergyUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
  }

  export type AllergyUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
  }

  export type TherapyPlanUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutTherapyPlansNestedInput
  }

  export type TherapyPlanUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    serviceProvideId?: StringFieldUpdateOperationsInput | string
  }

  export type TherapyPlanUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    serviceProvideId?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUpdateOneWithoutAppointmentNestedInput
    slot?: SlotUpdateOneRequiredWithoutAppointmentNestedInput
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput
    payment?: PaymentUpdateManyWithoutAppointmentNestedInput
    tags?: TagUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    tags?: TagUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationUpdateManyWithoutPrescriptionNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabResultUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutLabResultsNestedInput
  }

  export type LabResultUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    serviceProvideId?: StringFieldUpdateOperationsInput | string
  }

  export type LabResultUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    serviceProvideId?: StringFieldUpdateOperationsInput | string
  }

  export type TagUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUpdateManyWithoutTagsNestedInput
    appointments?: AppointmentUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUncheckedUpdateManyWithoutTagsNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderCreateManyAdminPanelInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    clinicInfoId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type PatientCreateManyAdminPanelInput = {
    id?: string
    age: string
    userId: string
    conditions?: PatientCreateconditionsInput | string[]
    bloodGroup: $Enums.BloodGroup
  }

  export type SuperAdminCreateManyAdminPanelInput = {
    id?: string
    userId: string
    permissions?: SuperAdminCreatepermissionsInput | string[]
    status: $Enums.Status
  }

  export type AdminCreateManyAdminPanelInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    superAdminId: string
  }

  export type ServiceProviderUpdateWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type ServiceProviderUncheckedUpdateManyWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUpdateManyWithoutPatientNestedInput
    tags?: TagUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutPatientNestedInput
    tags?: TagUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
  }

  export type SuperAdminUpdateWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    user?: UserUpdateOneRequiredWithoutSuperAdminNestedInput
    admin?: AdminUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminUncheckedUpdateWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    admin?: AdminUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminUncheckedUpdateManyWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: SuperAdminUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type AdminUpdateWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    superAdmin?: SuperAdminUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    superAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyWithoutAdminPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    superAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManySuperAdminInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    canManageProviders?: boolean
    canViewAllTransactions?: boolean
    canViewAllAppointments?: boolean
    adminPanelId: string
  }

  export type AdminUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutAdminIdNestedInput
  }

  export type AdminUncheckedUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    adminPanelId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    canManageProviders?: BoolFieldUpdateOperationsInput | boolean
    canViewAllTransactions?: BoolFieldUpdateOperationsInput | boolean
    canViewAllAppointments?: BoolFieldUpdateOperationsInput | boolean
    adminPanelId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleCreateManyServiceProvidersInput = {
    id?: string
    date?: Date | string | null
    dayOfWeek?: $Enums.WeekDay | null
    isRecurring?: boolean
    recurrenceType?: $Enums.RecurrenceType | null
    startTime: Date | string
    endTime: Date | string
    slotDuration: number
    location: string
    isAvailable?: boolean
    service: $Enums.Service
    status?: $Enums.Status
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyServiceProviderInput = {
    id?: string
    service?: AppointmentCreateserviceInput | $Enums.Service[]
    status: $Enums.Status
    appointmentTime: Date | string
    bookedAt?: Date | string
    reason?: string | null
    isForOthers?: boolean
    slotId: string
    userId: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationCreateManyServiceProviderInput = {
    id?: string
    university: string
    degree: string
    duration: string
  }

  export type WorkExperienceCreateManyServiceProviderInput = {
    id?: string
    clinic: string
    duration: string
  }

  export type AwardCreateManyServiceProviderInput = {
    id?: string
    date: string
    title: string
    description: string
  }

  export type LabResultCreateManyServiceProviderInput = {
    id?: string
    testName: string
    testDate: Date | string
    result: string
    referenceRange: string
    status: string
    patientId: string
  }

  export type TherapyPlanCreateManyServiceProviderInput = {
    id?: string
    planName: string
    date: Date | string
    type: string
    status: string
    details: string
    patientId: string
  }

  export type RatingCreateManyServiceProviderInput = {
    id?: string
    userId: string
    serviceProviderType: $Enums.ProviderType
    score: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateManyServiceProviderInput = {
    id?: string
    diagnosis: string
    prescription: string
    notes?: string | null
    userId: string
    description?: string | null
    recordId?: string | null
    attachment?: string | null
  }

  export type DoctorCreateManyServiceproviderInput = {
    id?: string
    userId: string
  }

  export type ScheduleUpdateWithoutServiceProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slots?: SlotUpdateManyWithoutScheduleNestedInput
    clinicInfo?: ClinicInfoUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutServiceProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slots?: SlotUncheckedUpdateManyWithoutScheduleNestedInput
    clinicInfo?: ClinicInfoUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutServiceProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayOfWeek?: NullableEnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceType?: NullableEnumRecurrenceTypeFieldUpdateOperationsInput | $Enums.RecurrenceType | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotDuration?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    service?: EnumServiceFieldUpdateOperationsInput | $Enums.Service
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUpdateOneWithoutAppointmentNestedInput
    slot?: SlotUpdateOneRequiredWithoutAppointmentNestedInput
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
    payment?: PaymentUpdateManyWithoutAppointmentNestedInput
    tags?: TagUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    tags?: TagUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    university?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type EducationUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    university?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type EducationUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    university?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type WorkExperienceUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinic?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type WorkExperienceUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinic?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type WorkExperienceUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinic?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type AwardUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AwardUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AwardUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type LabResultUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutLabResultsNestedInput
  }

  export type LabResultUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
  }

  export type LabResultUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    referenceRange?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
  }

  export type TherapyPlanUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput
  }

  export type TherapyPlanUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
  }

  export type TherapyPlanUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
  }

  export type RatingUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    score?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalRecordUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorUpdateWithoutServiceproviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUpdateManyWithoutDoctorNestedInput
    requests?: RequestUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutServiceproviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    assistants?: DoctorsAssistantUncheckedUpdateManyWithoutDoctorNestedInput
    requests?: RequestUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateManyWithoutServiceproviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TagUpdateWithoutServiceProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTagsNestedInput
    patients?: PatientUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutServiceProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTagsNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutServiceProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateManyDoctorInput = {
    id?: string
    patientId: string
    notes?: string | null
    dateIssued: Date | string
  }

  export type DoctorsAssistantCreateManyDoctorInput = {
    id?: string
    userId: string
  }

  export type RequestCreateManyDoctorInput = {
    id?: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationUpdateManyWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateIssued?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorsAssistantUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDoctorsAssistantNestedInput
    requestPermissions?: RequestPermissionUpdateManyWithoutDoctorsAssistantNestedInput
  }

  export type DoctorsAssistantUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestPermissions?: RequestPermissionUncheckedUpdateManyWithoutDoctorsAssistantNestedInput
  }

  export type DoctorsAssistantUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RequestUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPermissions?: RequestPermissionUpdateManyWithoutRequestsNestedInput
  }

  export type RequestUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPermissions?: RequestPermissionUncheckedUpdateManyWithoutRequestsNestedInput
  }

  export type RequestUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestPermissionCreateManyDoctorsAssistantInput = {
    id?: string
    name: string
    description?: string | null
    accessType: $Enums.PermissionType
  }

  export type RequestPermissionUpdateWithoutDoctorsAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
    requests?: RequestUpdateManyWithoutRequestPermissionsNestedInput
  }

  export type RequestPermissionUncheckedUpdateWithoutDoctorsAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
    requests?: RequestUncheckedUpdateManyWithoutRequestPermissionsNestedInput
  }

  export type RequestPermissionUncheckedUpdateManyWithoutDoctorsAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
  }

  export type MedicationCreateManyPrescriptionInput = {
    id?: string
    name: string
    dosage: string
    frequency: string
    duration: string
    status: string
  }

  export type MedicationUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MedicationUncheckedUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MedicationUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateManyPaymentInput = {
    id?: string
    gatewayTransactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    refundDetails?: string | null
  }

  export type TransactionUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gatewayTransactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gatewayTransactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gatewayTransactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequestUpdateWithoutRequestPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneWithoutRequestsNestedInput
  }

  export type RequestUncheckedUpdateWithoutRequestPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequestUncheckedUpdateManyWithoutRequestPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequestPermissionUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
    doctorsAssistant?: DoctorsAssistantUpdateOneWithoutRequestPermissionsNestedInput
  }

  export type RequestPermissionUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
    doctorsAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequestPermissionUncheckedUpdateManyWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumPermissionTypeFieldUpdateOperationsInput | $Enums.PermissionType
    doctorsAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyAppointmentInput = {
    id?: string
    transactionId: string
    amount: number
    status: $Enums.Status
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    refundDetails?: string | null
    userId: string
  }

  export type PaymentUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    transaction?: TransactionUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    transaction?: TransactionUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TagUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUpdateManyWithoutTagsNestedInput
    patients?: PatientUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUncheckedUpdateManyWithoutTagsNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotCreateManyScheduleInput = {
    id?: string
    slotDate?: Date | string | null
    startTime: Date | string
    endTime: Date | string
    isBooked?: boolean
    bookedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ClinicInfoCreateManyScheduleInput = {
    id?: string
    clinicName: string
    addressId: string
    phone: string
    images?: ClinicInfoCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlotUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUncheckedUpdateOneWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    bookedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicInfoUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutClinicInfoNestedInput
    serviceProviders?: ServiceProviderUpdateManyWithoutClinicInfoNestedInput
  }

  export type ClinicInfoUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProviders?: ServiceProviderUncheckedUpdateManyWithoutClinicInfoNestedInput
  }

  export type ClinicInfoUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicName?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    images?: ClinicInfoUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderCreateManyClinicInfoInput = {
    id?: string
    providerId: string
    name: string
    age?: number | null
    dob?: Date | string | null
    providerType: $Enums.ProviderType
    specialization?: ServiceProviderCreatespecializationInput | string[]
    fee?: number | null
    experience?: number | null
    description?: string | null
    service?: ServiceProviderCreateserviceInput | $Enums.Service[]
    status?: $Enums.Status
    document?: string | null
    registrationNumber?: string | null
    adminPanelId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ServiceProviderUpdateWithoutClinicInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    tags?: TagUpdateManyWithoutServiceProvidersNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutClinicInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
    tags?: TagUncheckedUpdateManyWithoutServiceProvidersNestedInput
  }

  export type ServiceProviderUncheckedUpdateManyWithoutClinicInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUpdateManyWithoutServiceproviderNestedInput
    clinicInfo?: ClinicInfoUpdateOneWithoutServiceProvidersNestedInput
    adminPanel?: AdminPanelUpdateOneWithoutServiceProviderNestedInput
    user?: UserUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUncheckedUpdateManyWithoutServiceProvidersNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    education?: EducationUncheckedUpdateManyWithoutServiceProviderNestedInput
    workExperience?: WorkExperienceUncheckedUpdateManyWithoutServiceProviderNestedInput
    awards?: AwardUncheckedUpdateManyWithoutServiceProviderNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutServiceProviderNestedInput
    therapyPlans?: TherapyPlanUncheckedUpdateManyWithoutServiceProviderNestedInput
    rating?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutServiceProviderNestedInput
    doctor?: DoctorUncheckedUpdateManyWithoutServiceproviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    specialization?: ServiceProviderUpdatespecializationInput | string[]
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceProviderUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUpdateOneWithoutAppointmentNestedInput
    slot?: SlotUpdateOneRequiredWithoutAppointmentNestedInput
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutAppointmentNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
    payment?: PaymentUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    othersAppointment?: OthersAppointmentUncheckedUpdateOneWithoutAppointmentNestedInput
    currentLocation?: CurrentLocationUncheckedUpdateOneWithoutAppointmentNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: AppointmentUpdateserviceInput | $Enums.Service[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isForOthers?: BoolFieldUpdateOperationsInput | boolean
    slotId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUpdateManyWithoutPatientNestedInput
    adminPanel?: AdminPanelUpdateOneRequiredWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TherapyPlanUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conditions?: PatientUpdateconditionsInput | string[]
    bloodGroup?: EnumBloodGroupFieldUpdateOperationsInput | $Enums.BloodGroup
    adminPanelId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}